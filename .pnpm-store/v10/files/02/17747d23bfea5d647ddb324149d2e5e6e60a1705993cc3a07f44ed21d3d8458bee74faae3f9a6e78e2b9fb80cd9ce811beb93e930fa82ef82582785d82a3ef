{"version":3,"sources":["/home/runner/work/kubb/kubb/packages/parser-ts/dist/chunk-5FZ7A36O.cjs","../src/factory.ts"],"names":["modifiers","questionToken"],"mappings":"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AAA;AACnB,MAAA;AACF,IAAA;AACF,EAAA;AAGgC,EAAA;AAEzB,EAAA;AACG,IAAA;AACkB,MAAA;AAChB,MAAA;AACN,QAAA;AACU,UAAA;AACmB,YAAA;AACzB,YAAA;AACA,YAAA;AACQ,YAAA;AACE,cAAA;AAEa,gBAAA;AACkB,kBAAA;AAEZ,kBAAA;AAKJ,oBAAA;AACC,sBAAA;AACT,oBAAA;AACS,sBAAA;AAChB,oBAAA;AACF,kBAAA;AAEqB,kBAAA;AACL,oBAAA;AAChB,kBAAA;AAES,kBAAA;AACQ,oBAAA;AACjB,kBAAA;AAEO,kBAAA;AAEM,gBAAA;AACjB,gBAAA;AACF,cAAA;AACQ,cAAA;AACV,YAAA;AACF,UAAA;AACF,QAAA;AACa,QAAA;AACf,MAAA;AACF,IAAA;AACQ,IAAA;AACkB,MAAA;AACS,MAAA;AACjC,MAAA;AACQ,MAAA;AAC0B,QAAA;AACD,QAAA;AACjC,MAAA;AACF,IAAA;AACF,EAAA;AACF;AAEsC;AACpC,EAAA;AACA,EAAA;AACA,EAAA;AAKC;AACkC,EAAA;AAEV,EAAA;AACR,IAAA;AACb,MAAA;AACQ,MAAA;AACY,QAAA;AACD,UAAA;AAChB,QAAA;AACH,MAAA;AACD,IAAA;AACH,EAAA;AAEe,EAAA;AACjB;AAEgC;AACQ,EAAA;AACrB,EAAA;AACqB,EAAA;AACrB,EAAA;AACqB,EAAA;AACA,EAAA;AACrB,EAAA;AACE,EAAA;AACiB,EAAA;AACtC;AAE6C;AAEE;AACH;AACD;AAEA;AAEE;AACX;AACM;AAEG;AAET;AACC;ADlIK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/home/runner/work/kubb/kubb/packages/parser-ts/dist/chunk-5FZ7A36O.cjs","sourcesContent":[null,"import { isNumber } from 'remeda'\nimport ts from 'typescript'\n\nconst { factory } = ts\n\n// https://ts-ast-viewer.com/\n\nexport const modifiers = {\n  async: factory.createModifier(ts.SyntaxKind.AsyncKeyword),\n  export: factory.createModifier(ts.SyntaxKind.ExportKeyword),\n  const: factory.createModifier(ts.SyntaxKind.ConstKeyword),\n  static: factory.createModifier(ts.SyntaxKind.StaticKeyword),\n} as const\n\nfunction isValidIdentifier(str: string): boolean {\n  if (!str.length || str.trim() !== str) {\n    return false\n  }\n  const node = ts.parseIsolatedEntityName(str, ts.ScriptTarget.Latest)\n\n  return !!node && node.kind === ts.SyntaxKind.Identifier && ts.identifierToKeywordKind(node.kind as unknown as ts.Identifier) === undefined\n}\n\nfunction propertyName(name: string | ts.PropertyName): ts.PropertyName {\n  if (typeof name === 'string') {\n    return isValidIdentifier(name) ? factory.createIdentifier(name) : factory.createStringLiteral(name)\n  }\n  return name\n}\n\nconst questionToken = factory.createToken(ts.SyntaxKind.QuestionToken)\n\nexport function createQuestionToken(token?: boolean | ts.QuestionToken) {\n  if (!token) {\n    return undefined\n  }\n  if (token === true) {\n    return questionToken\n  }\n  return token\n}\n\nexport function createIntersectionDeclaration({\n  nodes,\n  withParentheses,\n}: {\n  nodes: Array<ts.TypeNode>\n  withParentheses?: boolean\n}): ts.TypeNode | null {\n  if (!nodes.length) {\n    return null\n  }\n\n  if (nodes.length === 1) {\n    return nodes[0] || null\n  }\n\n  const node = factory.createIntersectionTypeNode(nodes)\n\n  if (withParentheses) {\n    return factory.createParenthesizedType(node)\n  }\n\n  return node\n}\n\n/**\n * Minimum nodes length of 2\n * @example `string & number`\n */\nexport function createTupleDeclaration({\n  nodes,\n  withParentheses,\n}: {\n  nodes: Array<ts.TypeNode>\n  withParentheses?: boolean\n}): ts.TypeNode | null {\n  if (!nodes.length) {\n    return null\n  }\n\n  if (nodes.length === 1) {\n    return nodes[0] || null\n  }\n\n  const node = factory.createTupleTypeNode(nodes)\n\n  if (withParentheses) {\n    return factory.createParenthesizedType(node)\n  }\n\n  return node\n}\n\nexport function createArrayDeclaration({\n  nodes,\n}: {\n  nodes: Array<ts.TypeNode>\n}): ts.TypeNode | null {\n  if (!nodes.length) {\n    return factory.createTupleTypeNode([])\n  }\n\n  if (nodes.length === 1) {\n    return factory.createArrayTypeNode(nodes.at(0)!)\n  }\n\n  return factory.createExpressionWithTypeArguments(factory.createIdentifier('Array'), [factory.createUnionTypeNode(nodes)])\n}\n\n/**\n * Minimum nodes length of 2\n * @example `string | number`\n */\nexport function createUnionDeclaration({\n  nodes,\n  withParentheses,\n}: {\n  nodes: Array<ts.TypeNode>\n  withParentheses?: boolean\n}): ts.TypeNode | null {\n  if (!nodes.length) {\n    return null\n  }\n\n  if (nodes.length === 1) {\n    return nodes[0] || null\n  }\n\n  const node = factory.createUnionTypeNode(nodes)\n\n  if (withParentheses) {\n    return factory.createParenthesizedType(node)\n  }\n\n  return node\n}\n\nexport function createPropertySignature({\n  readOnly,\n  modifiers = [],\n  name,\n  questionToken,\n  type,\n}: {\n  readOnly?: boolean\n  modifiers?: Array<ts.Modifier>\n  name: ts.PropertyName | string\n  questionToken?: ts.QuestionToken | boolean\n  type?: ts.TypeNode\n}) {\n  return factory.createPropertySignature(\n    [...modifiers, readOnly ? factory.createToken(ts.SyntaxKind.ReadonlyKeyword) : undefined].filter(Boolean),\n    propertyName(name),\n    createQuestionToken(questionToken),\n    type,\n  )\n}\n\nexport function createParameterSignature(\n  name: string | ts.BindingName,\n  {\n    modifiers,\n    dotDotDotToken,\n    questionToken,\n    type,\n    initializer,\n  }: {\n    decorators?: Array<ts.Decorator>\n    modifiers?: Array<ts.Modifier>\n    dotDotDotToken?: ts.DotDotDotToken\n    questionToken?: ts.QuestionToken | boolean\n    type?: ts.TypeNode\n    initializer?: ts.Expression\n  },\n): ts.ParameterDeclaration {\n  return factory.createParameterDeclaration(modifiers, dotDotDotToken, name, createQuestionToken(questionToken), type, initializer)\n}\n\nexport function createJSDoc({ comments }: { comments: string[] }) {\n  if (!comments.length) {\n    return null\n  }\n  return factory.createJSDocComment(\n    factory.createNodeArray(\n      comments.map((comment, i) => {\n        if (i === comments.length - 1) {\n          return factory.createJSDocText(comment)\n        }\n\n        return factory.createJSDocText(`${comment}\\n`)\n      }),\n    ),\n  )\n}\n\n/**\n * @link https://github.com/microsoft/TypeScript/issues/44151\n */\nexport function appendJSDocToNode<TNode extends ts.Node>({\n  node,\n  comments,\n}: {\n  node: TNode\n  comments: Array<string | undefined>\n}) {\n  const filteredComments = comments.filter(Boolean)\n\n  if (!filteredComments.length) {\n    return node\n  }\n\n  const text = filteredComments.reduce((acc = '', comment = '') => {\n    return `${acc}\\n * ${comment.replaceAll('*/', '*\\\\/')}`\n  }, '*')\n\n  // node: {...node}, with that ts.addSyntheticLeadingComment is appending\n  return ts.addSyntheticLeadingComment({ ...node }, ts.SyntaxKind.MultiLineCommentTrivia, `${text || '*'}\\n`, true)\n}\n\nexport function createIndexSignature(\n  type: ts.TypeNode,\n  {\n    modifiers,\n    indexName = 'key',\n    indexType = factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n  }: {\n    indexName?: string\n    indexType?: ts.TypeNode\n    decorators?: Array<ts.Decorator>\n    modifiers?: Array<ts.Modifier>\n  } = {},\n) {\n  return factory.createIndexSignature(modifiers, [createParameterSignature(indexName, { type: indexType })], type)\n}\n\nexport function createTypeAliasDeclaration({\n  modifiers,\n  name,\n  typeParameters,\n  type,\n}: {\n  modifiers?: Array<ts.Modifier>\n  name: string | ts.Identifier\n  typeParameters?: Array<ts.TypeParameterDeclaration>\n  type: ts.TypeNode\n}) {\n  return factory.createTypeAliasDeclaration(modifiers, name, typeParameters, type)\n}\n\nexport function createNamespaceDeclaration({\n  statements,\n  name,\n}: {\n  name: string\n  statements: ts.Statement[]\n}) {\n  return factory.createModuleDeclaration(\n    [factory.createToken(ts.SyntaxKind.ExportKeyword)],\n    factory.createIdentifier(name),\n    factory.createModuleBlock(statements),\n    ts.NodeFlags.Namespace,\n  )\n}\n\n/**\n * In { propertyName: string; name?: string } is `name` being used to make the type more unique when multiple same names are used.\n * @example `import { Pet as Cat } from './Pet'`\n */\nexport function createImportDeclaration({\n  name,\n  path,\n  isTypeOnly = false,\n  isNameSpace = false,\n}: {\n  name: string | Array<string | { propertyName: string; name?: string }>\n  path: string\n  isTypeOnly?: boolean\n  isNameSpace?: boolean\n}) {\n  if (!Array.isArray(name)) {\n    let importPropertyName: ts.Identifier | undefined = factory.createIdentifier(name)\n    let importName: ts.NamedImportBindings | undefined = undefined\n\n    if (isNameSpace) {\n      importPropertyName = undefined\n      importName = factory.createNamespaceImport(factory.createIdentifier(name))\n    }\n\n    return factory.createImportDeclaration(\n      undefined,\n      factory.createImportClause(isTypeOnly, importPropertyName, importName),\n      factory.createStringLiteral(path),\n      undefined,\n    )\n  }\n\n  return factory.createImportDeclaration(\n    undefined,\n    factory.createImportClause(\n      isTypeOnly,\n      undefined,\n      factory.createNamedImports(\n        name.map((item) => {\n          if (typeof item === 'object') {\n            const obj = item as { propertyName: string; name?: string }\n            if (obj.name) {\n              return factory.createImportSpecifier(false, factory.createIdentifier(obj.propertyName), factory.createIdentifier(obj.name))\n            }\n\n            return factory.createImportSpecifier(false, undefined, factory.createIdentifier(obj.propertyName))\n          }\n\n          return factory.createImportSpecifier(false, undefined, factory.createIdentifier(item))\n        }),\n      ),\n    ),\n    factory.createStringLiteral(path),\n    undefined,\n  )\n}\n\nexport function createExportDeclaration({\n  path,\n  asAlias,\n  isTypeOnly = false,\n  name,\n}: {\n  path: string\n  asAlias?: boolean\n  isTypeOnly?: boolean\n  name?: string | Array<ts.Identifier | string>\n}) {\n  if (name && !Array.isArray(name) && !asAlias) {\n    throw new Error('When using `name` as string, `asAlias` should be true')\n  }\n\n  if (!Array.isArray(name)) {\n    const parsedName = name?.match(/^\\d/) ? `_${name?.slice(1)}` : name\n\n    return factory.createExportDeclaration(\n      undefined,\n      isTypeOnly,\n      asAlias && parsedName ? factory.createNamespaceExport(factory.createIdentifier(parsedName)) : undefined,\n      factory.createStringLiteral(path),\n      undefined,\n    )\n  }\n\n  return factory.createExportDeclaration(\n    undefined,\n    isTypeOnly,\n    factory.createNamedExports(\n      name.map((propertyName) => {\n        return factory.createExportSpecifier(false, undefined, typeof propertyName === 'string' ? factory.createIdentifier(propertyName) : propertyName)\n      }),\n    ),\n    factory.createStringLiteral(path),\n    undefined,\n  )\n}\n\nexport function createEnumDeclaration({\n  type = 'enum',\n  name,\n  typeName,\n  enums,\n}: {\n  /**\n   * @default `'enum'`\n   */\n  type?: 'enum' | 'asConst' | 'asPascalConst' | 'constEnum' | 'literal'\n  /**\n   * Enum name in camelCase.\n   */\n  name: string\n  /**\n   * Enum name in PascalCase.\n   */\n  typeName: string\n  enums: [key: string | number, value: string | number | boolean][]\n}) {\n  if (type === 'literal') {\n    return [\n      factory.createTypeAliasDeclaration(\n        [factory.createToken(ts.SyntaxKind.ExportKeyword)],\n        factory.createIdentifier(typeName),\n        undefined,\n        factory.createUnionTypeNode(\n          enums\n            .map(([_key, value]) => {\n              if (isNumber(value)) {\n                return factory.createLiteralTypeNode(factory.createNumericLiteral(value?.toString()))\n              }\n\n              if (typeof value === 'boolean') {\n                return factory.createLiteralTypeNode(value ? factory.createTrue() : factory.createFalse())\n              }\n              if (value) {\n                return factory.createLiteralTypeNode(factory.createStringLiteral(value.toString()))\n              }\n\n              return undefined\n            })\n            .filter(Boolean),\n        ),\n      ),\n    ]\n  }\n\n  if (type === 'enum' || type === 'constEnum') {\n    return [\n      factory.createEnumDeclaration(\n        [factory.createToken(ts.SyntaxKind.ExportKeyword), type === 'constEnum' ? factory.createToken(ts.SyntaxKind.ConstKeyword) : undefined].filter(Boolean),\n        factory.createIdentifier(typeName),\n        enums\n          .map(([key, value]) => {\n            let initializer: ts.Expression = factory.createStringLiteral(value?.toString())\n\n            if (isNumber(Number.parseInt(value.toString()))) {\n              initializer = factory.createNumericLiteral(value as number)\n            }\n            if (typeof value === 'boolean') {\n              initializer = value ? factory.createTrue() : factory.createFalse()\n            }\n\n            if (isNumber(Number.parseInt(key.toString()))) {\n              return factory.createEnumMember(factory.createStringLiteral(`${typeName}_${key}`), initializer)\n            }\n\n            if (key) {\n              return factory.createEnumMember(factory.createStringLiteral(`${key}`), initializer)\n            }\n\n            return undefined\n          })\n          .filter(Boolean),\n      ),\n    ]\n  }\n\n  // used when using `as const` instead of an TypeScript enum.\n  const identifierName = type === 'asPascalConst' ? typeName : name\n\n  return [\n    factory.createVariableStatement(\n      [factory.createToken(ts.SyntaxKind.ExportKeyword)],\n      factory.createVariableDeclarationList(\n        [\n          factory.createVariableDeclaration(\n            factory.createIdentifier(identifierName),\n            undefined,\n            undefined,\n            factory.createAsExpression(\n              factory.createObjectLiteralExpression(\n                enums\n                  .map(([key, value]) => {\n                    let initializer: ts.Expression = factory.createStringLiteral(`${value?.toString()}`)\n\n                    if (isNumber(value)) {\n                      // Error: Negative numbers should be created in combination with createPrefixUnaryExpression factory.\n                      // The method createNumericLiteral only accepts positive numbers\n                      // or those combined with createPrefixUnaryExpression.\n                      // Therefore, we need to ensure that the number is not negative.\n                      if (value < 0) {\n                        initializer = factory.createPrefixUnaryExpression(ts.SyntaxKind.MinusToken, factory.createNumericLiteral(Math.abs(value)))\n                      } else {\n                        initializer = factory.createNumericLiteral(value)\n                      }\n                    }\n\n                    if (typeof value === 'boolean') {\n                      initializer = value ? factory.createTrue() : factory.createFalse()\n                    }\n\n                    if (key) {\n                      return factory.createPropertyAssignment(factory.createStringLiteral(`${key}`), initializer)\n                    }\n\n                    return undefined\n                  })\n                  .filter(Boolean),\n                true,\n              ),\n              factory.createTypeReferenceNode(factory.createIdentifier('const'), undefined),\n            ),\n          ),\n        ],\n        ts.NodeFlags.Const,\n      ),\n    ),\n    factory.createTypeAliasDeclaration(\n      [factory.createToken(ts.SyntaxKind.ExportKeyword)],\n      factory.createIdentifier(typeName),\n      undefined,\n      factory.createIndexedAccessTypeNode(\n        factory.createParenthesizedType(factory.createTypeQueryNode(factory.createIdentifier(identifierName), undefined)),\n        factory.createTypeOperatorNode(ts.SyntaxKind.KeyOfKeyword, factory.createTypeQueryNode(factory.createIdentifier(identifierName), undefined)),\n      ),\n    ),\n  ]\n}\n\nexport function createOmitDeclaration({\n  keys,\n  type,\n  nonNullable,\n}: {\n  keys: Array<string> | string\n  type: ts.TypeNode\n  nonNullable?: boolean\n}) {\n  const node = nonNullable ? factory.createTypeReferenceNode(factory.createIdentifier('NonNullable'), [type]) : type\n\n  if (Array.isArray(keys)) {\n    return factory.createTypeReferenceNode(factory.createIdentifier('Omit'), [\n      node,\n      factory.createUnionTypeNode(\n        keys.map((key) => {\n          return factory.createLiteralTypeNode(factory.createStringLiteral(key))\n        }),\n      ),\n    ])\n  }\n\n  return factory.createTypeReferenceNode(factory.createIdentifier('Omit'), [node, factory.createLiteralTypeNode(factory.createStringLiteral(keys))])\n}\n\nexport const keywordTypeNodes = {\n  any: factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),\n  unknown: factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),\n  number: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),\n  integer: factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),\n  object: factory.createKeywordTypeNode(ts.SyntaxKind.ObjectKeyword),\n  string: factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n  boolean: factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword),\n  undefined: factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword),\n  null: factory.createLiteralTypeNode(factory.createToken(ts.SyntaxKind.NullKeyword)),\n} as const\n\nexport const createTypeLiteralNode = factory.createTypeLiteralNode\n\nexport const createTypeReferenceNode = factory.createTypeReferenceNode\nexport const createNumericLiteral = factory.createNumericLiteral\nexport const createStringLiteral = factory.createStringLiteral\n\nexport const createArrayTypeNode = factory.createArrayTypeNode\n\nexport const createLiteralTypeNode = factory.createLiteralTypeNode\nexport const createNull = factory.createNull\nexport const createIdentifier = factory.createIdentifier\n\nexport const createTupleTypeNode = factory.createTupleTypeNode\n\nexport const createTrue = factory.createTrue\nexport const createFalse = factory.createFalse\n"]}