{"version":3,"sources":["../src/FileManager.ts","../src/BarrelManager.ts","../src/utils/TreeNode.ts"],"sourcesContent":["import crypto from 'node:crypto'\nimport { extname, resolve } from 'node:path'\n\nimport { orderBy } from 'natural-orderby'\nimport PQueue from 'p-queue'\nimport { isDeepEqual } from 'remeda'\n\nimport { getRelativePath, read, write } from '@kubb/fs'\nimport { BarrelManager } from './BarrelManager.ts'\nimport { searchAndReplace } from './transformers/searchAndReplace.ts'\nimport { trimExtName } from './transformers/trim.ts'\n\nimport type * as KubbFile from '@kubb/fs/types'\n\nimport type { BaseName, File, UUID } from '@kubb/fs/src/types.ts'\nimport type { GreaterThan } from '@kubb/types'\nimport type { BarrelManagerOptions } from './BarrelManager.ts'\nimport type { Logger } from './logger.ts'\nimport transformers from './transformers/index.ts'\nimport type { Plugin } from './types.ts'\nimport { getParser } from './utils'\n\nexport type ResolvedFile<TMeta extends FileMetaBase = FileMetaBase, TBaseName extends BaseName = BaseName> = File<TMeta, TBaseName> & {\n  /**\n   * @default crypto.randomUUID()\n   */\n  id: UUID\n  /**\n   * Contains the first part of the baseName, generated based on baseName\n   * @link  https://nodejs.org/api/path.html#pathformatpathobject\n   */\n\n  name: string\n}\n\nexport type FileMetaBase = {\n  pluginKey?: Plugin['key']\n}\n\ntype FileWithMeta<TMeta extends FileMetaBase = FileMetaBase> = KubbFile.File<TMeta>\n\ntype CacheItem = ResolvedFile & {\n  cancel?: () => void\n}\n\ntype AddResult<T extends Array<FileWithMeta>> = Promise<Awaited<GreaterThan<T['length'], 1> extends true ? Promise<ResolvedFile[]> : Promise<ResolvedFile>>>\n\ntype AddIndexesProps = {\n  /**\n   * Root based on root and output.path specified in the config\n   */\n  root: string\n  /**\n   * Output for plugin\n   */\n  output: {\n    path: string\n    exportAs?: string\n    extName?: KubbFile.Extname\n    exportType?: 'barrel' | 'barrelNamed' | false\n  }\n  logger: Logger\n  options?: BarrelManagerOptions\n  meta?: FileWithMeta['meta']\n}\n\ntype Options = {\n  queue?: PQueue\n  task?: (file: ResolvedFile) => Promise<ResolvedFile>\n}\n\nexport class FileManager {\n  #cache: Map<KubbFile.Path, CacheItem[]> = new Map()\n\n  #task: Options['task']\n  #queue: PQueue\n\n  constructor({ task = async (file) => file, queue = new PQueue() }: Options = {}) {\n    this.#task = task\n    this.#queue = queue\n\n    return this\n  }\n\n  get files(): Array<FileWithMeta> {\n    const files: Array<FileWithMeta> = []\n    this.#cache.forEach((item) => {\n      files.push(...item.flat(1))\n    })\n\n    return files\n  }\n  get isExecuting(): boolean {\n    return this.#queue.size !== 0 && this.#queue.pending !== 0\n  }\n\n  async add<T extends Array<FileWithMeta> = Array<FileWithMeta>>(...files: T): AddResult<T> {\n    const promises = combineFiles(files).map((file) => {\n      if (file.override) {\n        return this.#add(file)\n      }\n\n      return this.#addOrAppend(file)\n    })\n\n    const resolvedFiles = await Promise.all(promises)\n\n    if (files.length > 1) {\n      return resolvedFiles as unknown as AddResult<T>\n    }\n\n    return resolvedFiles[0] as unknown as AddResult<T>\n  }\n\n  async #add(file: FileWithMeta): Promise<ResolvedFile> {\n    const controller = new AbortController()\n    const resolvedFile: ResolvedFile = {\n      id: crypto.randomUUID(),\n      name: trimExtName(file.baseName),\n      ...file,\n    }\n\n    if (resolvedFile.exports?.length) {\n      const folder = resolvedFile.path.replace(resolvedFile.baseName, '')\n\n      resolvedFile.exports = resolvedFile.exports.filter((exportItem) => {\n        const exportedFile = this.files.find((file) => file.path.includes(resolve(folder, exportItem.path)))\n\n        if (exportedFile) {\n          return exportedFile.exportable\n        }\n\n        return true\n      })\n    }\n\n    this.#cache.set(resolvedFile.path, [{ cancel: () => controller.abort(), ...resolvedFile }])\n\n    return this.#queue.add(\n      async () => {\n        return this.#task?.(resolvedFile)\n      },\n      { signal: controller.signal },\n    ) as Promise<ResolvedFile>\n  }\n\n  async #addOrAppend(file: FileWithMeta): Promise<ResolvedFile> {\n    const previousCaches = this.#cache.get(file.path)\n    const previousCache = previousCaches ? previousCaches.at(previousCaches.length - 1) : undefined\n\n    if (previousCache) {\n      this.#cache.delete(previousCache.path)\n\n      return this.#add({\n        ...file,\n        source: previousCache.source && file.source ? `${previousCache.source}\\n${file.source}` : '',\n        imports: [...(previousCache.imports || []), ...(file.imports || [])],\n        exports: [...(previousCache.exports || []), ...(file.exports || [])],\n        env: { ...(previousCache.env || {}), ...(file.env || {}) },\n      })\n    }\n    return this.#add(file)\n  }\n\n  async addIndexes({ root, output, meta, logger, options = {} }: AddIndexesProps): Promise<void> {\n    const { exportType = 'barrel' } = output\n    //        ^?\n    if (exportType === false) {\n      return undefined\n    }\n\n    const pathToBuildFrom = resolve(root, output.path)\n\n    if (transformers.trimExtName(pathToBuildFrom).endsWith('index')) {\n      logger.emit('warning', 'Output has the same fileName as the barrelFiles, please disable barrel generation')\n      return\n    }\n\n    const exportPath = output.path.startsWith('./') ? trimExtName(output.path) : `./${trimExtName(output.path)}`\n    const mode = FileManager.getMode(output.path)\n    const barrelManager = new BarrelManager({\n      extName: output.extName,\n      ...options,\n    })\n    let files = barrelManager.getIndexes(pathToBuildFrom)\n\n    if (!files) {\n      return undefined\n    }\n\n    if (exportType === 'barrelNamed') {\n      files = files.map((file) => {\n        if (file.exports) {\n          return {\n            ...file,\n            exports: barrelManager.getNamedExports(pathToBuildFrom, file.exports),\n          }\n        }\n        return file\n      })\n    }\n\n    await Promise.all(\n      files.map((file) => {\n        return this.#addOrAppend({\n          ...file,\n          meta: meta ? meta : file.meta,\n        })\n      }),\n    )\n\n    const rootPath = mode === 'split' ? `${exportPath}/index${output.extName || ''}` : `${exportPath}${output.extName || ''}`\n    const rootFile: FileWithMeta = {\n      path: resolve(root, 'index.ts'),\n      baseName: 'index.ts',\n      source: '',\n      exports: [\n        output.exportAs\n          ? {\n              name: output.exportAs,\n              asAlias: true,\n              path: rootPath,\n              isTypeOnly: options.isTypeOnly,\n            }\n          : {\n              path: rootPath,\n              isTypeOnly: options.isTypeOnly,\n            },\n      ],\n      exportable: true,\n    }\n\n    if (exportType === 'barrelNamed' && !output.exportAs && rootFile.exports?.[0]) {\n      rootFile.exports = barrelManager.getNamedExport(root, rootFile.exports[0])\n    }\n\n    await this.#addOrAppend({\n      ...rootFile,\n      meta: meta ? meta : rootFile.meta,\n    })\n  }\n\n  getCacheByUUID(UUID: KubbFile.UUID): FileWithMeta | undefined {\n    let cache: FileWithMeta | undefined\n\n    this.#cache.forEach((files) => {\n      cache = files.find((item) => item.id === UUID)\n    })\n    return cache\n  }\n\n  get(path: KubbFile.Path): Array<FileWithMeta> | undefined {\n    return this.#cache.get(path)\n  }\n\n  remove(path: KubbFile.Path): void {\n    const cacheItem = this.get(path)\n    if (!cacheItem) {\n      return\n    }\n\n    this.#cache.delete(path)\n  }\n\n  async write(...params: Parameters<typeof write>): Promise<string | undefined> {\n    return write(...params)\n  }\n\n  async read(...params: Parameters<typeof read>): Promise<string> {\n    return read(...params)\n  }\n\n  // statics\n\n  static async getSource<TMeta extends FileMetaBase = FileMetaBase>(file: FileWithMeta<TMeta>): Promise<string> {\n    return getSource<TMeta>(file)\n  }\n\n  static combineFiles<TMeta extends FileMetaBase = FileMetaBase>(files: Array<FileWithMeta<TMeta> | null>): Array<FileWithMeta<TMeta>> {\n    return combineFiles<TMeta>(files)\n  }\n  static getMode(path: string | undefined | null): KubbFile.Mode {\n    if (!path) {\n      return 'split'\n    }\n    return extname(path) ? 'single' : 'split'\n  }\n\n  static get extensions(): Array<KubbFile.Extname> {\n    return ['.js', '.ts', '.tsx']\n  }\n\n  static isJavascript(baseName: string): boolean {\n    return FileManager.extensions.some((extension) => baseName.endsWith(extension))\n  }\n}\n\nfunction combineFiles<TMeta extends FileMetaBase = FileMetaBase>(files: Array<FileWithMeta<TMeta> | null>): Array<FileWithMeta<TMeta>> {\n  return files.filter(Boolean).reduce(\n    (acc, file: FileWithMeta<TMeta>) => {\n      const prevIndex = acc.findIndex((item) => item.path === file.path)\n\n      if (prevIndex === -1) {\n        return [...acc, file]\n      }\n\n      const prev = acc[prevIndex]\n\n      if (prev && file.override) {\n        acc[prevIndex] = {\n          imports: [],\n          exports: [],\n          ...file,\n        }\n        return acc\n      }\n\n      if (prev) {\n        acc[prevIndex] = {\n          ...file,\n          source: prev.source && file.source ? `${prev.source}\\n${file.source}` : '',\n          imports: [...(prev.imports || []), ...(file.imports || [])],\n          exports: [...(prev.exports || []), ...(file.exports || [])],\n          env: { ...(prev.env || {}), ...(file.env || {}) },\n        }\n      }\n\n      return acc\n    },\n    [] as Array<FileWithMeta<TMeta>>,\n  )\n}\n\nexport async function getSource<TMeta extends FileMetaBase = FileMetaBase>(file: FileWithMeta<TMeta>): Promise<string> {\n  // only use .js, .ts or .tsx files for ESM imports\n\n  if (file.language ? !['typescript', 'javascript'].includes(file.language) : !FileManager.isJavascript(file.baseName)) {\n    return file.source\n  }\n\n  const parser = await getParser(file.language)\n\n  const exports = file.exports ? combineExports(file.exports) : []\n  // imports should be defined and source should contain code or we have imports without them being used\n  const imports = file.imports && file.source ? combineImports(file.imports, exports, file.source) : []\n\n  const importNodes = imports\n    .filter((item) => {\n      const path = item.root ? getRelativePath(item.root, item.path) : item.path\n      // trim extName\n      return path !== trimExtName(file.path)\n    })\n    .map((item) => {\n      const path = item.root ? getRelativePath(item.root, item.path) : item.path\n\n      return parser.factory.createImportDeclaration({\n        name: item.name,\n        path: item.extName ? `${path}${item.extName}` : path,\n        isTypeOnly: item.isTypeOnly,\n      })\n    })\n  const exportNodes = exports.map((item) =>\n    parser.factory.createExportDeclaration({\n      name: item.name,\n      path: item.extName ? `${item.path}${item.extName}` : item.path,\n      isTypeOnly: item.isTypeOnly,\n      asAlias: item.asAlias,\n    }),\n  )\n\n  const source = [parser.print([...importNodes, ...exportNodes]), getEnvSource(file.source, file.env)].join('\\n')\n\n  // do some basic linting with the ts compiler\n  return parser.print([], { source, noEmitHelpers: false })\n}\n\nexport function combineExports(exports: Array<KubbFile.Export>): Array<KubbFile.Export> {\n  const combinedExports = orderBy(exports, [(v) => !v.isTypeOnly], ['asc']).reduce(\n    (prev, curr) => {\n      const name = curr.name\n      const prevByPath = prev.findLast((imp) => imp.path === curr.path)\n      const prevByPathAndIsTypeOnly = prev.findLast((imp) => imp.path === curr.path && isDeepEqual(imp.name, name) && imp.isTypeOnly)\n\n      if (prevByPathAndIsTypeOnly) {\n        // we already have an export that has the same path but uses `isTypeOnly` (export type ...)\n        return prev\n      }\n\n      const uniquePrev = prev.findLast(\n        (imp) => imp.path === curr.path && isDeepEqual(imp.name, name) && imp.isTypeOnly === curr.isTypeOnly && imp.asAlias === curr.asAlias,\n      )\n\n      if (uniquePrev || (Array.isArray(name) && !name.length) || (prevByPath?.asAlias && !curr.asAlias)) {\n        return prev\n      }\n\n      if (!prevByPath) {\n        return [\n          ...prev,\n          {\n            ...curr,\n            name: Array.isArray(name) ? [...new Set(name)] : name,\n          },\n        ]\n      }\n\n      if (prevByPath && Array.isArray(prevByPath.name) && Array.isArray(curr.name) && prevByPath.isTypeOnly === curr.isTypeOnly) {\n        prevByPath.name = [...new Set([...prevByPath.name, ...curr.name])]\n\n        return prev\n      }\n\n      return [...prev, curr]\n    },\n    [] as Array<KubbFile.Export>,\n  )\n\n  return orderBy(combinedExports, [(v) => !v.isTypeOnly, (v) => v.asAlias], ['desc', 'desc'])\n}\n\nexport function combineImports(imports: Array<KubbFile.Import>, exports: Array<KubbFile.Export>, source?: string): Array<KubbFile.Import> {\n  const combinedImports = orderBy(imports, [(v) => !v.isTypeOnly], ['asc']).reduce(\n    (prev, curr) => {\n      let name = Array.isArray(curr.name) ? [...new Set(curr.name)] : curr.name\n\n      const hasImportInSource = (importName: string) => {\n        if (!source) {\n          return true\n        }\n\n        const checker = (name?: string) => name && !!source.includes(name)\n\n        return checker(importName) || exports.some(({ name }) => (Array.isArray(name) ? name.some(checker) : checker(name)))\n      }\n\n      if (curr.path === curr.root) {\n        // root and path are the same file, remove the \"./\" import\n        return prev\n      }\n\n      if (Array.isArray(name)) {\n        name = name.filter((item) => (typeof item === 'string' ? hasImportInSource(item) : hasImportInSource(item.propertyName)))\n      }\n\n      const prevByPath = prev.findLast((imp) => imp.path === curr.path && imp.isTypeOnly === curr.isTypeOnly)\n      const uniquePrev = prev.findLast((imp) => imp.path === curr.path && isDeepEqual(imp.name, name) && imp.isTypeOnly === curr.isTypeOnly)\n      const prevByPathNameAndIsTypeOnly = prev.findLast((imp) => imp.path === curr.path && isDeepEqual(imp.name, name) && imp.isTypeOnly)\n\n      if (prevByPathNameAndIsTypeOnly) {\n        // we already have an export that has the same path but uses `isTypeOnly` (import type ...)\n        return prev\n      }\n\n      if (uniquePrev || (Array.isArray(name) && !name.length)) {\n        return prev\n      }\n\n      if (!prevByPath) {\n        return [\n          ...prev,\n          {\n            ...curr,\n            name,\n          },\n        ]\n      }\n\n      if (prevByPath && Array.isArray(prevByPath.name) && Array.isArray(name) && prevByPath.isTypeOnly === curr.isTypeOnly) {\n        prevByPath.name = [...new Set([...prevByPath.name, ...name])]\n\n        return prev\n      }\n\n      if (!Array.isArray(name) && name && !hasImportInSource(name)) {\n        return prev\n      }\n\n      return [...prev, curr]\n    },\n    [] as Array<KubbFile.Import>,\n  )\n\n  return orderBy(combinedImports, [(v) => !v.isTypeOnly], ['desc'])\n}\n\nfunction getEnvSource(source: string, env: NodeJS.ProcessEnv | undefined): string {\n  if (!env) {\n    return source\n  }\n\n  const keys = Object.keys(env)\n\n  if (!keys.length) {\n    return source\n  }\n\n  return keys.reduce((prev, key: string) => {\n    const environmentValue = env[key]\n    const replaceBy = environmentValue ? `'${environmentValue.replaceAll('\"', '')?.replaceAll(\"'\", '')}'` : 'undefined'\n\n    if (key.toUpperCase() !== key) {\n      throw new TypeError(`Environment should be in upperCase for ${key}`)\n    }\n\n    if (typeof replaceBy === 'string') {\n      prev = searchAndReplace({\n        text: prev.replaceAll(`process.env.${key}`, replaceBy),\n        replaceBy,\n        prefix: 'process.env',\n        key,\n      })\n      // removes `declare const ...`\n      prev = searchAndReplace({\n        text: prev.replaceAll(/(declare const).*\\n/gi, ''),\n        replaceBy,\n        key,\n      })\n    }\n\n    return prev\n  }, source)\n}\n","import { getExports } from '@kubb/parser-ts'\n\nimport path from 'node:path'\n\nimport { trimExtName } from './transformers/trim.ts'\nimport { TreeNode } from './utils/TreeNode.ts'\n\nimport type * as KubbFile from '@kubb/fs/types'\nimport type { DirectoryTreeOptions } from 'directory-tree'\n\nexport type BarrelManagerOptions = {\n  treeNode?: DirectoryTreeOptions\n  isTypeOnly?: boolean\n  /**\n   * Add .ts or .js\n   */\n  extName?: KubbFile.Extname\n}\n\nexport class BarrelManager {\n  #options: BarrelManagerOptions\n\n  constructor(options: BarrelManagerOptions = {}) {\n    this.#options = options\n\n    return this\n  }\n\n  getNamedExport(root: string, item: KubbFile.Export): KubbFile.Export[] {\n    const exportedNames = getExports(path.resolve(root, item.path))\n\n    if (!exportedNames) {\n      return [item]\n    }\n\n    return exportedNames.reduce(\n      (prev, curr) => {\n        if (!prev[0]?.name || !prev[1]?.name) {\n          return prev\n        }\n\n        if (curr.isTypeOnly) {\n          prev[1] = { ...prev[1], name: [...prev[1].name, curr.name] }\n        } else {\n          prev[0] = { ...prev[0], name: [...prev[0].name, curr.name] }\n        }\n\n        return prev\n      },\n      [\n        {\n          ...item,\n          name: [],\n          isTypeOnly: false,\n        },\n        {\n          ...item,\n          name: [],\n          isTypeOnly: true,\n        },\n      ] as KubbFile.Export[],\n    )\n  }\n\n  getNamedExports(root: string, exports: KubbFile.Export[]): KubbFile.Export[] {\n    return exports?.flatMap((item) => {\n      return this.getNamedExport(root, item)\n    })\n  }\n\n  getIndexes(root: string): Array<KubbFile.File> | null {\n    const { treeNode = {}, isTypeOnly, extName } = this.#options\n    const tree = TreeNode.build(root, treeNode)\n\n    if (!tree) {\n      return null\n    }\n\n    const fileReducer = (files: Array<KubbFile.File>, treeNode: TreeNode) => {\n      if (!treeNode.children) {\n        return []\n      }\n\n      if (treeNode.children.length > 1) {\n        const indexPath: KubbFile.Path = path.resolve(treeNode.data.path, 'index.ts')\n\n        const exports: Array<KubbFile.Export> = treeNode.children\n          .filter(Boolean)\n          .map((file) => {\n            const importPath: string = file.data.type === 'split' ? `./${file.data.name}/index` : `./${trimExtName(file.data.name)}`\n\n            if (importPath.endsWith('index') && file.data.type === 'single') {\n              return undefined\n            }\n\n            return {\n              path: extName ? `${importPath}${extName}` : importPath,\n              isTypeOnly,\n            } as KubbFile.Export\n          })\n          .filter(Boolean)\n\n        files.push({\n          path: indexPath,\n          baseName: 'index.ts',\n          source: '',\n          exports,\n          exportable: true,\n        })\n      } else if (treeNode.children.length === 1) {\n        const [treeNodeChild] = treeNode.children as [TreeNode]\n\n        const indexPath = path.resolve(treeNode.data.path, 'index.ts')\n        const importPath = treeNodeChild.data.type === 'split' ? `./${treeNodeChild.data.name}/index` : `./${trimExtName(treeNodeChild.data.name)}`\n\n        const exports = [\n          {\n            path: extName ? `${importPath}${extName}` : importPath,\n            isTypeOnly,\n          },\n        ]\n\n        files.push({\n          path: indexPath,\n          baseName: 'index.ts',\n          source: '',\n          exports,\n          exportable: true,\n        })\n      }\n\n      treeNode.children.forEach((childItem) => {\n        fileReducer(files, childItem)\n      })\n\n      return files\n    }\n\n    return fileReducer([], tree).reverse()\n  }\n}\n","import dirTree from 'directory-tree'\n\nimport { FileManager } from '../FileManager.ts'\n\nimport type * as KubbFile from '@kubb/fs/types'\nimport type { DirectoryTree, DirectoryTreeOptions } from 'directory-tree'\n\nexport type TreeNodeOptions = DirectoryTreeOptions\n\ntype BarrelData = { type: KubbFile.Mode; path: KubbFile.Path; name: string }\n\nexport class TreeNode<T = BarrelData> {\n  public data: T\n\n  public parent?: TreeNode<T>\n\n  public children: Array<TreeNode<T>> = []\n\n  constructor(data: T, parent?: TreeNode<T>) {\n    this.data = data\n    this.parent = parent\n    return this\n  }\n\n  addChild(data: T): TreeNode<T> {\n    const child = new TreeNode(data, this)\n    if (!this.children) {\n      this.children = []\n    }\n    this.children.push(child)\n    return child\n  }\n\n  find(data?: T): TreeNode<T> | null {\n    if (!data) {\n      return null\n    }\n\n    if (data === this.data) {\n      return this\n    }\n\n    if (this.children?.length) {\n      for (let i = 0, { length } = this.children, target: TreeNode<T> | null = null; i < length; i++) {\n        target = this.children[i]!.find(data)\n        if (target) {\n          return target\n        }\n      }\n    }\n\n    return null\n  }\n\n  get leaves(): TreeNode<T>[] {\n    if (!this.children || this.children.length === 0) {\n      // this is a leaf\n      return [this]\n    }\n\n    // if not a leaf, return all children's leaves recursively\n    const leaves: TreeNode<T>[] = []\n    if (this.children) {\n      for (let i = 0, { length } = this.children; i < length; i++) {\n        leaves.push.apply(leaves, this.children[i]!.leaves)\n      }\n    }\n    return leaves\n  }\n\n  get root(): TreeNode<T> {\n    if (!this.parent) {\n      return this\n    }\n    return this.parent.root\n  }\n\n  forEach(callback: (treeNode: TreeNode<T>) => void): this {\n    if (typeof callback !== 'function') {\n      throw new TypeError('forEach() callback must be a function')\n    }\n\n    // run this node through function\n    callback(this)\n\n    // do the same for all children\n    if (this.children) {\n      for (let i = 0, { length } = this.children; i < length; i++) {\n        this.children[i]?.forEach(callback)\n      }\n    }\n\n    return this\n  }\n\n  public static build(path: string, options: TreeNodeOptions = {}): TreeNode | null {\n    try {\n      const exclude = Array.isArray(options.exclude) ? options.exclude : [options.exclude].filter(Boolean)\n      const filteredTree = dirTree(path, {\n        extensions: options.extensions,\n        exclude: [/node_modules/, ...exclude],\n      })\n\n      if (!filteredTree) {\n        return null\n      }\n\n      const treeNode = new TreeNode({\n        name: filteredTree.name,\n        path: filteredTree.path,\n        type: FileManager.getMode(filteredTree.path),\n      })\n\n      const recurse = (node: typeof treeNode, item: DirectoryTree) => {\n        const subNode = node.addChild({\n          name: item.name,\n          path: item.path,\n          type: FileManager.getMode(item.path),\n        })\n\n        if (item.children?.length) {\n          item.children?.forEach((child) => {\n            recurse(subNode, child)\n          })\n        }\n      }\n\n      filteredTree.children?.forEach((child) => recurse(treeNode, child))\n\n      return treeNode\n    } catch (e) {\n      throw new Error('Something went wrong with creating index files with the TreehNode class', { cause: e })\n    }\n  }\n}\n"],"mappings":"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","names":["path","treeNode","path","file","name"]}