{"version":3,"sources":["/home/runner/work/kubb/kubb/packages/plugin-oas/dist/index.cjs","../src/index.ts","../src/plugin.ts","../src/OperationGenerator.ts"],"names":["path","method"],"mappings":"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","file":"/home/runner/work/kubb/kubb/packages/plugin-oas/dist/index.cjs","sourcesContent":[null,"import { pluginOas } from './plugin.ts'\n\nexport type {\n  GetOperationGeneratorOptions,\n  OperationMethodResult,\n} from './OperationGenerator.ts'\nexport { OperationGenerator } from './OperationGenerator.ts'\nexport { pluginOas, pluginOasName } from './plugin.ts'\nexport type {\n  GetSchemaGeneratorOptions,\n  SchemaGeneratorBuildOptions,\n  SchemaGeneratorOptions,\n} from './SchemaGenerator.ts'\nexport type { SchemaMethodResult } from './SchemaGenerator.ts'\nexport { SchemaGenerator } from './SchemaGenerator.ts'\nexport type {\n  Schema,\n  SchemaKeyword,\n  SchemaKeywordBase,\n  SchemaKeywordMapper,\n  SchemaMapper,\n} from './SchemaMapper.ts'\nexport { isKeyword, schemaKeywords } from './SchemaMapper.ts'\nexport type * from './types.ts'\n\n/**\n * @deprecated Use `import { pluginOas } from '@kubb/plugin-oas'` instead\n */\nconst definePluginDefault = pluginOas\n\nexport default definePluginDefault\n","import path from 'node:path'\n\nimport { createPlugin } from '@kubb/core'\nimport { camelCase } from '@kubb/core/transformers'\n\nimport { getSchemas } from './utils/getSchemas.ts'\n\nimport type { Config } from '@kubb/core'\nimport type { Logger } from '@kubb/core/logger'\nimport type { Oas, OasTypes } from '@kubb/oas'\nimport type { PluginOas } from './types.ts'\nimport { parseFromConfig } from './utils/parseFromConfig.ts'\n\nexport const pluginOasName = 'plugin-oas' satisfies PluginOas['name']\n\nexport const pluginOas = createPlugin<PluginOas>((options) => {\n  const { output = { path: 'schemas', export: false }, validate = true, serverIndex = 0, contentType, oasClass } = options\n\n  const getOas = async ({ config, logger }: { config: Config; logger: Logger }): Promise<Oas> => {\n    try {\n      // needs to be in a different variable or the catch here will not work(return of a promise instead)\n      const oas = await parseFromConfig(config, oasClass)\n\n      if (validate) {\n        await oas.valdiate()\n      }\n\n      return oas\n    } catch (e) {\n      const error = e as Error\n\n      logger.emit('warning', error?.message)\n      return parseFromConfig(config, oasClass)\n    }\n  }\n\n  return {\n    name: pluginOasName,\n    options,\n\n    api() {\n      const { config, logger } = this\n\n      return {\n        getOas() {\n          return getOas({ config, logger })\n        },\n        async getSchemas({ includes } = {}) {\n          const oas = await this.getOas()\n          return getSchemas({ oas, contentType, includes })\n        },\n        async getBaseURL() {\n          const oasInstance = await this.getOas()\n          const baseURL = oasInstance.api.servers?.at(serverIndex)?.url\n          return baseURL\n        },\n        contentType,\n      }\n    },\n    resolvePath(baseName) {\n      if (output === false) {\n        return undefined\n      }\n\n      const root = path.resolve(this.config.root, this.config.output.path)\n\n      return path.resolve(root, output.path, baseName)\n    },\n    resolveName(name, type) {\n      return camelCase(name, { isFile: type === 'file' })\n    },\n    async writeFile(path, source) {\n      if (!path.endsWith('.json') || !source) {\n        return\n      }\n\n      return this.fileManager.write(path, source, { sanity: false })\n    },\n    async buildStart() {\n      if (!output) {\n        return\n      }\n\n      const oas = await getOas({\n        config: this.config,\n        logger: this.logger,\n      })\n      await oas.dereference()\n      const schemas = getSchemas({ oas, contentType })\n\n      const mapSchema = async ([name, schema]: [string, OasTypes.SchemaObject]) => {\n        const resolvedPath = this.resolvePath({\n          baseName: `${name}.json`,\n          pluginKey: this.plugin.key,\n        })\n\n        const resvoledFileName = this.resolveName({\n          name: `${name}.json`,\n          pluginKey: [pluginOasName],\n          type: 'file',\n        }) as `${string}.json`\n\n        if (!resolvedPath) {\n          return\n        }\n\n        await this.addFile({\n          path: resolvedPath,\n          baseName: resvoledFileName,\n          source: JSON.stringify(schema),\n          meta: {\n            pluginKey: this.plugin.key,\n          },\n        })\n      }\n\n      const promises = Object.entries(schemas).map(mapSchema)\n      await Promise.all(promises)\n    },\n  }\n})\n","import { type FileMetaBase, Generator } from '@kubb/core'\nimport transformers from '@kubb/core/transformers'\n\nimport type { PluginFactoryOptions, PluginManager } from '@kubb/core'\nimport type * as KubbFile from '@kubb/fs/types'\n\nimport type { Plugin } from '@kubb/core'\nimport type { HttpMethod, Oas, OasTypes, Operation, contentType } from '@kubb/oas'\nimport type { Exclude, Include, OperationSchemas, OperationsByMethod, Override } from './types.ts'\n\nexport type GetOperationGeneratorOptions<T extends OperationGenerator<any, any, any>> = T extends OperationGenerator<infer Options, any, any> ? Options : never\n\nexport type OperationMethodResult<TFileMeta extends FileMetaBase> = Promise<KubbFile.File<TFileMeta> | Array<KubbFile.File<TFileMeta>> | null>\n\ntype Context<TOptions, TPluginOptions extends PluginFactoryOptions> = {\n  oas: Oas\n  exclude: Array<Exclude> | undefined\n  include: Array<Include> | undefined\n  override: Array<Override<TOptions>> | undefined\n  contentType: contentType | undefined\n  pluginManager: PluginManager\n  /**\n   * Current plugin\n   */\n  plugin: Plugin<TPluginOptions>\n  mode: KubbFile.Mode\n}\n\nexport abstract class OperationGenerator<\n  TOptions = unknown,\n  TPluginOptions extends PluginFactoryOptions = PluginFactoryOptions,\n  TFileMeta extends FileMetaBase = FileMetaBase,\n> extends Generator<TOptions, Context<TOptions, TPluginOptions>> {\n  #operationsByMethod: OperationsByMethod = {}\n  get operationsByMethod(): OperationsByMethod {\n    return this.#operationsByMethod\n  }\n\n  set operationsByMethod(paths: OperationsByMethod) {\n    this.#operationsByMethod = paths\n  }\n\n  #getOptions(operation: Operation, method: HttpMethod): Partial<TOptions> {\n    const { override = [] } = this.context\n\n    return (\n      override.find(({ pattern, type }) => {\n        if (type === 'tag') {\n          return !!operation.getTags()[0]?.name.match(pattern)\n        }\n\n        if (type === 'operationId') {\n          return !!operation.getOperationId().match(pattern)\n        }\n\n        if (type === 'path') {\n          return !!operation.path.match(pattern)\n        }\n\n        if (type === 'method') {\n          return !!method.match(pattern)\n        }\n\n        return false\n      })?.options || {}\n    )\n  }\n  /**\n   *\n   * @deprecated\n   */\n  #isExcluded(operation: Operation, method: HttpMethod): boolean {\n    const { exclude = [] } = this.context\n    let matched = false\n\n    exclude.forEach(({ pattern, type }) => {\n      if (type === 'tag' && !matched) {\n        matched = !!operation.getTags()[0]?.name.match(pattern)\n      }\n\n      if (type === 'operationId' && !matched) {\n        matched = !!operation.getOperationId().match(pattern)\n      }\n\n      if (type === 'path' && !matched) {\n        matched = !!operation.path.match(pattern)\n      }\n\n      if (type === 'method' && !matched) {\n        matched = !!method.match(pattern)\n      }\n    })\n\n    return matched\n  }\n  /**\n   *\n   * @deprecated\n   */\n  #isIncluded(operation: Operation, method: HttpMethod): boolean {\n    const { include = [] } = this.context\n    let matched = false\n\n    include.forEach(({ pattern, type }) => {\n      if (type === 'tag' && !matched) {\n        matched = !!operation.getTags()[0]?.name.match(pattern)\n      }\n\n      if (type === 'operationId' && !matched) {\n        matched = !!operation.getOperationId().match(pattern)\n      }\n\n      if (type === 'path' && !matched) {\n        matched = !!operation.path.match(pattern)\n      }\n\n      if (type === 'method' && !matched) {\n        matched = !!method.match(pattern)\n      }\n    })\n\n    return matched\n  }\n\n  getSchemas(\n    operation: Operation,\n    { forStatusCode, resolveName = (name) => name }: { forStatusCode?: string | number; resolveName?: (name: string) => string } = {},\n  ): OperationSchemas {\n    const pathParamsSchema = this.context.oas.getParametersSchema(operation, 'path')\n    const queryParamsSchema = this.context.oas.getParametersSchema(operation, 'query')\n    const headerParamsSchema = this.context.oas.getParametersSchema(operation, 'header')\n    const requestSchema = this.context.oas.getRequestSchema(operation)\n    const responseStatusCode =\n      forStatusCode || (operation.schema.responses && Object.keys(operation.schema.responses).find((key) => key.startsWith('2'))) || 200\n    const responseSchema = this.context.oas.getResponseSchema(operation, responseStatusCode)\n    const statusCodes = operation.getResponseStatusCodes().map((statusCode) => {\n      let name = statusCode\n      if (name === 'default') {\n        name = 'error'\n      }\n\n      const schema = this.context.oas.getResponseSchema(operation, statusCode)\n\n      return {\n        name: resolveName(transformers.pascalCase(`${operation.getOperationId()} ${name}`)),\n        description: (operation.getResponseByStatusCode(statusCode) as OasTypes.ResponseObject)?.description,\n        schema,\n        operation,\n        operationName: transformers.pascalCase(`${operation.getOperationId()}`),\n        statusCode: name === 'error' ? undefined : Number(statusCode),\n        keys: schema?.properties ? Object.keys(schema.properties) : undefined,\n      }\n    })\n\n    return {\n      pathParams: pathParamsSchema\n        ? {\n            name: resolveName(transformers.pascalCase(`${operation.getOperationId()} PathParams`)),\n            operation,\n            operationName: transformers.pascalCase(`${operation.getOperationId()}`),\n            schema: pathParamsSchema,\n            keys: pathParamsSchema.properties ? Object.keys(pathParamsSchema.properties) : undefined,\n          }\n        : undefined,\n      queryParams: queryParamsSchema\n        ? {\n            name: resolveName(transformers.pascalCase(`${operation.getOperationId()} QueryParams`)),\n            operation,\n            operationName: transformers.pascalCase(`${operation.getOperationId()}`),\n            schema: queryParamsSchema,\n            keys: queryParamsSchema.properties ? Object.keys(queryParamsSchema.properties) : [],\n          }\n        : undefined,\n      headerParams: headerParamsSchema\n        ? {\n            name: resolveName(transformers.pascalCase(`${operation.getOperationId()} HeaderParams`)),\n            operation,\n            operationName: transformers.pascalCase(`${operation.getOperationId()}`),\n            schema: headerParamsSchema,\n            keys: headerParamsSchema.properties ? Object.keys(headerParamsSchema.properties) : undefined,\n          }\n        : undefined,\n      request: requestSchema\n        ? {\n            name: resolveName(transformers.pascalCase(`${operation.getOperationId()} ${operation.method === 'get' ? 'queryRequest' : 'mutationRequest'}`)),\n            description: (operation.schema.requestBody as OasTypes.RequestBodyObject)?.description,\n            operation,\n            operationName: transformers.pascalCase(`${operation.getOperationId()}`),\n            schema: requestSchema,\n            keys: requestSchema.properties ? Object.keys(requestSchema.properties) : undefined,\n            keysToOmit: requestSchema.properties\n              ? Object.keys(requestSchema.properties).filter((key) => {\n                  const item = requestSchema.properties?.[key] as OasTypes.SchemaObject\n\n                  return item?.readOnly\n                })\n              : undefined,\n          }\n        : undefined,\n      response: {\n        name: resolveName(transformers.pascalCase(`${operation.getOperationId()} ${operation.method === 'get' ? 'queryResponse' : 'mutationResponse'}`)),\n        description: operation.getResponseAsJSONSchema(responseStatusCode)?.at(0)?.description,\n        operation,\n        operationName: transformers.pascalCase(`${operation.getOperationId()}`),\n        schema: responseSchema,\n        statusCode: Number(responseStatusCode),\n        keys: responseSchema?.properties ? Object.keys(responseSchema.properties) : undefined,\n        keysToOmit: responseSchema?.properties\n          ? Object.keys(responseSchema.properties).filter((key) => {\n              const item = responseSchema.properties?.[key] as OasTypes.SchemaObject\n              return item?.writeOnly\n            })\n          : undefined,\n      },\n      errors: statusCodes.filter((item) => item.statusCode?.toString().startsWith('4') || item.statusCode?.toString().startsWith('5')),\n      statusCodes,\n    }\n  }\n\n  get #methods() {\n    return {\n      get: this.get,\n      post: this.post,\n      patch: this.patch,\n      put: this.put,\n      delete: this.delete,\n      head: undefined,\n      options: undefined,\n      trace: undefined,\n    } as const\n  }\n\n  async build(): Promise<Array<KubbFile.File<TFileMeta>>> {\n    const { oas } = this.context\n\n    const paths = oas.getPaths()\n    this.operationsByMethod = Object.entries(paths).reduce((acc, [path, method]) => {\n      const methods = Object.keys(method) as HttpMethod[]\n\n      methods.forEach((method) => {\n        const operation = oas.operation(path, method)\n        if (operation && this.#methods[method]) {\n          const isExcluded = this.#isExcluded(operation, method)\n          const isIncluded = this.context.include ? this.#isIncluded(operation, method) : true\n\n          if (isIncluded && !isExcluded) {\n            if (!acc[path]) {\n              acc[path] = {} as OperationsByMethod['get']\n            }\n            acc[path] = {\n              ...acc[path],\n              [method]: {\n                operation,\n                schemas: this.getSchemas(operation),\n              },\n            } as OperationsByMethod['get']\n          }\n        }\n      })\n\n      return acc\n    }, {} as OperationsByMethod)\n\n    const promises = Object.keys(this.operationsByMethod).reduce((acc, path) => {\n      const methods = this.operationsByMethod[path] ? (Object.keys(this.operationsByMethod[path]!) as HttpMethod[]) : []\n\n      methods.forEach((method) => {\n        const { operation } = this.operationsByMethod[path]?.[method]!\n        const options = this.#getOptions(operation, method)\n        const promiseMethod = this.#methods[method]?.call(this, operation, {\n          ...this.options,\n          ...options,\n        })\n        const promiseOperation = this.operation.call(this, operation, {\n          ...this.options,\n          ...options,\n        })\n\n        if (promiseMethod) {\n          acc.push(promiseMethod)\n        }\n        if (promiseOperation) {\n          acc.push(promiseOperation)\n        }\n      })\n\n      return acc\n    }, [] as OperationMethodResult<TFileMeta>[])\n\n    const operations = Object.values(this.operationsByMethod).map((item) => Object.values(item).map((item) => item.operation))\n\n    promises.push(this.all(operations.flat().filter(Boolean), this.operationsByMethod))\n\n    const files = await Promise.all(promises)\n\n    // using .flat because operationGenerator[method] can return a array of files or just one file\n    return files.flat().filter(Boolean)\n  }\n\n  /**\n   * Operation\n   */\n  async operation(operation: Operation, options: TOptions): OperationMethodResult<TFileMeta> {\n    return null\n  }\n\n  /**\n   * GET\n   */\n  async get(operation: Operation, options: TOptions): OperationMethodResult<TFileMeta> {\n    return null\n  }\n\n  /**\n   * POST\n   */\n  async post(operation: Operation, options: TOptions): OperationMethodResult<TFileMeta> {\n    return null\n  }\n  /**\n   * PATCH\n   */\n  async patch(operation: Operation, options: TOptions): OperationMethodResult<TFileMeta> {\n    return null\n  }\n\n  /**\n   * PUT\n   */\n  async put(operation: Operation, options: TOptions): OperationMethodResult<TFileMeta> {\n    return null\n  }\n\n  /**\n   * DELETE\n   */\n  async delete(operation: Operation, options: TOptions): OperationMethodResult<TFileMeta> {\n    return null\n  }\n\n  /**\n   * Combination of GET, POST, PATCH, PUT, DELETE\n   */\n  async all(operations: Operation[], paths: OperationsByMethod): OperationMethodResult<TFileMeta> {\n    return null\n  }\n}\n"]}