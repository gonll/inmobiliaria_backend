{"version":3,"file":"index.js","names":["useContext","useFile","useContext","createFabric"],"sources":["../src/components/App.tsx","../src/components/Const.tsx","../src/components/File.tsx","../src/components/Function.tsx","../src/components/Type.tsx","../src/composables/useLifecycle.tsx","../src/devtools.ts","../src/createReactFabric.ts","../src/utils/getFunctionParams.ts","../src/index.ts"],"sourcesContent":["import { AppContext, NodeTreeContext, provide, RootContext, useContext, useNodeTree } from '@kubb/fabric-core'\nimport type { KubbElement, KubbNode } from '../types.ts'\n\nexport type AppProps<TMeta extends object = object> = {\n  /**\n   * Metadata associated with the App.\n   */\n  meta?: TMeta\n  /**\n   * Children nodes.\n   */\n  children?: KubbNode\n}\n\n/**\n * App container containing the AppContext carrying `meta` and an `exit` hook.\n */\nexport function App<TMeta extends object = object>({ children, ...props }: AppProps<TMeta>): KubbElement {\n  const { meta = {} } = props\n\n  const { exit } = useContext(RootContext)\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'App', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  provide(AppContext, { exit, meta })\n\n  return <>{children}</>\n}\n\nApp.displayName = 'KubbApp'\n","import { NodeTreeContext, provide, useNodeTree } from '@kubb/fabric-core'\nimport type { JSDoc, Key, KubbElement, KubbNode } from '../types.ts'\nimport { createJSDoc } from '../utils/createJSDoc.ts'\n\nexport type ConstProps = {\n  key?: Key\n  /**\n   * Name of the const\n   */\n  name: string\n  /**\n   * Does this type need to be exported.\n   */\n  export?: boolean\n  /**\n   * Type to make the const being typed\n   */\n  type?: string\n  /**\n   * Options for JSdocs.\n   */\n  JSDoc?: JSDoc\n  /**\n   * Use of `const` assertions\n   */\n  asConst?: boolean\n  /**\n   * Children nodes.\n   */\n  children?: KubbNode\n}\n\n/**\n * Generates a TypeScript constant declaration.\n */\nexport function Const({ children, ...props }: ConstProps): KubbElement {\n  const { name, export: canExport, type, JSDoc, asConst } = props\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'Const', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  return (\n    <>\n      {JSDoc?.comments && (\n        <>\n          {createJSDoc({ comments: JSDoc?.comments })}\n          <br />\n        </>\n      )}\n      {canExport && <>export </>}\n      const {name}{' '}\n      {type && (\n        <>\n          {':'}\n          {type}{' '}\n        </>\n      )}\n      = {children}\n      {asConst && <> as const</>}\n    </>\n  )\n}\n\nConst.displayName = 'KubbConst'\n","import { FileContext, NodeTreeContext, provide, useFile, useFileManager, useNodeTree } from '@kubb/fabric-core'\nimport type { KubbFile } from '@kubb/fabric-core/types'\nimport type { Key, KubbElement, KubbNode } from '../types.ts'\n\ntype BasePropsWithBaseName = {\n  /**\n   * Name to be used to dynamicly create the baseName(based on input.path).\n   * Based on UNIX basename\n   * @link https://nodejs.org/api/path.html#pathbasenamepath-suffix\n   */\n  baseName: KubbFile.BaseName\n  /**\n   * Path will be full qualified path to a specified file.\n   */\n  path: KubbFile.Path\n}\n\ntype BasePropsWithoutBaseName = {\n  baseName?: never\n  /**\n   * Path will be full qualified path to a specified file.\n   */\n  path?: KubbFile.Path\n}\n\ntype BaseProps = BasePropsWithBaseName | BasePropsWithoutBaseName\n\ntype Props<TMeta> = BaseProps & {\n  key?: Key\n  meta?: TMeta\n  banner?: string\n  footer?: string\n  children?: KubbNode\n}\n\n/**\n * Adds files to the FileManager\n */\nexport function File<TMeta extends object = object>({ children, ...props }: Props<TMeta>): KubbElement {\n  const { baseName, path, meta = {}, footer, banner } = props\n\n  const fileManager = useFileManager()\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'File', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  if (!baseName || !path) {\n    return <>{children}</>\n  }\n\n  const file: KubbFile.File = {\n    baseName,\n    path,\n    meta,\n    banner,\n    footer,\n    sources: [],\n    imports: [],\n    exports: [],\n  }\n\n  const [resolvedFile] = fileManager.add(file)\n  provide(FileContext, resolvedFile)\n\n  return <kubb-file {...props}>{children}</kubb-file>\n}\n\nFile.displayName = 'KubbFile'\n\ntype FileSourceProps = Omit<KubbFile.Source, 'value'> & {\n  key?: Key\n  children?: KubbNode\n}\n\n/**\n * File.Source\n *\n * Marks a block of source text to be associated with the current file when\n * rendering with the FileCollector. Children are treated as the source string.\n */\nfunction FileSource({ children, ...props }: FileSourceProps): KubbElement {\n  const { name, isExportable, isIndexable, isTypeOnly } = props\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'FileSource', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  return (\n    <kubb-source name={name} isTypeOnly={isTypeOnly} isExportable={isExportable} isIndexable={isIndexable}>\n      {children}\n    </kubb-source>\n  )\n}\n\nFileSource.displayName = 'KubbFileSource'\n\nexport type FileExportProps = KubbFile.Export & { key?: Key }\n\n/**\n * File.Export\n *\n * Declares an export entry for the current file. This will be collected by\n * the FileCollector for later emission.\n */\nfunction FileExport(props: FileExportProps): KubbElement {\n  const { name, path, isTypeOnly, asAlias } = props\n\n  const nodeTree = useNodeTree()\n  const file = useFile()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'FileExport', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  if (file) {\n    file.exports.push({\n      name,\n      path,\n      asAlias,\n      isTypeOnly,\n    })\n  }\n\n  return <kubb-export name={name} path={path} isTypeOnly={isTypeOnly} asAlias={asAlias} />\n}\n\nFileExport.displayName = 'KubbFileExport'\n\nexport type FileImportProps = KubbFile.Import & { key?: Key }\n\n/**\n * File.Import\n *\n * Declares an import entry for the current file.\n */\nfunction FileImport(props: FileImportProps): KubbElement {\n  const { name, root, path, isTypeOnly, isNameSpace } = props\n\n  const nodeTree = useNodeTree()\n  const file = useFile()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'FileImport', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  if (file) {\n    file.imports.push({\n      name,\n      path,\n      root,\n      isNameSpace,\n      isTypeOnly,\n    })\n  }\n\n  return <kubb-import name={name} root={root} path={path} isNameSpace={isNameSpace} isTypeOnly={isTypeOnly} />\n}\n\nFileImport.displayName = 'KubbFileImport'\n\nFile.Export = FileExport\nFile.Import = FileImport\nFile.Source = FileSource\n","import { NodeTreeContext, provide, useNodeTree } from '@kubb/fabric-core'\nimport type { JSDoc, Key, KubbElement, KubbNode } from '../types.ts'\nimport { createJSDoc } from '../utils/createJSDoc.ts'\n\ntype Props = {\n  key?: Key\n  /**\n   * Name of the function.\n   */\n  name: string\n  /**\n   * Add default when export is being used\n   */\n  default?: boolean\n  /**\n   * Parameters/options/props that need to be used.\n   */\n  params?: string\n  /**\n   * Does this function need to be exported.\n   */\n  export?: boolean\n  /**\n   * Does the function has async/promise behaviour.\n   * This will also add `Promise<returnType>` as the returnType.\n   */\n  async?: boolean\n  /**\n   * Generics that needs to be added for TypeScript.\n   */\n  generics?: string | string[]\n  /**\n   * ReturnType(see async for adding Promise type).\n   */\n  returnType?: string\n  /**\n   * Options for JSdocs.\n   */\n  JSDoc?: JSDoc\n  /**\n   * Children nodes.\n   */\n  children?: KubbNode\n}\n\n/**\n * Generates a TypeScript function declaration.\n */\nexport function Function({ children, ...props }: Props): KubbElement {\n  const { name, default: isDefault, export: canExport, async, generics, params, returnType, JSDoc } = props\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'Function', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  return (\n    <>\n      {JSDoc?.comments && (\n        <>\n          {createJSDoc({ comments: JSDoc?.comments })}\n          <br />\n        </>\n      )}\n      {canExport && <>export </>}\n      {isDefault && <>default </>}\n      {async && <>async </>}\n      function {name}\n      {generics && (\n        <>\n          {'<'}\n          {Array.isArray(generics) ? generics.join(', ').trim() : generics}\n          {'>'}\n        </>\n      )}\n      ({params}){returnType && !async && <>: {returnType}</>}\n      {returnType && async && (\n        <>\n          : Promise{'<'}\n          {returnType}\n          {'>'}\n        </>\n      )}\n      {' {'}\n      <br />\n      <indent />\n      {/* Indent component to handle indentation*/}\n      {children}\n      <br />\n      <dedent />\n      {/* Indent component to handle indentation*/}\n      {'}'}\n    </>\n  )\n}\n\nFunction.displayName = 'KubbFunction'\n\ntype ArrowFunctionProps = Props & {\n  /**\n   * Create Arrow function in one line\n   */\n  singleLine?: boolean\n}\n\n/**\n * ArrowFunction\n *\n * Renders an arrow function definition. Supports the same flags as `Function`.\n * Use `singleLine` to render the body as a single-line expression.\n */\nfunction ArrowFunction({ children, ...props }: ArrowFunctionProps) {\n  const { name, default: isDefault, export: canExport, async, generics, params, returnType, JSDoc, singleLine } = props\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'ArrowFunction', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n  return (\n    <>\n      {JSDoc?.comments && (\n        <>\n          {createJSDoc({ comments: JSDoc?.comments })}\n          <br />\n        </>\n      )}\n      {canExport && <>export </>}\n      {isDefault && <>default </>}\n      const {name} = {async && <>async </>}\n      {generics && (\n        <>\n          {'<'}\n          {Array.isArray(generics) ? generics.join(', ').trim() : generics}\n          {'>'}\n        </>\n      )}\n      ({params}){returnType && !async && <>: {returnType}</>}\n      {returnType && async && (\n        <>\n          : Promise{'<'}\n          {returnType}\n          {'>'}\n        </>\n      )}\n      {singleLine && (\n        <>\n          {' => '}\n          {children}\n          <br />\n        </>\n      )}\n      {!singleLine && (\n        <>\n          {' => {'}\n          <br />\n          <indent />\n          {/* Indent component to handle indentation*/}\n          {children}\n          <br />\n          <dedent />\n          {/* Indent component to handle indentation*/}\n          {'}'}\n          <br />\n        </>\n      )}\n    </>\n  )\n}\n\nArrowFunction.displayName = 'KubbArrowFunction'\nFunction.Arrow = ArrowFunction\n","import { NodeTreeContext, provide, useNodeTree } from '@kubb/fabric-core'\nimport type { JSDoc, Key, KubbElement, KubbNode } from '../types.ts'\nimport { createJSDoc } from '../utils/createJSDoc.ts'\n\nexport type TypeProps = {\n  key?: Key\n  /**\n   * Name of the type, this needs to start with a capital letter.\n   */\n  name: string\n  /**\n   * Does this type need to be exported.\n   */\n  export?: boolean\n  /**\n   * Options for JSdocs.\n   */\n  JSDoc?: JSDoc\n  /**\n   * Children nodes.\n   */\n  children?: KubbNode\n}\n\n/**\n * Generates a TypeScript type declaration.\n */\nexport function Type({ children, ...props }: TypeProps): KubbElement {\n  const { name, export: canExport, JSDoc } = props\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'Type', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  if (name.charAt(0).toUpperCase() !== name.charAt(0)) {\n    throw new Error('Name should start with a capital letter(see TypeScript types)')\n  }\n\n  return (\n    <>\n      {JSDoc?.comments && (\n        <>\n          {createJSDoc({ comments: JSDoc?.comments })}\n          <br />\n        </>\n      )}\n      {canExport && <>export </>}\n      type {name} = {children}\n    </>\n  )\n}\n\nType.displayName = 'KubbType'\n","import { RootContext, useContext } from '@kubb/fabric-core'\n\n/**\n * Provides lifecycle helpers that integrate with the Fabric runtime. The\n * `exit` helper schedules a call to the RootContext exit function on the\n * next tick to allow React to complete its render cycle first.\n */\nexport function useLifecycle() {\n  const { exit } = useContext(RootContext)\n\n  return {\n    exit: () => {\n      // need this to let React finish its current render cycle\n      setTimeout(() => {\n        exit()\n      }, 0)\n    },\n  }\n}\n","import { execa } from 'execa'\nimport { onExit } from 'signal-exit'\nimport ws from 'ws'\n\nimport { Renderer } from './Renderer.ts'\n\ndeclare global {\n  var WebSocket: typeof WebSocket\n  var self: any\n  var window: any\n  var isDevtoolsEnabled: any\n}\n\nlet isOpen = false\n\nexport function openDevtools() {\n  if (isOpen) {\n    return undefined\n  }\n  // Set up global polyfills BEFORE importing react-devtools-core\n  // This is required because react-devtools-core expects these to be available\n  const customGlobal = global as any\n  customGlobal.WebSocket ||= ws\n  customGlobal.window ||= global\n  customGlobal.self ||= global\n  customGlobal.isDevtoolsEnabled = true\n\n  // Filter out Kubbs's internal components from devtools for a cleaner view.\n  // See https://github.com/facebook/react/blob/edf6eac8a181860fd8a2d076a43806f1237495a1/packages/react-devtools-shared/src/types.js#L24\n  customGlobal.window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ = [\n    {\n      // ComponentFilterDisplayName\n      type: 2,\n      value: 'Context.Provider',\n      isEnabled: true,\n      isValid: true,\n    },\n    {\n      // ComponentFilterDisplayName\n      type: 2,\n      value: 'KubbRoot',\n      isEnabled: true,\n      isValid: true,\n    },\n    {\n      // ComponentFilterDisplayName\n      type: 2,\n      value: 'KubbErrorBoundary',\n      isEnabled: true,\n      isValid: true,\n    },\n    {\n      // ComponentFilterDisplayName\n      type: 2,\n      value: 'kubb-file',\n      isEnabled: true,\n      isValid: true,\n    },\n    {\n      // ComponentFilterDisplayName\n      type: 2,\n      value: 'kubb-text',\n      isEnabled: true,\n      isValid: true,\n    },\n    {\n      // ComponentFilterDisplayName\n      type: 2,\n      value: 'kubb-import',\n      isEnabled: true,\n      isValid: true,\n    },\n    {\n      // ComponentFilterDisplayName\n      type: 2,\n      value: 'kubb-export',\n      isEnabled: true,\n      isValid: true,\n    },\n    {\n      // ComponentFilterDisplayName\n      type: 2,\n      value: 'kubb-source',\n      isEnabled: true,\n      isValid: true,\n    },\n  ]\n\n  // biome-ignore lint/suspicious/noTsIgnore: cannot find types\n  // @ts-ignore\n  import('react-devtools-core').then(async (devtools) => {\n    console.info('Opening devtools')\n    const controller = new AbortController()\n    if (!isOpen) {\n      execa({\n        stdio: 'pipe',\n        preferLocal: true,\n        cancelSignal: controller.signal,\n        gracefulCancel: true,\n      })`npx react-devtools@6.1.5`\n    }\n\n    isOpen = true\n\n    // Destructure the functions from the module\n    const { initialize, connectToDevTools } = devtools?.default || devtools\n\n    // Initialize DevTools BEFORE importing Renderer (which imports React)\n    initialize()\n    console.info('Initializing devtools')\n\n    // Inject the renderer BEFORE connecting to DevTools\n    // This ensures DevTools can properly discover the custom renderer\n    Renderer.injectIntoDevTools({\n      bundleType: 1,\n      version: '19.1.0',\n      rendererPackageName: 'kubb',\n      // findFiberByHostInstance is required for DevTools to map elements to fibers\n      findFiberByHostInstance: () => null,\n    })\n\n    console.info('Connecting devtools')\n\n    try {\n      connectToDevTools({\n        host: 'localhost',\n        port: 8097,\n        useHttps: false,\n        isAppActive: () => true,\n      })\n    } catch (e) {\n      console.error(e)\n      console.info('Error when connecting the devtools')\n    }\n\n    onExit(\n      () => {\n        console.info('Disconnecting devtools')\n        controller.abort()\n      },\n      { alwaysLast: false },\n    )\n  })\n}\n","import { createFabric } from '@kubb/fabric-core'\nimport type { Fabric, FabricConfig, FabricMode } from '@kubb/fabric-core/types'\nimport { openDevtools } from './devtools.ts'\nimport type { Options } from './plugins/reactPlugin.ts'\nimport { reactPlugin } from './plugins/reactPlugin.ts'\n\nexport function createReactFabric(\n  config: FabricConfig<Options & { mode?: FabricMode; devtools?: boolean }> = {},\n): Fabric<Options & { mode?: FabricMode; devtools?: boolean }> {\n  if (config.devtools) {\n    openDevtools()\n  }\n\n  const fabric = createFabric({ mode: config.mode })\n\n  fabric.use(reactPlugin, {\n    stdout: config.stdout,\n    stderr: config.stderr,\n    debug: config.debug,\n    stdin: config.stdin,\n  })\n\n  return fabric\n}\n","import { orderBy } from 'natural-orderby'\n\nexport type Param = {\n  /**\n   * `object` will return the pathParams as an object.\n   *\n   * `inline` will return the pathParams as comma separated params.\n   * @default `'inline'`\n   * @private\n   */\n  mode?: 'object' | 'inline' | 'inlineSpread'\n  type?: 'string' | 'number' | (string & {})\n  optional?: boolean\n  /**\n   * @example test = \"default\"\n   */\n  default?: string\n  /**\n   * Used for no TypeScript(with mode object)\n   * @example test: \"default\"\n   */\n  value?: string\n  children?: Params\n}\n\ntype ParamItem =\n  | (Pick<Param, 'mode' | 'type' | 'value'> & {\n      optional?: true\n      default?: never\n      children?: Params\n    })\n  | (Pick<Param, 'mode' | 'type' | 'value'> & {\n      optional?: false\n      default?: string\n      children?: Params\n    })\n\nexport type Params = Record<string, Param | undefined>\n\ntype Options = {\n  type: 'constructor' | 'call' | 'object' | 'objectValue'\n  transformName?: (name: string) => string\n  transformType?: (type: string) => string\n}\n\nfunction order(items: Array<[key: string, item?: ParamItem]>) {\n  return orderBy(\n    items.filter(Boolean),\n    [\n      ([_key, item]) => {\n        if (item?.children) {\n          return 0 // Treat items with children as required (they'll get = {} if all children are optional)\n        }\n        // Priority order: required (0) → optional (1) → default-only (2)\n        if (item?.optional) {\n          return 1 // Optional parameters (with or without default)\n        }\n        if (item?.default) {\n          // Parameters with default only (not marked as optional)\n          // Note: While the ParamItem type suggests optional and default are mutually exclusive,\n          // this handles the case where a parameter has a default value but isn't explicitly marked as optional\n          return 2\n        }\n        return 0 // Required parameters\n      },\n    ],\n    ['asc'],\n  )\n}\n\nfunction parseChild(key: string, item: ParamItem, options: Options): string | null {\n  // @ts-expect-error\n  const entries = order(Object.entries(item.children))\n\n  const types: string[] = []\n  const names: string[] = []\n\n  const optional = entries.every(([_key, item]) => item?.optional || !!item?.default)\n\n  entries.forEach(([key, entryItem]) => {\n    if (entryItem) {\n      const name = parseItem(key, { ...entryItem, type: undefined }, options)\n      if (entryItem.children) {\n        const subTypes = Object.entries(entryItem.children)\n          .map(([key]) => {\n            return key\n          })\n          .join(', ')\n\n        if (subTypes) {\n          names.push(`${name}: { ${subTypes} }`)\n        } else {\n          names.push(name)\n        }\n      } else {\n        if (options.type === 'call' && options.transformName) {\n          names.push(`${key}: ${name}`)\n        } else {\n          names.push(name)\n        }\n      }\n\n      if (entries.some(([_key, item]) => item?.type)) {\n        types.push(parseItem(key, { ...entryItem, default: undefined }, options))\n      }\n    }\n  })\n\n  const name = item.mode === 'inline' ? key : names.length ? `{ ${names.join(', ')} }` : undefined\n  const type = item.type ? item.type : types.length ? `{ ${types.join('; ')} }` : undefined\n\n  if (!name) {\n    return null\n  }\n\n  return parseItem(\n    name,\n    {\n      type,\n      default: item.default,\n      optional: !item.default ? optional : undefined,\n    } as ParamItem,\n    options,\n  )\n}\n\nfunction parseItem(name: string, item: ParamItem, options: Options): string {\n  const acc: string[] = []\n  const transformedName = options.transformName ? options.transformName(name) : name\n  const transformedType = options.transformType && item.type ? options.transformType(item.type) : item.type\n\n  if (options.type === 'object') {\n    return transformedName\n  }\n\n  if (options.type === 'objectValue') {\n    return item.value ? `${transformedName}: ${item.value}` : transformedName\n  }\n\n  //LEGACY\n  if (item.type && options.type === 'constructor') {\n    if (item.optional) {\n      // Check if this is a destructured parameter (object mode)\n      const isDestructured = transformedName.startsWith('{')\n      if (isDestructured) {\n        // For destructured parameters, use \": type = {}\" syntax to make it optional\n        acc.push(`${transformedName}: ${transformedType} = {}`)\n      } else {\n        // For inline parameters, use \"?: type\" syntax\n        acc.push(`${transformedName}?: ${transformedType}`)\n      }\n    } else {\n      acc.push(`${transformedName}: ${transformedType}${item.default ? ` = ${item.default}` : ''}`)\n    }\n  } else if (item.default && options.type === 'constructor') {\n    acc.push(`${transformedName} = ${item.default}`)\n  } else if (item.value) {\n    acc.push(`${transformedName} : ${item.value}`)\n  } else if (item.mode === 'inlineSpread') {\n    acc.push(`... ${transformedName}`)\n  } else {\n    acc.push(transformedName)\n  }\n\n  return acc[0] as string\n}\n\nexport function getFunctionParams(params: Params, options: Options): string {\n  const entries = order(Object.entries(params as Record<string, ParamItem | undefined>))\n\n  return entries\n    .reduce((acc, [key, item]) => {\n      if (!item) {\n        return acc\n      }\n\n      if (item.children) {\n        if (Object.keys(item.children).length === 0) {\n          return acc\n        }\n\n        if (item.mode === 'inlineSpread') {\n          return [...acc, getFunctionParams(item.children, options)]\n        }\n\n        const parsedItem = parseChild(key, item, options)\n        if (!parsedItem) {\n          return acc\n        }\n\n        return [...acc, parsedItem]\n      }\n\n      const parsedItem = parseItem(key, item, options)\n\n      return [...acc, parsedItem]\n    }, [] as string[])\n    .join(', ')\n}\n\nexport function createFunctionParams(params: Params): Params {\n  return params\n}\n// TODO  use of zod\n//TODO use of string as `$name: $type` to create templates for functions instead of call/constructor\nexport class FunctionParams {\n  #params: Params\n\n  static factory(params: Params) {\n    return new FunctionParams(params)\n  }\n  constructor(params: Params) {\n    this.#params = params\n  }\n\n  get params(): Params {\n    return this.#params\n  }\n\n  get flatParams(): Params {\n    const flatter = (acc: Params, [key, item]: [key: string, item?: Param]): Params => {\n      if (item?.children) {\n        return Object.entries(item.children).reduce(flatter, acc)\n      }\n      if (item) {\n        acc[key] = item\n      }\n\n      return acc\n    }\n    return Object.entries(this.#params).reduce(flatter, {} as Params)\n  }\n\n  toCall({ transformName, transformType }: Pick<Options, 'transformName' | 'transformType'> = {}): string {\n    return getFunctionParams(this.#params, { type: 'call', transformName, transformType })\n  }\n\n  toObject(): string {\n    return getFunctionParams(this.#params, { type: 'object' })\n  }\n  toObjectValue(): string {\n    return getFunctionParams(this.#params, { type: 'objectValue' })\n  }\n\n  toConstructor(): string {\n    return getFunctionParams(this.#params, { type: 'constructor' })\n  }\n}\n","// import './globals.ts'\nimport * as React from 'react'\n\nexport type { Fabric } from '@kubb/fabric-core'\n// expose fabric core helpers\nexport { createFabric, createFile, FileManager, FileProcessor } from '@kubb/fabric-core'\n\n// react helpers\nexport const useState = React.useState\nexport const createContext = React.createContext\nexport const createElement = React.createElement\nexport const Fragment = React.Fragment\nexport const use = React.use\nexport const useContext = React.useContext\nexport const useEffect = React.useEffect\nexport const useReducer = React.useReducer\nexport const useRef = React.useRef\n// components\nexport { App } from './components/App.tsx'\nexport { Const } from './components/Const.tsx'\nexport { File } from './components/File.tsx'\nexport { Function } from './components/Function.tsx'\nexport { Type } from './components/Type.tsx'\n\n// composables\nexport { useApp } from './composables/useApp.ts'\nexport { useFile } from './composables/useFile.ts'\nexport { useLifecycle } from './composables/useLifecycle.tsx'\n\n// factories\nexport { createReactFabric } from './createReactFabric.ts'\nexport { openDevtools } from './devtools.ts'\nexport { Runtime } from './Runtime.tsx'\n// utils\nexport { createFunctionParams, FunctionParams } from './utils/getFunctionParams.ts'\n"],"mappings":"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"}