{"version":3,"sources":["/home/runner/work/kubb/kubb/packages/parser-ts/dist/index.cjs","../src/api.ts","../src/print.ts","../src/parse.ts"],"names":["sourceFile","ts"],"mappings":"AAAA;AACE;AACF,wDAA6B;AAC7B;AACA;ACJA,wEAAiB;AAEjB,gGAAe;AAUR,SAAS,UAAA,CAAW,QAAA,EAAoD;AAC7E,EAAA,MAAM,SAAA,EAAW,cAAA,CAAK,OAAA,CAAQ,QAAQ,EAAA,EAAI,SAAA,EAAW,CAAA,EAAA;AAEtC,EAAA;AACN,IAAA;AACT,EAAA;AAEiC,EAAA;AACX,IAAA;AACV,IAAA;AACX,EAAA;AAEsC,EAAA;AACA,EAAA;AACSA,EAAAA;AAE/B,EAAA;AACR,IAAA;AACT,EAAA;AAEqD,EAAA;AAEjC,EAAA;AACX,IAAA;AACT,EAAA;AAEiD,EAAA;AACvB,EAAA;AAEc,IAAA;AAE/B,IAAA;AACwB,MAAA;AACJ,MAAA;AAC3B,IAAA;AACD,EAAA;AACH;ADbwD;AACA;AEpCzC;AAIKC;AAY2C;AAOR;AAI3B;AAEuB,EAAA;AAChB,EAAA;AACR,IAAA;AACvB,IAAA;AACA,IAAA;AACA,IAAA;AACD,EAAA;AAE4B,EAAA;AAEd,EAAA;AACN,IAAA;AACT,EAAA;AAE6B,EAAA;AACI,IAAA;AAC1B,EAAA;AAC4B,IAAA;AACnC,EAAA;AAEmD,EAAA;AACF,EAAA;AAEE,EAAA;AACrD;AFSwD;AACA;AGtDP;AACxC,EAAA;AACL,IAAA;AACe,IAAA;AACjB,EAAA;AACF;AHwDwD;AACA;AACA;AACA;AACA;AACA","file":"/home/runner/work/kubb/kubb/packages/parser-ts/dist/index.cjs","sourcesContent":[null,"import path from 'node:path'\n\nimport ts from 'typescript'\n\ntype ExportsResult = {\n  name: string\n  isTypeOnly: boolean\n}\n\n/**\n * @link https://github.com/microsoft/TypeScript/issues/15840\n */\nexport function getExports(filePath: string): undefined | Array<ExportsResult> {\n  const rootName = path.extname(filePath) ? filePath : `${filePath}.ts`\n\n  if (!rootName) {\n    return undefined\n  }\n\n  const program = ts.createProgram({\n    rootNames: [rootName],\n    options: {},\n  })\n\n  const checker = program.getTypeChecker()\n  const sources = program.getSourceFiles()\n  const sourceFile = sources.find((sourceFile) => sourceFile.fileName === rootName)\n\n  if (!sourceFile) {\n    return undefined\n  }\n\n  const symbol = checker.getSymbolAtLocation(sourceFile)\n\n  if (!symbol?.flags) {\n    return undefined\n  }\n\n  const exports = checker.getExportsOfModule(symbol)\n  return exports.map((e) => {\n    // 5 is type and 90 is const\n    const type = checker.getTypeOfSymbol(e) as unknown as { id?: 5 | 90 }\n\n    return {\n      name: e.escapedName.toString(),\n      isTypeOnly: type?.id === 5,\n    }\n  })\n}\n","import ts from 'typescript'\n\nimport type { PrinterOptions } from 'typescript'\n\nconst { factory } = ts\n\ntype Options = {\n  source?: string\n  baseName?: string\n} & PrinterOptions\n\n/**\n * Escaped new lines in code with block comments so they can be restored by {@link restoreNewLines}\n * @param {string} code The code to escape new lines in\n * @returns The same code but with new lines escaped using block comments\n */\nconst escapeNewLines = (code: string) => code.replace(/\\n\\n/g, '\\n/* :newline: */')\n\n/**\n * Reverses {@link escapeNewLines} and restores new lines\n * @param {string} code The code with escaped new lines\n * @returns The same code with new lines restored\n */\nconst restoreNewLines = (code: string) => code.replace(/\\/\\* :newline: \\*\\//g, '\\n')\n\nexport function print(\n  elements: ts.Node | Array<ts.Node | undefined> | null,\n  { source = '', baseName = 'print.ts', removeComments, noEmitHelpers, newLine = ts.NewLineKind.LineFeed }: Options = {},\n): string {\n  const sourceFile = ts.createSourceFile(baseName, escapeNewLines(source), ts.ScriptTarget.ES2022, false, ts.ScriptKind.TS)\n  const printer = ts.createPrinter({\n    omitTrailingSemicolon: true,\n    newLine,\n    removeComments,\n    noEmitHelpers,\n  })\n\n  let nodes: Array<ts.Node> = []\n\n  if (!elements) {\n    return ''\n  }\n\n  if (Array.isArray(elements)) {\n    nodes = elements.filter(Boolean)\n  } else {\n    nodes = [elements].filter(Boolean)\n  }\n\n  const outputFile = printer.printList(ts.ListFormat.MultiLine, factory.createNodeArray(nodes), sourceFile)\n  const outputSource = printer.printFile(sourceFile)\n\n  return [outputFile, restoreNewLines(outputSource)].filter(Boolean).join('\\n')\n}\n","import { print } from './print.ts'\n\nimport type ts from 'typescript'\n\ntype ParseResult = {\n  ast: ts.Node\n  text: string\n}\n\nexport function parse(ast: ts.Node): ParseResult {\n  return {\n    ast,\n    text: print(ast),\n  }\n}\n"]}