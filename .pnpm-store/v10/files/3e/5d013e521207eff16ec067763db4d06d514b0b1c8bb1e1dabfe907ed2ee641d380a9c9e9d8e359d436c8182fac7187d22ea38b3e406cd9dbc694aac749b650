{"version":3,"sources":["../src/utils/index.ts","../src/utils/getComments.ts","../src/utils/getGroupedByTagFiles.ts","../src/utils/getParams.ts","../src/utils/refSorter.ts"],"sourcesContent":["export { getComments } from './getComments.ts'\nexport { getGroupedByTagFiles } from './getGroupedByTagFiles.ts'\nexport { getASTParams, getPathParams } from './getParams.ts'\nexport { getSchemaFactory } from './getSchemaFactory.ts'\nexport type { GetSchemasProps } from './getSchemas.ts'\nexport { getSchemas } from './getSchemas.ts'\nexport { refsSorter } from './refSorter.ts'\nexport { parseFromConfig } from './parseFromConfig.ts'\n","import transformers from '@kubb/core/transformers'\nimport { URLPath } from '@kubb/core/utils'\n\nimport type { Operation } from '@kubb/oas'\n\nexport function getComments(operation: Operation): string[] {\n  return [\n    operation.getDescription() && `@description ${operation.getDescription()}`,\n    operation.getSummary() && `@summary ${operation.getSummary()}`,\n    operation.path && `@link ${new URLPath(operation.path).URL}`,\n    operation.isDeprecated() && '@deprecated',\n  ]\n    .filter(Boolean)\n    .map((text) => transformers.trim(text))\n}\n","import { resolve } from 'node:path'\n\nimport { FileManager } from '@kubb/core'\nimport transformers from '@kubb/core/transformers'\nimport { renderTemplate } from '@kubb/core/utils'\nimport { getRelativePath } from '@kubb/fs'\n\nimport type { Plugin } from '@kubb/core'\nimport type { Logger } from '@kubb/core/logger'\nimport type * as KubbFile from '@kubb/fs/types'\n\ntype Options = {\n  logger: Logger\n  files: Array<KubbFile.File<FileMeta>>\n  plugin: Plugin\n  template: string\n  exportAs: string\n  /**\n   * Root based on root and output.path specified in the config\n   */\n  root: string\n  /**\n   * Output for plugin\n   */\n  output: {\n    path: string\n    exportAs?: string\n    extName?: KubbFile.Extname\n    exportType?: 'barrel' | 'barrelNamed' | false\n  }\n}\n\ntype FileMeta = {\n  pluginKey?: Plugin['key']\n  tag?: string\n}\n\nexport async function getGroupedByTagFiles({ logger, files, plugin, template, exportAs, root, output }: Options): Promise<KubbFile.File<FileMeta>[]> {\n  const { path, exportType = 'barrel' } = output\n  const mode = FileManager.getMode(resolve(root, path))\n\n  if (mode === 'single' || exportType === false) {\n    return []\n  }\n\n  return files\n    .filter((file) => {\n      const name = file.meta?.pluginKey?.[0]\n      return name === plugin.name\n    })\n    .map((file: KubbFile.File<FileMeta>) => {\n      if (!file.meta?.tag) {\n        logger?.emit('debug', [`Could not find a tagName for ${JSON.stringify(file, undefined, 2)}`])\n\n        return\n      }\n\n      const tag = file.meta?.tag && transformers.camelCase(file.meta.tag)\n      const tagPath = getRelativePath(resolve(root, output.path), resolve(root, renderTemplate(template, { tag })))\n      const tagName = renderTemplate(exportAs, { tag })\n\n      if (tagName) {\n        return {\n          baseName: 'index.ts' as const,\n          path: resolve(root, output.path, 'index.ts'),\n          source: '',\n          exports: [\n            {\n              path: output.extName ? `${tagPath}/index${output.extName}` : `${tagPath}/index`,\n              asAlias: true,\n              name: tagName,\n            },\n          ],\n          meta: {\n            pluginKey: plugin.key,\n          },\n          exportable: true,\n        }\n      }\n    })\n    .filter(Boolean)\n}\n","import { isParameterObject } from '@kubb/oas'\n\nimport type { FunctionParamsAST } from '@kubb/core/utils'\nimport type { OasTypes } from '@kubb/oas'\nimport type { Params } from '@kubb/react'\nimport type { OperationSchema } from '../types.ts'\nimport { camelCase } from '@kubb/core/transformers'\n/**\n *\n * @deprecated\n * TODO move to operationManager hook\n */\nexport function getASTParams(\n  operationSchema: OperationSchema | undefined,\n  {\n    typed = false,\n    override,\n  }: {\n    typed?: boolean\n    override?: (data: FunctionParamsAST) => FunctionParamsAST\n  } = {},\n): FunctionParamsAST[] {\n  if (!operationSchema || !operationSchema.schema.properties || !operationSchema.name) {\n    return []\n  }\n\n  return Object.entries(operationSchema.schema.properties).map(([name, schema]: [string, OasTypes.SchemaObject]) => {\n    const isParam = isParameterObject(schema)\n    const data: FunctionParamsAST = {\n      name,\n      enabled: !!name,\n      required: isParam ? schema.required : true,\n      type: typed ? `${operationSchema.name}[\"${name}\"]` : undefined,\n    }\n\n    return override ? override(data) : data\n  })\n}\n\nexport function getPathParams(\n  operationSchema: OperationSchema | undefined,\n  options: {\n    typed?: boolean\n    override?: (data: FunctionParamsAST) => FunctionParamsAST\n  } = {},\n) {\n  return getASTParams(operationSchema, options).reduce((acc, curr) => {\n    if (curr.name && curr.enabled) {\n      acc[camelCase(curr.name)] = {\n        default: curr.default,\n        type: curr.type,\n        optional: !curr.required,\n      }\n    }\n\n    return acc\n  }, {} as Params)\n}\n","import type { Refs } from '../types.ts'\n\ntype Generated = { import: { refs: Refs; name: string } }\n\nexport function refsSorter<T extends Generated>(a: T, b: T): number {\n  if (Object.keys(a.import.refs)?.length < Object.keys(b.import.refs)?.length) {\n    return -1\n  }\n  if (Object.keys(a.import.refs)?.length > Object.keys(b.import.refs)?.length) {\n    return 1\n  }\n  return 0\n}\n"],"mappings":"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","names":["transformers"]}