import { E as Extname, N as __name, a as FabricElement, l as Plugin, u as UserPlugin } from "./Fabric-yRxItrhk.cjs";
import { r as TreeNode, t as ComponentNode } from "./useNodeTree-CdlPBTwH.cjs";

//#region src/plugins/barrelPlugin.d.ts
type Mode = 'all' | 'named' | 'propagate' | false;
type Options$4 = {
  root: string;
  mode: Mode;
  dryRun?: boolean;
};
type WriteEntryOptions = {
  root: string;
  mode: Mode;
};
type ExtendOptions$2 = {
  /**
   * `fabric.writeEntry` should be called before `fabric.write`
   */
  writeEntry(options: WriteEntryOptions): Promise<void>;
};
declare global {
  namespace Kubb {
    interface Fabric {
      /**
       * `fabric.writeEntry` should be called before `fabric.write`
       */
      writeEntry(options: WriteEntryOptions): Promise<void>;
    }
  }
}
declare const barrelPlugin: Plugin<Options$4, ExtendOptions$2>;
//#endregion
//#region src/plugins/definePlugin.d.ts
declare function definePlugin<Options = unknown, TAppExtension extends Record<string, any> = {}>(plugin: UserPlugin<Options, TAppExtension>): Plugin<Options, TAppExtension>;
//#endregion
//#region src/plugins/fsPlugin.d.ts
type WriteOptions = {
  extension?: Record<Extname, Extname | ''>;
};
type Options$3 = {
  dryRun?: boolean;
  /**
   * Optional callback that is invoked whenever a file is written by the plugin.
   * Useful for tests to observe write operations without spying on internal functions.
   */
  onBeforeWrite?: (path: string, data: string | undefined) => void | Promise<void>;
  clean?: {
    path: string;
  };
};
type ExtendOptions$1 = {
  write(options?: WriteOptions): Promise<void>;
};
declare global {
  namespace Kubb {
    interface Fabric {
      write(options?: WriteOptions): Promise<void>;
    }
  }
}
declare const fsPlugin: Plugin<Options$3, ExtendOptions$1>;
//#endregion
//#region src/plugins/fsxPlugin/fsxPlugin.d.ts
type Options$2 = {
  treeNode?: TreeNode<ComponentNode>;
  /**
   * Set this to true to always see the result of the render in the console(line per render)
   */
  debug?: boolean;
};
type ExtendOptions = {
  render(App: FabricElement<any>): Promise<string>;
  waitUntilExit(): Promise<void>;
};
declare global {
  namespace Kubb {
    interface Fabric {
      render(App: FabricElement<any>): Promise<string>;
      waitUntilExit(): Promise<void>;
    }
  }
}
declare const fsxPlugin: Plugin<Options$2, ExtendOptions>;
//#endregion
//#region src/plugins/graphPlugin.d.ts
type Options$1 = {
  root: string;
  /**
   * @default false
   */
  open?: boolean;
};
declare const graphPlugin: Plugin<Options$1, {}>;
//#endregion
//#region src/plugins/loggerPlugin.d.ts
type WebSocketOptions = {
  /**
   * Hostname to bind the websocket server to.
   * @default '127.0.0.1'
   */
  host?: string;
  /**
   * Port to bind the websocket server to.
   * @default 0 (random available port)
   */
  port?: number;
};
type Options = {
  /**
   * Toggle progress bar output.
   * @default true
   */
  progress?: boolean;
  /**
   * Toggle or configure the websocket broadcast server.
   * When `true`, a websocket server is started on an ephemeral port.
   * When `false`, websocket support is disabled.
   * When providing an object, the server uses the supplied host and port.
   * @default true
   */
  websocket?: boolean | WebSocketOptions;
};
declare const loggerPlugin: Plugin<Options, {}>;
//#endregion
export { barrelPlugin, definePlugin, fsPlugin, fsxPlugin, graphPlugin, loggerPlugin };
//# sourceMappingURL=plugins.d.cts.map