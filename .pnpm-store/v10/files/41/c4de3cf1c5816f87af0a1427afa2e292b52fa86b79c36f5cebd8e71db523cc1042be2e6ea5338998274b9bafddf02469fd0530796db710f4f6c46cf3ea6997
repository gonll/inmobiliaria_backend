const require_getRelativePath = require('./getRelativePath-jYLCpluV.cjs');
let node_path = require("node:path");
node_path = require_getRelativePath.__toESM(node_path);
let typescript = require("typescript");
typescript = require_getRelativePath.__toESM(typescript);

//#region src/parsers/typescriptParser.ts
const { factory } = typescript.default;
/**
* Validates TypeScript AST nodes before printing to catch invalid nodes early.
* Throws an error if any node has SyntaxKind.Unknown which would cause the TypeScript printer to crash.
*/
function validateNodes(...nodes) {
	for (const node of nodes) {
		if (!node) throw new Error("Attempted to print undefined or null TypeScript node");
		if (node.kind === typescript.default.SyntaxKind.Unknown) throw new Error(`Invalid TypeScript AST node detected with SyntaxKind.Unknown. This typically indicates a schema pattern that couldn't be properly converted to TypeScript. Node: ${JSON.stringify(node, null, 2)}`);
	}
}
/**
* Convert AST TypeScript/TSX nodes to a string based on the TypeScript printer.
*/
function print(...elements) {
	const sourceFile = typescript.default.createSourceFile("print.tsx", "", typescript.default.ScriptTarget.ES2022, true, typescript.default.ScriptKind.TSX);
	const printer = typescript.default.createPrinter({
		omitTrailingSemicolon: true,
		newLine: typescript.default.NewLineKind.LineFeed,
		removeComments: false,
		noEmitHelpers: true
	});
	for (const node of elements) if (node.kind === typescript.default.SyntaxKind.Unknown) console.error("⚠️ Unknown node found:", node);
	return printer.printList(typescript.default.ListFormat.MultiLine, factory.createNodeArray(elements.filter(Boolean)), sourceFile).replace(/\r\n/g, "\n");
}
function safePrint(...elements) {
	validateNodes(...elements);
	return print(...elements);
}
function createImport({ name, path, root, isTypeOnly = false, isNameSpace = false }) {
	const resolvePath = root ? require_getRelativePath.getRelativePath(root, path) : path;
	if (!Array.isArray(name)) {
		if (isNameSpace) return factory.createImportDeclaration(void 0, factory.createImportClause(isTypeOnly, void 0, factory.createNamespaceImport(factory.createIdentifier(name))), factory.createStringLiteral(resolvePath), void 0);
		return factory.createImportDeclaration(void 0, factory.createImportClause(isTypeOnly, factory.createIdentifier(name), void 0), factory.createStringLiteral(resolvePath), void 0);
	}
	const specifiers = name.map((item) => {
		if (typeof item === "object") {
			const { propertyName, name: alias } = item;
			return factory.createImportSpecifier(false, alias ? factory.createIdentifier(propertyName) : void 0, factory.createIdentifier(alias !== null && alias !== void 0 ? alias : propertyName));
		}
		return factory.createImportSpecifier(false, void 0, factory.createIdentifier(item));
	});
	return factory.createImportDeclaration(void 0, factory.createImportClause(isTypeOnly, void 0, factory.createNamedImports(specifiers)), factory.createStringLiteral(resolvePath), void 0);
}
function createExport({ path, asAlias, isTypeOnly = false, name }) {
	if (name && !Array.isArray(name) && !asAlias) console.warn(`When using name as string, asAlias should be true ${name}`);
	if (!Array.isArray(name)) {
		const parsedName = (name === null || name === void 0 ? void 0 : name.match(/^\d/)) ? `_${name === null || name === void 0 ? void 0 : name.slice(1)}` : name;
		return factory.createExportDeclaration(void 0, isTypeOnly, asAlias && parsedName ? factory.createNamespaceExport(factory.createIdentifier(parsedName)) : void 0, factory.createStringLiteral(path), void 0);
	}
	return factory.createExportDeclaration(void 0, isTypeOnly, factory.createNamedExports(name.map((propertyName) => {
		return factory.createExportSpecifier(false, void 0, typeof propertyName === "string" ? factory.createIdentifier(propertyName) : propertyName);
	})), factory.createStringLiteral(path), void 0);
}
const typescriptParser = require_getRelativePath.defineParser({
	name: "typescript",
	extNames: [".ts", ".js"],
	install() {},
	async parse(file, options = { extname: ".ts" }) {
		const sourceParts = [];
		for (const item of file.sources) if (item.value) sourceParts.push(item.value);
		const source = sourceParts.join("\n\n");
		const importNodes = [];
		for (const item of file.imports) {
			const importPath = item.root ? require_getRelativePath.getRelativePath(item.root, item.path) : item.path;
			const hasExtname = !!node_path.default.extname(importPath);
			importNodes.push(createImport({
				name: item.name,
				path: options.extname && hasExtname ? `${require_getRelativePath.trimExtName(importPath)}${options.extname}` : item.root ? require_getRelativePath.trimExtName(importPath) : importPath,
				isTypeOnly: item.isTypeOnly
			}));
		}
		const exportNodes = [];
		for (const item of file.exports) {
			const exportPath = item.path;
			const hasExtname = !!node_path.default.extname(exportPath);
			exportNodes.push(createExport({
				name: item.name,
				path: options.extname && hasExtname ? `${require_getRelativePath.trimExtName(item.path)}${options.extname}` : require_getRelativePath.trimExtName(item.path),
				isTypeOnly: item.isTypeOnly,
				asAlias: item.asAlias
			}));
		}
		return [
			file.banner,
			print(...importNodes, ...exportNodes),
			source,
			file.footer
		].filter((segment) => segment != null).join("\n");
	}
});

//#endregion
Object.defineProperty(exports, 'createExport', {
  enumerable: true,
  get: function () {
    return createExport;
  }
});
Object.defineProperty(exports, 'createImport', {
  enumerable: true,
  get: function () {
    return createImport;
  }
});
Object.defineProperty(exports, 'print', {
  enumerable: true,
  get: function () {
    return print;
  }
});
Object.defineProperty(exports, 'safePrint', {
  enumerable: true,
  get: function () {
    return safePrint;
  }
});
Object.defineProperty(exports, 'typescriptParser', {
  enumerable: true,
  get: function () {
    return typescriptParser;
  }
});
Object.defineProperty(exports, 'validateNodes', {
  enumerable: true,
  get: function () {
    return validateNodes;
  }
});
//# sourceMappingURL=typescriptParser-3Mjce6yD.cjs.map