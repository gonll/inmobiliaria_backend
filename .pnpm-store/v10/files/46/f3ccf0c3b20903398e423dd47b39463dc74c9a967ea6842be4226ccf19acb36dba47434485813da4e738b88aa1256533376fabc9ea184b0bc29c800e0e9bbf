{"version":3,"sources":["../src/SchemaMapper.ts","../src/SchemaGenerator.ts"],"sourcesContent":["import type * as KubbFile from '@kubb/fs/types'\n\nexport type SchemaKeywordMapper = {\n  object: {\n    keyword: 'object'\n    args: {\n      properties: { [x: string]: Schema[] }\n      additionalProperties: Schema[]\n      strict?: boolean\n    }\n  }\n  strict: { keyword: 'strict' }\n  url: { keyword: 'url' }\n  readOnly: { keyword: 'readOnly' }\n  writeOnly: { keyword: 'writeOnly' }\n  uuid: { keyword: 'uuid' }\n  email: { keyword: 'email' }\n  firstName: { keyword: 'firstName' }\n  lastName: { keyword: 'lastName' }\n  phone: { keyword: 'phone' }\n  password: { keyword: 'password' }\n  date: { keyword: 'date'; args: { type?: 'date' | 'string' } }\n  time: { keyword: 'time'; args: { type?: 'date' | 'string' } }\n  datetime: { keyword: 'datetime'; args: { offset?: boolean; local?: boolean } }\n  tuple: { keyword: 'tuple'; args: { items: Schema[]; min?: number; max?: number } }\n  array: {\n    keyword: 'array'\n    args: { items: Schema[]; min?: number; max?: number }\n  }\n  enum: {\n    keyword: 'enum'\n    args: {\n      name: string\n      typeName: string\n      asConst: boolean\n      items: Array<{\n        name: string | number\n        format: 'string' | 'number' | 'boolean'\n        value?: string | number | boolean\n      }>\n    }\n  }\n  and: { keyword: 'and'; args: Schema[] }\n  const: {\n    keyword: 'const'\n    args: {\n      name: string | number\n      format: 'string' | 'number' | 'boolean'\n      value?: string | number | boolean\n    }\n  }\n  union: { keyword: 'union'; args: Schema[] }\n  ref: {\n    keyword: 'ref'\n    args: { name: string; path: KubbFile.OptionalPath }\n  }\n  matches: { keyword: 'matches'; args?: string }\n  boolean: { keyword: 'boolean' }\n  default: { keyword: 'default'; args: string | number | boolean }\n  string: { keyword: 'string' }\n  integer: { keyword: 'integer' }\n  number: { keyword: 'number' }\n  max: { keyword: 'max'; args: number }\n  min: { keyword: 'min'; args: number }\n  describe: { keyword: 'describe'; args: string }\n  example: { keyword: 'example'; args: string }\n  deprecated: { keyword: 'deprecated' }\n  optional: { keyword: 'optional' }\n  undefined: { keyword: 'undefined' }\n  nullish: { keyword: 'nullish' }\n  nullable: { keyword: 'nullable' }\n  null: { keyword: 'null' }\n  any: { keyword: 'any' }\n  unknown: { keyword: 'unknown' }\n  blob: { keyword: 'blob' }\n  schema: { keyword: 'schema'; args: { type: 'string' | 'number' | 'integer' | 'boolean' | 'array' | 'object'; format?: string } }\n  name: { keyword: 'name'; args: string }\n  catchall: { keyword: 'catchall' }\n}\n\nexport const schemaKeywords = {\n  any: 'any',\n  strict: 'strict',\n  unknown: 'unknown',\n  number: 'number',\n  integer: 'integer',\n  string: 'string',\n  boolean: 'boolean',\n  undefined: 'undefined',\n  nullable: 'nullable',\n  null: 'null',\n  nullish: 'nullish',\n  array: 'array',\n  tuple: 'tuple',\n  enum: 'enum',\n  union: 'union',\n  datetime: 'datetime',\n  date: 'date',\n  email: 'email',\n  uuid: 'uuid',\n  url: 'url',\n  /* intersection */\n  default: 'default',\n  const: 'const',\n  and: 'and',\n  describe: 'describe',\n  min: 'min',\n  max: 'max',\n  optional: 'optional',\n  readOnly: 'readOnly',\n  writeOnly: 'writeOnly',\n\n  // custom ones\n  object: 'object',\n  ref: 'ref',\n  matches: 'matches',\n  firstName: 'firstName',\n  lastName: 'lastName',\n  password: 'password',\n  phone: 'phone',\n  blob: 'blob',\n  deprecated: 'deprecated',\n  example: 'example',\n  schema: 'schema',\n  catchall: 'catchall',\n  time: 'time',\n  name: 'name',\n} satisfies {\n  [K in keyof SchemaKeywordMapper]: SchemaKeywordMapper[K]['keyword']\n}\n\nexport type SchemaKeyword = keyof SchemaKeywordMapper\n\nexport type SchemaMapper<T = string | null | undefined> = {\n  [K in keyof SchemaKeywordMapper]: (() => T | undefined) | undefined\n}\n\nexport type SchemaKeywordBase<T> = {\n  keyword: SchemaKeyword\n  args: T\n}\n\nexport type Schema = { keyword: string } | SchemaKeywordMapper[keyof SchemaKeywordMapper]\n\nexport function isKeyword<T extends Schema, K extends keyof SchemaKeywordMapper>(meta: T, keyword: K): meta is Extract<T, SchemaKeywordMapper[K]> {\n  return meta.keyword === keyword\n}\n","import { type FileMetaBase, Generator } from '@kubb/core'\nimport transformers, { pascalCase } from '@kubb/core/transformers'\nimport { getUniqueName } from '@kubb/core/utils'\n\nimport { isReference } from '@kubb/oas'\nimport { isDeepEqual, isNumber, uniqueWith } from 'remeda'\nimport { isKeyword, schemaKeywords } from './SchemaMapper.ts'\nimport { getSchemaFactory } from './utils/getSchemaFactory.ts'\nimport { getSchemas } from './utils/getSchemas.ts'\n\nimport type { Plugin, PluginFactoryOptions, PluginManager, ResolveNameParams } from '@kubb/core'\nimport type * as KubbFile from '@kubb/fs/types'\n\nimport type { Oas, OpenAPIV3, SchemaObject, contentType } from '@kubb/oas'\nimport type { Schema, SchemaKeywordMapper } from './SchemaMapper.ts'\nimport type { OperationSchema, Override, Refs } from './types.ts'\n\nexport type GetSchemaGeneratorOptions<T extends SchemaGenerator<any, any, any>> = T extends SchemaGenerator<infer Options, any, any> ? Options : never\n\nexport type SchemaMethodResult<TFileMeta extends FileMetaBase> = Promise<KubbFile.File<TFileMeta> | Array<KubbFile.File<TFileMeta>> | null>\n\ntype Context<TOptions, TPluginOptions extends PluginFactoryOptions> = {\n  oas: Oas\n  pluginManager: PluginManager\n  /**\n   * Current plugin\n   */\n  plugin: Plugin<TPluginOptions>\n  mode: KubbFile.Mode\n  include?: Array<'schemas' | 'responses' | 'requestBodies'>\n  override: Array<Override<TOptions>> | undefined\n  contentType?: contentType\n  output?: string\n}\n\nexport type SchemaGeneratorOptions = {\n  dateType: false | 'string' | 'stringOffset' | 'stringLocal' | 'date'\n  unknownType: 'any' | 'unknown'\n  enumType?: 'enum' | 'asConst' | 'asPascalConst' | 'constEnum' | 'literal'\n  enumSuffix?: string\n  usedEnumNames?: Record<string, number>\n  mapper?: Record<string, string>\n  typed?: boolean\n  transformers: {\n    /**\n     * Customize the names based on the type that is provided by the plugin.\n     */\n    name?: (name: ResolveNameParams['name'], type?: ResolveNameParams['type']) => string\n    /**\n     * Receive schema and name(propertName) and return FakerMeta array\n     * TODO TODO add docs\n     * @beta\n     */\n    schema?: (schemaProps: SchemaProps, defaultSchemas: Schema[]) => Schema[] | undefined\n  }\n}\n\nexport type SchemaGeneratorBuildOptions = Omit<OperationSchema, 'name' | 'schema'>\n\ntype SchemaProps = {\n  schema?: SchemaObject\n  name?: string\n  parentName?: string\n}\n\nexport abstract class SchemaGenerator<\n  TOptions extends SchemaGeneratorOptions = SchemaGeneratorOptions,\n  TPluginOptions extends PluginFactoryOptions = PluginFactoryOptions,\n  TFileMeta extends FileMetaBase = FileMetaBase,\n> extends Generator<TOptions, Context<TOptions, TPluginOptions>> {\n  // Collect the types of all referenced schemas, so we can export them later\n  refs: Refs = {}\n\n  // Keep track of already used type aliases\n  #usedAliasNames: Record<string, number> = {}\n\n  /**\n   * Creates a type node from a given schema.\n   * Delegates to getBaseTypeFromSchema internally and\n   * optionally adds a union with null.\n   */\n  parse(props: SchemaProps): Schema[] {\n    const options = this.#getOptions(props)\n\n    const defaultSchemas = this.#parseSchemaObject(props)\n    const schemas = options.transformers?.schema?.(props, defaultSchemas) || defaultSchemas || []\n\n    return uniqueWith(schemas, isDeepEqual)\n  }\n\n  deepSearch<T extends keyof SchemaKeywordMapper>(tree: Schema[] | undefined, keyword: T): SchemaKeywordMapper[T][] {\n    return SchemaGenerator.deepSearch<T>(tree, keyword)\n  }\n\n  find<T extends keyof SchemaKeywordMapper>(tree: Schema[] | undefined, keyword: T): SchemaKeywordMapper[T] | undefined {\n    return SchemaGenerator.find<T>(tree, keyword)\n  }\n\n  static deepSearch<T extends keyof SchemaKeywordMapper>(tree: Schema[] | undefined, keyword: T): SchemaKeywordMapper[T][] {\n    const foundItems: SchemaKeywordMapper[T][] = []\n\n    tree?.forEach((schema) => {\n      if (schema.keyword === keyword) {\n        foundItems.push(schema as SchemaKeywordMapper[T])\n      }\n\n      if (schema.keyword === schemaKeywords.object) {\n        const subItem = schema as SchemaKeywordMapper['object']\n\n        Object.values(subItem.args?.properties || {}).forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>(entrySchema, keyword))\n        })\n\n        Object.values(subItem.args?.additionalProperties || {}).forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n        })\n      }\n\n      if (schema.keyword === schemaKeywords.array) {\n        const subItem = schema as SchemaKeywordMapper['array']\n\n        subItem.args.items.forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n        })\n      }\n\n      if (schema.keyword === schemaKeywords.and) {\n        const subItem = schema as SchemaKeywordMapper['and']\n\n        subItem.args.forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n        })\n      }\n\n      if (schema.keyword === schemaKeywords.tuple) {\n        const subItem = schema as SchemaKeywordMapper['tuple']\n\n        subItem.args.items.forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n        })\n      }\n\n      if (schema.keyword === schemaKeywords.union) {\n        const subItem = schema as SchemaKeywordMapper['union']\n\n        subItem.args.forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n        })\n      }\n    })\n\n    return foundItems\n  }\n\n  static findInObject<T extends keyof SchemaKeywordMapper>(tree: Schema[] | undefined, keyword: T): SchemaKeywordMapper[T] | undefined {\n    let foundItem: SchemaKeywordMapper[T] | undefined = undefined\n\n    tree?.forEach((schema) => {\n      if (!foundItem && schema.keyword === keyword) {\n        foundItem = schema as SchemaKeywordMapper[T]\n      }\n\n      if (schema.keyword === schemaKeywords.object) {\n        const subItem = schema as SchemaKeywordMapper['object']\n\n        Object.values(subItem.args?.properties || {}).forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>(entrySchema, keyword)\n          }\n        })\n\n        Object.values(subItem.args?.additionalProperties || {}).forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>([entrySchema], keyword)\n          }\n        })\n      }\n    })\n\n    return foundItem\n  }\n\n  static find<T extends keyof SchemaKeywordMapper>(tree: Schema[] | undefined, keyword: T): SchemaKeywordMapper[T] | undefined {\n    let foundItem: SchemaKeywordMapper[T] | undefined = undefined\n\n    tree?.forEach((schema) => {\n      if (!foundItem && schema.keyword === keyword) {\n        foundItem = schema as SchemaKeywordMapper[T]\n      }\n\n      if (schema.keyword === schemaKeywords.array) {\n        const subItem = schema as SchemaKeywordMapper['array']\n\n        subItem.args.items.forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>([entrySchema], keyword)\n          }\n        })\n      }\n\n      if (schema.keyword === schemaKeywords.and) {\n        const subItem = schema as SchemaKeywordMapper['and']\n\n        subItem.args.forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>([entrySchema], keyword)\n          }\n        })\n      }\n\n      if (schema.keyword === schemaKeywords.tuple) {\n        const subItem = schema as SchemaKeywordMapper['tuple']\n\n        subItem.args.items.forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>([entrySchema], keyword)\n          }\n        })\n      }\n\n      if (schema.keyword === schemaKeywords.union) {\n        const subItem = schema as SchemaKeywordMapper['union']\n\n        subItem.args.forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>([entrySchema], keyword)\n          }\n        })\n      }\n    })\n\n    return foundItem\n  }\n\n  #getUsedEnumNames(props: SchemaProps) {\n    const options = this.#getOptions(props)\n\n    return options.usedEnumNames || {}\n  }\n\n  #getOptions({ name }: SchemaProps): Partial<TOptions> {\n    const { override = [] } = this.context\n\n    return {\n      ...this.options,\n      ...(override.find(({ pattern, type }) => {\n        if (name && type === 'schemaName') {\n          return !!name.match(pattern)\n        }\n\n        return false\n      })?.options || {}),\n    }\n  }\n\n  #getUnknownReturn(props: SchemaProps) {\n    const options = this.#getOptions(props)\n\n    if (options.unknownType === 'any') {\n      return schemaKeywords.any\n    }\n\n    return schemaKeywords.unknown\n  }\n\n  /**\n   * Recursively creates a type literal with the given props.\n   */\n  #parseProperties({ schema, name }: SchemaProps): Schema[] {\n    const properties = schema?.properties || {}\n    const additionalProperties = schema?.additionalProperties\n    const required = schema?.required\n\n    const propertiesSchemas = Object.keys(properties)\n      .map((propertyName) => {\n        const validationFunctions: Schema[] = []\n        const propertySchema = properties[propertyName] as SchemaObject\n\n        const isRequired = Array.isArray(required) ? required?.includes(propertyName) : !!required\n        const nullable = propertySchema.nullable ?? propertySchema['x-nullable'] ?? false\n\n        validationFunctions.push(...this.parse({ schema: propertySchema, name: propertyName, parentName: name }))\n\n        validationFunctions.push({\n          keyword: schemaKeywords.name,\n          args: propertyName,\n        })\n\n        if (!isRequired && nullable) {\n          validationFunctions.push({ keyword: schemaKeywords.nullish })\n        } else if (!isRequired) {\n          validationFunctions.push({ keyword: schemaKeywords.optional })\n        }\n\n        return {\n          [propertyName]: validationFunctions,\n        }\n      })\n      .reduce((acc, curr) => ({ ...acc, ...curr }), {})\n    let additionalPropertiesSchemas: Schema[] = []\n\n    if (additionalProperties) {\n      additionalPropertiesSchemas =\n        additionalProperties === true || !Object.keys(additionalProperties).length\n          ? [{ keyword: this.#getUnknownReturn({ schema, name }) }]\n          : this.parse({ schema: additionalProperties as SchemaObject, parentName: name })\n    }\n\n    return [\n      {\n        keyword: schemaKeywords.object,\n        args: {\n          properties: propertiesSchemas,\n          additionalProperties: additionalPropertiesSchemas,\n        },\n      },\n    ]\n  }\n\n  /**\n   * Create a type alias for the schema referenced by the given ReferenceObject\n   */\n  #getRefAlias(obj: OpenAPIV3.ReferenceObject): Schema[] {\n    const { $ref } = obj\n    let ref = this.refs[$ref]\n\n    const originalName = getUniqueName($ref.replace(/.+\\//, ''), this.#usedAliasNames)\n    const propertyName = this.context.pluginManager.resolveName({\n      name: originalName,\n      pluginKey: this.context.plugin.key,\n      type: 'function',\n    })\n\n    if (ref) {\n      return [\n        {\n          keyword: schemaKeywords.ref,\n          args: { name: ref.propertyName, path: ref.path },\n        },\n      ]\n    }\n\n    const fileName = this.context.pluginManager.resolveName({\n      name: originalName,\n      pluginKey: this.context.plugin.key,\n      type: 'file',\n    })\n    const file = this.context.pluginManager.getFile({\n      name: fileName,\n      pluginKey: this.context.plugin.key,\n      extName: '.ts',\n    })\n\n    ref = this.refs[$ref] = {\n      propertyName,\n      originalName,\n      path: file.path,\n    }\n\n    return [\n      {\n        keyword: schemaKeywords.ref,\n        args: { name: ref.propertyName, path: ref?.path },\n      },\n    ]\n  }\n\n  #getParsedSchemaObject(schema?: SchemaObject) {\n    const parsedSchema = getSchemaFactory(this.context.oas)(schema)\n    return parsedSchema\n  }\n\n  /**\n   * This is the very core of the OpenAPI to TS conversion - it takes a\n   * schema and returns the appropriate type.\n   */\n  #parseSchemaObject({ schema: _schema, name, parentName }: SchemaProps): Schema[] {\n    const options = this.#getOptions({ schema: _schema, name })\n    const unknownReturn = this.#getUnknownReturn({ schema: _schema, name })\n    const { schema, version } = this.#getParsedSchemaObject(_schema)\n    if (!schema) {\n      return [{ keyword: unknownReturn }]\n    }\n\n    const baseItems: Schema[] = [\n      {\n        keyword: schemaKeywords.schema,\n        args: {\n          type: schema.type as any,\n          format: schema.format,\n        },\n      },\n    ]\n    const min = schema.minimum ?? schema.minLength ?? schema.minItems ?? undefined\n    const max = schema.maximum ?? schema.maxLength ?? schema.maxItems ?? undefined\n    const nullable = schema.nullable ?? schema['x-nullable'] ?? false\n\n    if (schema.default !== undefined && !Array.isArray(schema.default)) {\n      if (typeof schema.default === 'string') {\n        baseItems.push({\n          keyword: schemaKeywords.default,\n          args: transformers.stringify(schema.default),\n        })\n      } else if (typeof schema.default === 'boolean') {\n        baseItems.push({\n          keyword: schemaKeywords.default,\n          args: schema.default ?? false,\n        })\n      } else {\n        baseItems.push({\n          keyword: schemaKeywords.default,\n          args: schema.default,\n        })\n      }\n    }\n\n    if (schema.description) {\n      baseItems.push({\n        keyword: schemaKeywords.describe,\n        args: schema.description,\n      })\n    }\n\n    if (schema.pattern) {\n      baseItems.unshift({\n        keyword: schemaKeywords.matches,\n        args: schema.pattern,\n      })\n    }\n\n    if (max !== undefined) {\n      baseItems.unshift({ keyword: schemaKeywords.max, args: max })\n    }\n\n    if (min !== undefined) {\n      baseItems.unshift({ keyword: schemaKeywords.min, args: min })\n    }\n\n    if (nullable) {\n      baseItems.push({ keyword: schemaKeywords.nullable })\n    }\n\n    if (schema.type && Array.isArray(schema.type)) {\n      const [_schema, nullable] = schema.type\n\n      if (nullable === 'null') {\n        baseItems.push({ keyword: schemaKeywords.nullable })\n      }\n    }\n\n    if (schema.readOnly) {\n      baseItems.push({ keyword: schemaKeywords.readOnly })\n    }\n\n    if (schema.writeOnly) {\n      baseItems.push({ keyword: schemaKeywords.writeOnly })\n    }\n\n    if (isReference(schema)) {\n      return [\n        ...this.#getRefAlias(schema),\n        nullable && { keyword: schemaKeywords.nullable },\n        schema.readOnly && { keyword: schemaKeywords.readOnly },\n        schema.writeOnly && { keyword: schemaKeywords.writeOnly },\n        {\n          keyword: schemaKeywords.schema,\n          args: {\n            type: schema.type as any,\n            format: schema.format,\n          },\n        },\n      ].filter(Boolean)\n    }\n\n    if (schema.oneOf) {\n      // union\n      const schemaWithoutOneOf = { ...schema, oneOf: undefined }\n\n      const union: Schema = {\n        keyword: schemaKeywords.union,\n        args: schema.oneOf\n          .map((item) => {\n            return item && this.parse({ schema: item as SchemaObject, name, parentName })[0]\n          })\n          .filter(Boolean)\n          .filter((item) => {\n            return item && item.keyword !== unknownReturn\n          }),\n      }\n      if (schemaWithoutOneOf.properties) {\n        const propertySchemas = this.parse({ schema: schemaWithoutOneOf, name, parentName })\n\n        return [\n          {\n            ...union,\n            args: union.args.map((arg) => {\n              return {\n                keyword: schemaKeywords.and,\n                args: [arg, ...propertySchemas],\n              }\n            }),\n          },\n          ...baseItems,\n        ]\n      }\n\n      return [union, ...baseItems]\n    }\n\n    if (schema.anyOf) {\n      // union\n      const schemaWithoutAnyOf = { ...schema, anyOf: undefined }\n\n      const union: Schema = {\n        keyword: schemaKeywords.union,\n        args: schema.anyOf\n          .map((item) => {\n            return item && this.parse({ schema: item as SchemaObject, name, parentName })[0]\n          })\n          .filter(Boolean)\n          .filter((item) => {\n            return item && item.keyword !== unknownReturn\n          })\n          .map((item) => {\n            if (isKeyword(item, schemaKeywords.object)) {\n              return {\n                ...item,\n                args: {\n                  ...item.args,\n                  strict: true,\n                },\n              }\n            }\n            return item\n          }),\n      }\n      if (schemaWithoutAnyOf.properties) {\n        return [...this.parse({ schema: schemaWithoutAnyOf, name, parentName }), union, ...baseItems]\n      }\n\n      return [union, ...baseItems]\n    }\n    if (schema.allOf) {\n      // intersection/add\n      const schemaWithoutAllOf = { ...schema, allOf: undefined }\n\n      const and: Schema = {\n        keyword: schemaKeywords.and,\n        args: schema.allOf\n          .map((item) => {\n            return item && this.parse({ schema: item as SchemaObject, name, parentName })[0]\n          })\n          .filter(Boolean)\n          .filter((item) => {\n            return item && item.keyword !== unknownReturn\n          }),\n      }\n\n      if (schemaWithoutAllOf.properties) {\n        return [\n          {\n            ...and,\n            args: [...(and.args || []), ...this.parse({ schema: schemaWithoutAllOf, name, parentName })],\n          },\n          ...baseItems,\n        ]\n      }\n\n      return [and, ...baseItems]\n    }\n\n    if (schema.enum) {\n      const enumName = getUniqueName(pascalCase([parentName, name, options.enumSuffix].join(' ')), this.#getUsedEnumNames({ schema, name }))\n      const typeName = this.context.pluginManager.resolveName({\n        name: enumName,\n        pluginKey: this.context.plugin.key,\n        type: 'type',\n      })\n\n      const nullableEnum = schema.enum.includes(null)\n      if (nullableEnum) {\n        baseItems.push({ keyword: schemaKeywords.nullable })\n      }\n      const filteredValues = schema.enum.filter((value) => value !== null)\n\n      // x-enumNames has priority\n      const extensionEnums = ['x-enumNames', 'x-enum-varnames']\n        .filter((extensionKey) => extensionKey in schema)\n        .map((extensionKey) => {\n          return [\n            {\n              keyword: schemaKeywords.enum,\n              args: {\n                name,\n                typeName,\n                asConst: false,\n                items: [...new Set(schema[extensionKey as keyof typeof schema] as string[])].map((name: string | number, index) => ({\n                  name: transformers.stringify(name),\n                  value: schema.enum?.[index] as string | number,\n                  format: isNumber(schema.enum?.[index]) ? 'number' : 'string',\n                })),\n              },\n            },\n            ...baseItems.filter(\n              (item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max && item.keyword !== schemaKeywords.matches,\n            ),\n          ]\n        })\n\n      if (schema.type === 'number' || schema.type === 'integer') {\n        // we cannot use z.enum when enum type is number/integer\n        const enumNames = extensionEnums[0]?.find((item) => isKeyword(item, schemaKeywords.enum)) as unknown as SchemaKeywordMapper['enum']\n        return [\n          {\n            keyword: schemaKeywords.enum,\n            args: {\n              name: enumName,\n              typeName,\n              asConst: true,\n              items: enumNames?.args?.items\n                ? [...new Set(enumNames.args.items)].map(({ name, value }) => ({\n                    name,\n                    value,\n                    format: 'number',\n                  }))\n                : [...new Set(filteredValues)].map((value: string) => {\n                    return {\n                      name: value,\n                      value,\n                      format: 'number',\n                    }\n                  }),\n            },\n          },\n          ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max && item.keyword !== schemaKeywords.matches),\n        ]\n      }\n\n      if (schema.type === 'boolean') {\n        // we cannot use z.enum when enum type is boolean\n        const enumNames = extensionEnums[0]?.find((item) => isKeyword(item, schemaKeywords.enum)) as unknown as SchemaKeywordMapper['enum']\n        return [\n          {\n            keyword: schemaKeywords.enum,\n            args: {\n              name: enumName,\n              typeName,\n              asConst: true,\n              items: enumNames?.args?.items\n                ? [...new Set(enumNames.args.items)].map(({ name, value }) => ({\n                    name,\n                    value,\n                    format: 'boolean',\n                  }))\n                : [...new Set(filteredValues)].map((value: string) => {\n                    return {\n                      name: value,\n                      value,\n                      format: 'boolean',\n                    }\n                  }),\n            },\n          },\n          ...baseItems.filter((item) => item.keyword !== schemaKeywords.matches),\n        ]\n      }\n\n      if (extensionEnums.length > 0 && extensionEnums[0]) {\n        return extensionEnums[0]\n      }\n\n      return [\n        {\n          keyword: schemaKeywords.enum,\n          args: {\n            name: enumName,\n            typeName,\n            asConst: false,\n            items: [...new Set(filteredValues)].map((value: string) => ({\n              name: transformers.stringify(value),\n              value,\n              format: isNumber(value) ? 'number' : 'string',\n            })),\n          },\n        },\n        ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max && item.keyword !== schemaKeywords.matches),\n      ]\n    }\n\n    if ('prefixItems' in schema) {\n      const prefixItems = schema.prefixItems as SchemaObject[]\n      const min = schema.minimum ?? schema.minLength ?? schema.minItems ?? undefined\n      const max = schema.maximum ?? schema.maxLength ?? schema.maxItems ?? undefined\n\n      return [\n        {\n          keyword: schemaKeywords.tuple,\n          args: {\n            min,\n            max,\n            items: prefixItems\n              .map((item) => {\n                return this.parse({ schema: item, name, parentName })[0]\n              })\n              .filter(Boolean),\n          },\n        },\n        ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max),\n      ]\n    }\n\n    if (version === '3.1' && 'const' in schema) {\n      // const keyword takes precendence over the actual type.\n      if (schema['const']) {\n        return [\n          {\n            keyword: schemaKeywords.const,\n            args: {\n              name: schema['const'],\n              format: typeof schema['const'] === 'number' ? 'number' : 'string',\n              value: schema['const'],\n            },\n          },\n          ...baseItems,\n        ]\n      }\n      return [{ keyword: schemaKeywords.null }]\n    }\n\n    /**\n     * > Structural validation alone may be insufficient to allow an application to correctly utilize certain values. The \"format\"\n     * > annotation keyword is defined to allow schema authors to convey semantic information for a fixed subset of values which are\n     * > accurately described by authoritative resources, be they RFCs or other external specifications.\n     *\n     * In other words: format is more specific than type alone, hence it should override the type value, if possible.\n     *\n     * see also https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-validation-00#rfc.section.7\n     */\n    if (schema.format) {\n      switch (schema.format) {\n        case 'binary':\n          baseItems.push({ keyword: schemaKeywords.blob })\n          return baseItems\n        case 'date-time':\n          if (options.dateType) {\n            if (options.dateType === 'date') {\n              baseItems.unshift({ keyword: schemaKeywords.date, args: { type: 'date' } })\n\n              return baseItems\n            }\n\n            if (options.dateType === 'stringOffset') {\n              baseItems.unshift({ keyword: schemaKeywords.datetime, args: { offset: true } })\n              return baseItems\n            }\n\n            if (options.dateType === 'stringLocal') {\n              baseItems.unshift({ keyword: schemaKeywords.datetime, args: { local: true } })\n              return baseItems\n            }\n\n            baseItems.unshift({ keyword: schemaKeywords.datetime, args: { offset: false } })\n\n            return baseItems\n          }\n          break\n        case 'date':\n          if (options.dateType) {\n            if (options.dateType === 'date') {\n              baseItems.unshift({ keyword: schemaKeywords.date, args: { type: 'date' } })\n\n              return baseItems\n            }\n\n            baseItems.unshift({ keyword: schemaKeywords.date, args: { type: 'string' } })\n\n            return baseItems\n          }\n          break\n        case 'time':\n          if (options.dateType) {\n            if (options.dateType === 'date') {\n              baseItems.unshift({ keyword: schemaKeywords.time, args: { type: 'date' } })\n\n              return baseItems\n            }\n\n            baseItems.unshift({ keyword: schemaKeywords.time, args: { type: 'string' } })\n\n            return baseItems\n          }\n          break\n        case 'uuid':\n          baseItems.unshift({ keyword: schemaKeywords.uuid })\n          break\n        case 'email':\n        case 'idn-email':\n          baseItems.unshift({ keyword: schemaKeywords.email })\n          break\n        case 'uri':\n        case 'ipv4':\n        case 'ipv6':\n        case 'uri-reference':\n        case 'hostname':\n        case 'idn-hostname':\n          baseItems.unshift({ keyword: schemaKeywords.url })\n          break\n        // case 'duration':\n        // case 'json-pointer':\n        // case 'relative-json-pointer':\n        default:\n          // formats not yet implemented: ignore.\n          break\n      }\n    }\n\n    // type based logic\n    if ('items' in schema || schema.type === ('array' as 'string')) {\n      const min = schema.minimum ?? schema.minLength ?? schema.minItems ?? undefined\n      const max = schema.maximum ?? schema.maxLength ?? schema.maxItems ?? undefined\n      const items = this.parse({ schema: 'items' in schema ? (schema.items as SchemaObject) : [], name, parentName })\n\n      return [\n        {\n          keyword: schemaKeywords.array,\n          args: {\n            items,\n            min,\n            max,\n          },\n        },\n        ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max),\n      ]\n    }\n\n    if (schema.properties || schema.additionalProperties) {\n      return [...this.#parseProperties({ schema, name }), ...baseItems]\n    }\n\n    if (schema.type) {\n      if (Array.isArray(schema.type)) {\n        // OPENAPI v3.1.0: https://www.openapis.org/blog/2021/02/16/migrating-from-openapi-3-0-to-3-1-0\n        const [type] = schema.type as Array<OpenAPIV3.NonArraySchemaObjectType>\n\n        return [\n          ...this.parse({\n            schema: {\n              ...schema,\n              type,\n            },\n            name,\n            parentName,\n          }),\n          ...baseItems,\n        ].filter(Boolean)\n      }\n\n      if (!['boolean', 'object', 'number', 'string', 'integer', 'null'].includes(schema.type)) {\n        this.context.pluginManager.logger.emit('warning', `Schema type '${schema.type}' is not valid for schema ${parentName}.${name}`)\n      }\n\n      // 'string' | 'number' | 'integer' | 'boolean'\n      return [{ keyword: schema.type }, ...baseItems]\n    }\n\n    return [{ keyword: unknownReturn }]\n  }\n\n  async build(): Promise<Array<KubbFile.File<TFileMeta>>> {\n    const { oas, contentType, include } = this.context\n\n    oas.resolveDiscriminators()\n\n    const schemas = getSchemas({ oas, contentType, includes: include })\n\n    const promises = Object.entries(schemas).reduce((acc, [name, schema]) => {\n      const options = this.#getOptions({ name })\n      const promiseOperation = this.schema.call(this, name, schema, {\n        ...this.options,\n        ...options,\n      })\n\n      if (promiseOperation) {\n        acc.push(promiseOperation)\n      }\n\n      return acc\n    }, [] as SchemaMethodResult<TFileMeta>[])\n\n    const files = await Promise.all(promises)\n\n    // using .flat because schemaGenerator[method] can return a array of files or just one file\n    return files.flat().filter(Boolean)\n  }\n\n  /**\n   * Schema\n   */\n  abstract schema(name: string, object: SchemaObject, options: TOptions): SchemaMethodResult<TFileMeta>\n}\n"],"mappings":"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","names":["_schema","nullable","name","min","max"]}