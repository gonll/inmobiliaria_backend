{"version":3,"file":"generate-2cT6i5PV.cjs","names":["pc","version","pc","pc","pc","path","Writable","pc","LogLevel","process","clack","pc","frames","version","command","LogLevel","pc","frames","version","command","LogLevel","frames","command","LogLevel","command","pc","process","pc","LogLevel","path","error","path","pc","AsyncEventEmitter","PromiseManager","LogLevel","version","path","process","pc"],"sources":["../src/utils/formatMsWithColor.ts","../src/utils/ansiColors.ts","../src/utils/getIntro.ts","../src/utils/randomColor.ts","../src/utils/getSummary.ts","../src/utils/Writables.ts","../src/loggers/clackLogger.ts","../src/loggers/envDetection.ts","../src/loggers/fileSystemLogger.ts","../src/loggers/githubActionsLogger.ts","../src/loggers/plainLogger.ts","../src/loggers/utils.ts","../src/utils/detectFormatter.ts","../src/utils/detectLinter.ts","../src/utils/executeHooks.ts","../src/utils/formatters.ts","../src/runners/generate.ts","../src/utils/getPlugins.ts","../src/utils/getConfigs.ts","../src/utils/getCosmiConfig.ts","../src/utils/watcher.ts","../src/commands/generate.ts"],"sourcesContent":["import { formatMs } from '@kubb/core/utils'\nimport pc from 'picocolors'\n\n/**\n * Formats milliseconds with color based on duration thresholds:\n * - Green: <= 500ms\n * - Yellow: > 500ms and <= 1000ms\n * - Red: > 1000ms\n */\nexport function formatMsWithColor(ms: number): string {\n  const formatted = formatMs(ms)\n\n  if (ms <= 500) {\n    return pc.green(formatted)\n  }\n\n  if (ms <= 1000) {\n    return pc.yellow(formatted)\n  }\n\n  return pc.red(formatted)\n}\n","/**\n * ANSI True Color (24-bit) utilities for terminal output\n * Supports hex color codes without external dependencies like chalk\n */\n\n/**\n * Convert hex color to ANSI 24-bit true color escape sequence\n * @param color - Hex color code (with or without #), e.g., '#FF5500' or 'FF5500'\n * @returns Function that wraps text with the color\n */\nexport function hex(color: string): (text: string) => string {\n  const cleanHex = color.replace('#', '')\n  const r = Number.parseInt(cleanHex.slice(0, 2), 16)\n  const g = Number.parseInt(cleanHex.slice(2, 4), 16)\n  const b = Number.parseInt(cleanHex.slice(4, 6), 16)\n\n  // Default to white (255) if parsing fails (NaN)\n  const safeR = Number.isNaN(r) ? 255 : r\n  const safeG = Number.isNaN(g) ? 255 : g\n  const safeB = Number.isNaN(b) ? 255 : b\n\n  return (text: string) => `\\x1b[38;2;${safeR};${safeG};${safeB}m${text}\\x1b[0m`\n}\n","import { default as gradientString } from 'gradient-string'\nimport pc from 'picocolors'\nimport { hex } from './ansiColors.ts'\n\n// Custom Color Palette for \"Wooden\" Depth\nconst colors = {\n  lid: hex('#F55A17'), // Dark Wood\n  woodTop: hex('#F5A217'), // Bright Orange (Light source)\n  woodMid: hex('#F58517'), // Main Orange\n  woodBase: hex('#B45309'), // Shadow Orange\n  eye: hex('#FFFFFF'), // Deep Slate\n  highlight: hex('#adadc6'), // Eye shine\n  blush: hex('#FDA4AF'), // Soft Rose\n}\n\n/**\n * Generates the Kubb mascot face welcome message\n * @param version - The version string to display\n * @returns Formatted mascot face string\n */\nexport function getIntro({ title, description, version, areEyesOpen }: { title: string; description: string; version: string; areEyesOpen: boolean }): string {\n  // Use gradient-string for the KUBB version text\n  const kubbVersion = gradientString(['#F58517', '#F5A217', '#F55A17'])(`KUBB v${version}`)\n\n  const eyeTop = areEyesOpen ? colors.eye('â–ˆâ–€â–ˆ') : colors.eye('â”€â”€â”€')\n  const eyeBottom = areEyesOpen ? colors.eye('â–€â–€â–€') : colors.eye('â”€â”€â”€')\n\n  return `\n   ${colors.lid('â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„â–„')}\n  ${colors.woodTop('â–ˆ  ')}${colors.highlight('â–„â–„')}${colors.woodTop('     ')}${colors.highlight('â–„â–„')}${colors.woodTop('  â–ˆ')}  ${kubbVersion}\n  ${colors.woodMid('â–ˆ ')}${eyeTop}${colors.woodMid('     ')}${eyeTop}${colors.woodMid(' â–ˆ')}  ${pc.gray(title)}\n  ${colors.woodMid('â–ˆ ')}${eyeBottom}${colors.woodMid('  ')}${colors.blush('â—¡')}${colors.woodMid('  ')}${eyeBottom}${colors.woodMid(' â–ˆ')}  ${pc.yellow('âžœ')} ${pc.white(description)}\n   ${colors.woodBase('â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€â–€')}\n`\n}\n","import pc from 'picocolors'\nimport seedrandom from 'seedrandom'\n\nexport function randomColor(text?: string): 'black' | 'red' | 'green' | 'yellow' | 'blue' | 'magenta' | 'cyan' | 'white' | 'gray' {\n  if (!text) {\n    return 'white'\n  }\n\n  const defaultColors = ['black', 'red', 'green', 'yellow', 'blue', 'red', 'green', 'magenta', 'cyan', 'gray'] as const\n\n  const random = seedrandom(text)\n  return defaultColors.at(Math.floor(random() * defaultColors.length)) || 'white'\n}\n\nexport function randomCliColor(text?: string): string {\n  if (!text) {\n    return ''\n  }\n\n  const color = randomColor(text)\n\n  const fn = pc[color]\n  return fn ? fn(text) : text\n}\n","import path from 'node:path'\nimport type { Config, Plugin } from '@kubb/core'\nimport { formatHrtime } from '@kubb/core/utils'\nimport pc from 'picocolors'\nimport { randomCliColor } from './randomColor.ts'\n\ntype SummaryProps = {\n  failedPlugins: Set<{ plugin: Plugin; error: Error }>\n  status: 'success' | 'failed'\n  hrStart: [number, number]\n  filesCreated: number\n  config: Config\n  pluginTimings?: Map<string, number>\n}\n\nexport function getSummary({ failedPlugins, filesCreated, status, hrStart, config, pluginTimings }: SummaryProps): string[] {\n  const duration = formatHrtime(hrStart)\n\n  const pluginsCount = config.plugins?.length || 0\n  const successCount = pluginsCount - failedPlugins.size\n\n  const meta = {\n    plugins:\n      status === 'success'\n        ? `${pc.green(`${successCount} successful`)}, ${pluginsCount} total`\n        : `${pc.green(`${successCount} successful`)}, ${pc.red(`${failedPlugins.size} failed`)}, ${pluginsCount} total`,\n    pluginsFailed: status === 'failed' ? [...failedPlugins]?.map(({ plugin }) => randomCliColor(plugin.name))?.join(', ') : undefined,\n    filesCreated: filesCreated,\n    time: pc.green(duration),\n    output: path.isAbsolute(config.root) ? path.resolve(config.root, config.output.path) : config.root,\n  } as const\n\n  const labels = {\n    plugins: 'Plugins:',\n    failed: 'Failed:',\n    generated: 'Generated:',\n    pluginTimings: 'Plugin Timings:',\n    output: 'Output:',\n  }\n  const maxLength = Math.max(0, ...[...Object.values(labels), ...(pluginTimings ? Array.from(pluginTimings.keys()) : [])].map((s) => s.length))\n\n  const summaryLines: string[] = []\n  summaryLines.push(`${labels.plugins.padEnd(maxLength + 2)} ${meta.plugins}`)\n\n  if (meta.pluginsFailed) {\n    summaryLines.push(`${labels.failed.padEnd(maxLength + 2)} ${meta.pluginsFailed}`)\n  }\n\n  summaryLines.push(`${labels.generated.padEnd(maxLength + 2)} ${meta.filesCreated} files in ${meta.time}`)\n\n  if (pluginTimings && pluginTimings.size > 0) {\n    const TIME_SCALE_DIVISOR = 100\n    const MAX_BAR_LENGTH = 10\n\n    const sortedTimings = Array.from(pluginTimings.entries()).sort((a, b) => b[1] - a[1])\n\n    if (sortedTimings.length > 0) {\n      summaryLines.push(`${labels.pluginTimings}`)\n\n      sortedTimings.forEach(([name, time]) => {\n        const timeStr = time >= 1000 ? `${(time / 1000).toFixed(2)}s` : `${Math.round(time)}ms`\n        const barLength = Math.min(Math.ceil(time / TIME_SCALE_DIVISOR), MAX_BAR_LENGTH)\n        const bar = pc.dim('â–ˆ'.repeat(barLength))\n\n        summaryLines.push(`${pc.dim('â€¢')} ${name.padEnd(maxLength + 1)}${bar} ${timeStr}`)\n      })\n    }\n  }\n\n  summaryLines.push(`${labels.output.padEnd(maxLength + 2)} ${meta.output}`)\n\n  return summaryLines\n}\n","import type { WritableOptions } from 'node:stream'\nimport { Writable } from 'node:stream'\nimport type * as clack from '@clack/prompts'\nimport pc from 'picocolors'\n\nexport class ClackWritable extends Writable {\n  taskLog: ReturnType<typeof clack.taskLog>\n  constructor(taskLog: ReturnType<typeof clack.taskLog>, opts?: WritableOptions) {\n    super(opts)\n\n    this.taskLog = taskLog\n  }\n  _write(chunk: any, _encoding: BufferEncoding, callback: (error?: Error | null) => void): void {\n    this.taskLog.message(`${pc.dim(chunk?.toString())}`)\n    callback()\n  }\n}\n","import { relative } from 'node:path'\nimport process from 'node:process'\nimport * as clack from '@clack/prompts'\nimport { defineLogger, LogLevel } from '@kubb/core'\nimport { formatHrtime, formatMs } from '@kubb/core/utils'\nimport { execa } from 'execa'\nimport pc from 'picocolors'\nimport { formatMsWithColor } from '../utils/formatMsWithColor.ts'\nimport { getIntro } from '../utils/getIntro.ts'\nimport { getSummary } from '../utils/getSummary.ts'\nimport { ClackWritable } from '../utils/Writables.ts'\n\n/**\n * Clack adapter for local TTY environments\n * Provides a beautiful CLI UI with flat structure inspired by Claude's CLI patterns\n */\nexport const clackLogger = defineLogger({\n  name: 'clack',\n  install(context, options) {\n    const logLevel = options?.logLevel || LogLevel.info\n    const state = {\n      totalPlugins: 0,\n      completedPlugins: 0,\n      failedPlugins: 0,\n      totalFiles: 0,\n      processedFiles: 0,\n      hrStart: process.hrtime(),\n      spinner: clack.spinner(),\n      isSpinning: false,\n      activeProgress: new Map<string, { interval?: NodeJS.Timeout; progressBar: clack.ProgressResult }>(),\n    }\n\n    function reset() {\n      for (const [_key, active] of state.activeProgress) {\n        if (active.interval) {\n          clearInterval(active.interval)\n        }\n        active.progressBar?.stop()\n      }\n\n      state.totalPlugins = 0\n      state.completedPlugins = 0\n      state.failedPlugins = 0\n      state.totalFiles = 0\n      state.processedFiles = 0\n      state.hrStart = process.hrtime()\n      state.spinner = clack.spinner()\n      state.isSpinning = false\n      state.activeProgress.clear()\n    }\n\n    function showProgressStep() {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const parts: string[] = []\n      const duration = formatHrtime(state.hrStart)\n\n      if (state.totalPlugins > 0) {\n        const pluginStr =\n          state.failedPlugins > 0\n            ? `Plugins ${pc.green(state.completedPlugins.toString())}/${state.totalPlugins} ${pc.red(`(${state.failedPlugins} failed)`)}`\n            : `Plugins ${pc.green(state.completedPlugins.toString())}/${state.totalPlugins}`\n        parts.push(pluginStr)\n      }\n\n      if (state.totalFiles > 0) {\n        parts.push(`Files ${pc.green(state.processedFiles.toString())}/${state.totalFiles}`)\n      }\n\n      if (parts.length > 0) {\n        parts.push(`${pc.green(duration)} elapsed`)\n        clack.log.step(getMessage(parts.join(pc.dim(' | '))))\n      }\n    }\n\n    function getMessage(message: string): string {\n      if (logLevel >= LogLevel.verbose) {\n        const timestamp = new Date().toLocaleTimeString('en-US', {\n          hour12: false,\n          hour: '2-digit',\n          minute: '2-digit',\n          second: '2-digit',\n        })\n\n        return [pc.dim(`[${timestamp}]`), message].join(' ')\n      }\n\n      return message\n    }\n\n    function startSpinner(text?: string) {\n      state.spinner.start(text)\n      state.isSpinning = true\n    }\n\n    function stopSpinner(text?: string) {\n      state.spinner.stop(text)\n      state.isSpinning = false\n    }\n\n    context.on('info', (message, info = '') => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage([pc.blue('â„¹'), message, pc.dim(info)].join(' '))\n\n      if (state.isSpinning) {\n        state.spinner.message(text)\n      } else {\n        clack.log.info(text)\n      }\n    })\n\n    context.on('success', (message, info = '') => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage([pc.blue('âœ“'), message, logLevel >= LogLevel.info ? pc.dim(info) : undefined].filter(Boolean).join(' '))\n\n      if (state.isSpinning) {\n        stopSpinner(text)\n      } else {\n        clack.log.success(text)\n      }\n    })\n\n    context.on('warn', (message, info) => {\n      if (logLevel < LogLevel.warn) {\n        return\n      }\n\n      const text = getMessage([pc.yellow('âš '), message, logLevel >= LogLevel.info ? pc.dim(info) : undefined].filter(Boolean).join(' '))\n\n      clack.log.warn(text)\n    })\n\n    context.on('error', (error) => {\n      const caused = error.cause as Error\n\n      const text = [pc.red('âœ—'), error.message].join(' ')\n\n      if (state.isSpinning) {\n        stopSpinner(getMessage(text))\n      } else {\n        clack.log.error(getMessage(text))\n      }\n\n      // Show stack trace in debug mode (first 3 frames)\n      if (logLevel >= LogLevel.debug && error.stack) {\n        const frames = error.stack.split('\\n').slice(1, 4)\n        for (const frame of frames) {\n          clack.log.message(getMessage(pc.dim(frame.trim())))\n        }\n\n        if (caused?.stack) {\n          clack.log.message(pc.dim(`â””â”€ caused by ${caused.message}`))\n\n          const frames = caused.stack.split('\\n').slice(1, 4)\n          for (const frame of frames) {\n            clack.log.message(getMessage(`    ${pc.dim(frame.trim())}`))\n          }\n        }\n      }\n    })\n\n    context.on('version:new', (version, latestVersion) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      clack.box(\n        `\\`v${version}\\` â†’ \\`v${latestVersion}\\`\nRun \\`npm install -g @kubb/cli\\` to update`,\n        'Update available for `Kubb`',\n        {\n          width: 'auto',\n          formatBorder: pc.yellow,\n          rounded: true,\n          withGuide: false,\n          contentAlign: 'center',\n          titleAlign: 'center',\n        },\n      )\n    })\n\n    context.on('lifecycle:start', async (version) => {\n      console.log(`\\n${getIntro({ title: 'The ultimate toolkit for working with APIs', description: 'Ready to start', version, areEyesOpen: true })}\\n`)\n\n      reset()\n    })\n\n    context.on('config:start', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Configuration started')\n\n      clack.intro(text)\n      startSpinner(getMessage('Configuration loading'))\n    })\n\n    context.on('config:end', (_configs) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Configuration completed')\n\n      clack.outro(text)\n    })\n\n    context.on('generation:start', (config) => {\n      // Initialize progress tracking\n      state.totalPlugins = config.plugins?.length || 0\n\n      const text = getMessage(['Generation started', config.name ? `for ${pc.dim(config.name)}` : undefined].filter(Boolean).join(' '))\n\n      clack.intro(text)\n      reset()\n    })\n\n    context.on('plugin:start', (plugin) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      stopSpinner()\n\n      const progressBar = clack.progress({\n        style: 'block',\n        max: 100,\n        size: 30,\n      })\n      const text = getMessage(`Generating ${pc.bold(plugin.name)}`)\n      progressBar.start(text)\n\n      const interval = setInterval(() => {\n        progressBar.advance()\n      }, 100)\n\n      state.activeProgress.set(plugin.name, { progressBar, interval })\n    })\n\n    context.on('plugin:end', (plugin, { duration, success }) => {\n      stopSpinner()\n\n      const active = state.activeProgress.get(plugin.name)\n\n      if (!active || logLevel === LogLevel.silent) {\n        return\n      }\n\n      clearInterval(active.interval)\n\n      if (success) {\n        state.completedPlugins++\n      } else {\n        state.failedPlugins++\n      }\n\n      const durationStr = formatMsWithColor(duration)\n      const text = getMessage(\n        success ? `${pc.bold(plugin.name)} completed in ${durationStr}` : `${pc.bold(plugin.name)} failed in ${pc.red(formatMs(duration))}`,\n      )\n\n      active.progressBar.stop(text)\n      state.activeProgress.delete(plugin.name)\n\n      // Show progress step after each plugin\n      showProgressStep()\n    })\n\n    context.on('files:processing:start', (files) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      stopSpinner()\n\n      state.totalFiles = files.length\n      state.processedFiles = 0\n\n      const text = `Writing ${files.length} files`\n      const progressBar = clack.progress({\n        style: 'block',\n        max: files.length,\n        size: 30,\n      })\n\n      context.emit('info', text)\n      progressBar.start(getMessage(text))\n      state.activeProgress.set('files', { progressBar })\n    })\n\n    context.on('file:processing:update', ({ file, config }) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      stopSpinner()\n\n      state.processedFiles++\n\n      const text = `Writing ${relative(config.root, file.path)}`\n      const active = state.activeProgress.get('files')\n\n      if (!active) {\n        return\n      }\n\n      active.progressBar.advance(undefined, text)\n    })\n    context.on('files:processing:end', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      stopSpinner()\n\n      const text = getMessage('Files written successfully')\n      const active = state.activeProgress.get('files')\n\n      if (!active) {\n        return\n      }\n\n      active.progressBar.stop(text)\n      state.activeProgress.delete('files')\n\n      // Show final progress step after files are written\n      showProgressStep()\n    })\n\n    context.on('generation:end', (config) => {\n      const text = getMessage(config.name ? `Generation completed for ${pc.dim(config.name)}` : 'Generation completed')\n\n      clack.outro(text)\n    })\n\n    context.on('format:start', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Format started')\n\n      clack.intro(text)\n    })\n\n    context.on('format:end', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Format completed')\n\n      clack.outro(text)\n    })\n\n    context.on('lint:start', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Lint started')\n\n      clack.intro(text)\n    })\n\n    context.on('lint:end', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Lint completed')\n\n      clack.outro(text)\n    })\n\n    context.on('hook:start', async ({ id, command, args }) => {\n      const commandWithArgs = args?.length ? `${command} ${args.join(' ')}` : command\n      const text = getMessage(`Hook ${pc.dim(commandWithArgs)} started`)\n\n      // Skip hook execution if no id is provided (e.g., during benchmarks or tests)\n      if (!id) {\n        return\n      }\n\n      if (logLevel <= LogLevel.silent) {\n        try {\n          const result = await execa(command, args, {\n            detached: true,\n            stripFinalNewline: true,\n          })\n\n          await context.emit('debug', {\n            date: new Date(),\n            logs: [result.stdout],\n          })\n\n          await context.emit('hook:end', {\n            command,\n            args,\n            id,\n            success: true,\n            error: null,\n          })\n        } catch (err) {\n          const error = new Error('Hook execute failed')\n          error.cause = err\n\n          await context.emit('debug', {\n            date: new Date(),\n            logs: [(err as any).stdout],\n          })\n\n          await context.emit('hook:end', {\n            command,\n            args,\n            id,\n            success: false,\n            error,\n          })\n          await context.emit('error', error)\n        }\n\n        return\n      }\n\n      clack.intro(text)\n\n      const logger = clack.taskLog({\n        title: getMessage(['Executing hook', logLevel >= LogLevel.info ? pc.dim(commandWithArgs) : undefined].filter(Boolean).join(' ')),\n      })\n\n      const writable = new ClackWritable(logger)\n\n      try {\n        const result = await execa(command, args, {\n          detached: true,\n          stdout: ['pipe', writable],\n          stripFinalNewline: true,\n        })\n\n        await context.emit('debug', {\n          date: new Date(),\n          logs: [result.stdout],\n        })\n\n        await context.emit('hook:end', { command, args, id, success: true, error: null })\n      } catch (err) {\n        const error = new Error('Hook execute failed')\n        error.cause = err\n\n        await context.emit('debug', {\n          date: new Date(),\n          logs: [(err as any).stdout],\n        })\n\n        await context.emit('hook:end', { command, args, id, success: true, error })\n        await context.emit('error', error)\n      }\n    })\n\n    context.on('hook:end', ({ command, args }) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const commandWithArgs = args?.length ? `${command} ${args.join(' ')}` : command\n      const text = getMessage(`Hook ${pc.dim(commandWithArgs)} successfully executed`)\n\n      clack.outro(text)\n    })\n\n    context.on('generation:summary', (config, { pluginTimings, failedPlugins, filesCreated, status, hrStart }) => {\n      const summary = getSummary({\n        failedPlugins,\n        filesCreated,\n        config,\n        status,\n        hrStart,\n        pluginTimings: logLevel >= LogLevel.verbose ? pluginTimings : undefined,\n      })\n      const title = config.name || ''\n\n      summary.unshift('\\n')\n      summary.push('\\n')\n\n      if (status === 'success') {\n        clack.box(summary.join('\\n'), getMessage(title), {\n          width: 'auto',\n          formatBorder: pc.green,\n          rounded: true,\n          withGuide: false,\n          contentAlign: 'left',\n          titleAlign: 'center',\n        })\n\n        return\n      }\n\n      clack.box(summary.join('\\n'), getMessage(title), {\n        width: 'auto',\n        formatBorder: pc.red,\n        rounded: true,\n        withGuide: false,\n        contentAlign: 'left',\n        titleAlign: 'center',\n      })\n    })\n\n    context.on('lifecycle:end', () => {\n      reset()\n    })\n  },\n})\n","/**\n * Check if running in GitHub Actions environment\n */\nexport function isGitHubActions(): boolean {\n  return !!process.env.GITHUB_ACTIONS\n}\n\n/**\n * Check if running in any CI environment\n */\nexport function isCIEnvironment(): boolean {\n  return !!(\n    process.env.CI ||\n    process.env.GITHUB_ACTIONS ||\n    process.env.GITLAB_CI ||\n    process.env.CIRCLECI ||\n    process.env.TRAVIS ||\n    process.env.JENKINS_URL ||\n    process.env.BUILDKITE\n  )\n}\n\n/**\n * Check if TTY is available for interactive output\n */\nexport function canUseTTY(): boolean {\n  return !!process.stdout.isTTY && !isCIEnvironment()\n}\n","import { relative, resolve } from 'node:path'\nimport { defineLogger } from '@kubb/core'\nimport { write } from '@kubb/core/fs'\nimport { formatMs } from '@kubb/core/utils'\n\ntype CachedEvent = {\n  date: Date\n  logs: string[]\n  fileName?: string\n}\n\n/**\n * FileSystem logger for debug log persistence\n * Captures debug and verbose events and writes them to files in .kubb directory\n *\n * Note: Logs are written on lifecycle:end or process exit. If the process crashes\n * before these events, some cached logs may be lost.\n */\nexport const fileSystemLogger = defineLogger({\n  name: 'filesystem',\n  install(context) {\n    const state = {\n      cachedLogs: new Set<CachedEvent>(),\n      startDate: Date.now(),\n    }\n\n    function reset() {\n      state.cachedLogs = new Set<CachedEvent>()\n      state.startDate = Date.now()\n    }\n\n    async function writeLogs(name?: string) {\n      if (state.cachedLogs.size === 0) {\n        return []\n      }\n\n      const files: Record<string, string[]> = {}\n\n      for (const log of state.cachedLogs) {\n        const baseName = log.fileName || `${['kubb', name, state.startDate].filter(Boolean).join('-')}.log`\n        const pathName = resolve(process.cwd(), '.kubb', baseName)\n\n        if (!files[pathName]) {\n          files[pathName] = []\n        }\n\n        if (log.logs.length > 0) {\n          const timestamp = log.date.toLocaleString()\n          files[pathName].push(`[${timestamp}]\\n${log.logs.join('\\n')}`)\n        }\n      }\n\n      await Promise.all(\n        Object.entries(files).map(async ([fileName, logs]) => {\n          return write(fileName, logs.join('\\n\\n'))\n        }),\n      )\n\n      return Object.keys(files)\n    }\n\n    context.on('info', (message, info) => {\n      state.cachedLogs.add({\n        date: new Date(),\n        logs: [`â„¹ ${message} ${info}`],\n        fileName: undefined,\n      })\n    })\n\n    context.on('success', (message, info) => {\n      state.cachedLogs.add({\n        date: new Date(),\n        logs: [`âœ“ ${message} ${info}`],\n        fileName: undefined,\n      })\n    })\n\n    context.on('warn', (message, info) => {\n      state.cachedLogs.add({\n        date: new Date(),\n        logs: [`âš  ${message} ${info}`],\n        fileName: undefined,\n      })\n    })\n\n    context.on('error', (error) => {\n      state.cachedLogs.add({\n        date: new Date(),\n        logs: [`âœ— ${error.message}`, error.stack || 'unknown stack'],\n        fileName: undefined,\n      })\n    })\n\n    context.on('debug', (message) => {\n      state.cachedLogs.add({\n        date: new Date(),\n        logs: message.logs,\n        fileName: undefined,\n      })\n    })\n\n    context.on('plugin:start', (plugin) => {\n      state.cachedLogs.add({\n        date: new Date(),\n        logs: [`Generating ${plugin.name}`],\n        fileName: undefined,\n      })\n    })\n\n    context.on('plugin:end', (plugin, { duration, success }) => {\n      const durationStr = formatMs(duration)\n\n      state.cachedLogs.add({\n        date: new Date(),\n        logs: [success ? `${plugin.name} completed in ${durationStr}` : `${plugin.name} failed in ${durationStr}`],\n        fileName: undefined,\n      })\n    })\n\n    context.on('files:processing:start', (files) => {\n      state.cachedLogs.add({\n        date: new Date(),\n        logs: [`Start ${files.length} writing:`, ...files.map((file) => file.path)],\n        fileName: undefined,\n      })\n    })\n\n    context.on('generation:end', async (config) => {\n      const writtenFilePaths = await writeLogs(config.name)\n      if (writtenFilePaths.length > 0) {\n        const files = writtenFilePaths.map((f) => relative(process.cwd(), f))\n        await context.emit('info', 'Debug files written to:', files.join(', '))\n      }\n      reset()\n    })\n\n    context.on('lifecycle:end', async () => {\n      // lifecycle:end handler can be used for cleanup if needed in the future\n    })\n\n    // Fallback: Write logs on process exit to handle crashes\n    const exitHandler = () => {\n      // Synchronous write on exit - best effort\n      if (state.cachedLogs.size > 0) {\n        writeLogs().catch(() => {\n          // Ignore errors on exit\n        })\n      }\n    }\n\n    process.once('exit', exitHandler)\n    process.once('SIGINT', exitHandler)\n    process.once('SIGTERM', exitHandler)\n  },\n})\n","import { type Config, defineLogger, LogLevel } from '@kubb/core'\nimport { formatHrtime, formatMs } from '@kubb/core/utils'\nimport { execa } from 'execa'\nimport pc from 'picocolors'\nimport { formatMsWithColor } from '../utils/formatMsWithColor.ts'\n\n/**\n * GitHub Actions adapter for CI environments\n * Uses Github group annotations for collapsible sections\n */\nexport const githubActionsLogger = defineLogger({\n  name: 'github-actions',\n  install(context, options) {\n    const logLevel = options?.logLevel || LogLevel.info\n    const state = {\n      totalPlugins: 0,\n      completedPlugins: 0,\n      failedPlugins: 0,\n      totalFiles: 0,\n      processedFiles: 0,\n      hrStart: process.hrtime(),\n      currentConfigs: [] as Array<Config>,\n    }\n\n    function reset() {\n      state.totalPlugins = 0\n      state.completedPlugins = 0\n      state.failedPlugins = 0\n      state.totalFiles = 0\n      state.processedFiles = 0\n      state.hrStart = process.hrtime()\n    }\n\n    function showProgressStep() {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const parts: string[] = []\n      const duration = formatHrtime(state.hrStart)\n\n      if (state.totalPlugins > 0) {\n        const pluginStr =\n          state.failedPlugins > 0\n            ? `Plugins ${pc.green(state.completedPlugins.toString())}/${state.totalPlugins} ${pc.red(`(${state.failedPlugins} failed)`)}`\n            : `Plugins ${pc.green(state.completedPlugins.toString())}/${state.totalPlugins}`\n        parts.push(pluginStr)\n      }\n\n      if (state.totalFiles > 0) {\n        parts.push(`Files ${pc.green(state.processedFiles.toString())}/${state.totalFiles}`)\n      }\n\n      if (parts.length > 0) {\n        parts.push(`${pc.green(duration)} elapsed`)\n        console.log(getMessage(parts.join(pc.dim(' | '))))\n      }\n    }\n\n    function getMessage(message: string): string {\n      if (logLevel >= LogLevel.verbose) {\n        const timestamp = new Date().toLocaleTimeString('en-US', {\n          hour12: false,\n          hour: '2-digit',\n          minute: '2-digit',\n          second: '2-digit',\n        })\n\n        return [pc.dim(`[${timestamp}]`), message].join(' ')\n      }\n\n      return message\n    }\n\n    function openGroup(name: string) {\n      console.log(`::group::${name}`)\n    }\n\n    function closeGroup(_name: string) {\n      console.log('::endgroup::')\n    }\n\n    context.on('info', (message, info = '') => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage([pc.blue('â„¹'), message, pc.dim(info)].join(' '))\n\n      console.log(text)\n    })\n\n    context.on('success', (message, info = '') => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage([pc.blue('âœ“'), message, logLevel >= LogLevel.info ? pc.dim(info) : undefined].filter(Boolean).join(' '))\n\n      console.log(text)\n    })\n\n    context.on('warn', (message, info = '') => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage([pc.yellow('âš '), message, logLevel >= LogLevel.info ? pc.dim(info) : undefined].filter(Boolean).join(' '))\n\n      console.warn(`::warning::${text}`)\n    })\n\n    context.on('error', (error) => {\n      const caused = error.cause as Error\n\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n      const message = error.message || String(error)\n      console.error(`::error::${message}`)\n\n      // Show stack trace in debug mode (first 3 frames)\n      if (logLevel >= LogLevel.debug && error.stack) {\n        const frames = error.stack.split('\\n').slice(1, 4)\n        for (const frame of frames) {\n          console.log(getMessage(pc.dim(frame.trim())))\n        }\n\n        if (caused?.stack) {\n          console.log(pc.dim(`â””â”€ caused by ${caused.message}`))\n\n          const frames = caused.stack.split('\\n').slice(1, 4)\n          for (const frame of frames) {\n            console.log(getMessage(`    ${pc.dim(frame.trim())}`))\n          }\n        }\n      }\n    })\n\n    context.on('lifecycle:start', (version) => {\n      console.log(pc.yellow(`Kubb ${version} ðŸ§©`))\n      reset()\n    })\n\n    context.on('config:start', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Configuration started')\n\n      openGroup('Configuration')\n\n      console.log(text)\n    })\n\n    context.on('config:end', (configs) => {\n      state.currentConfigs = configs\n\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Configuration completed')\n\n      console.log(text)\n\n      closeGroup('Configuration')\n    })\n\n    context.on('generation:start', (config) => {\n      // Initialize progress tracking\n      state.totalPlugins = config.plugins?.length || 0\n\n      const text = config.name ? `Generation for ${pc.bold(config.name)}` : 'Generation'\n\n      if (state.currentConfigs.length > 1) {\n        openGroup(text)\n      }\n\n      if (state.currentConfigs.length === 1) {\n        console.log(getMessage(text))\n      }\n\n      reset()\n    })\n\n    context.on('plugin:start', (plugin) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n      const text = getMessage(`Generating ${pc.bold(plugin.name)}`)\n\n      if (state.currentConfigs.length === 1) {\n        openGroup(`Plugin: ${plugin.name}`)\n      }\n\n      console.log(text)\n    })\n\n    context.on('plugin:end', (plugin, { duration, success }) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      if (success) {\n        state.completedPlugins++\n      } else {\n        state.failedPlugins++\n      }\n\n      const durationStr = formatMsWithColor(duration)\n      const text = getMessage(\n        success ? `${pc.bold(plugin.name)} completed in ${durationStr}` : `${pc.bold(plugin.name)} failed in ${pc.red(formatMs(duration))}`,\n      )\n\n      console.log(text)\n      if (state.currentConfigs.length > 1) {\n        console.log(' ')\n      }\n\n      if (state.currentConfigs.length === 1) {\n        closeGroup(`Plugin: ${plugin.name}`)\n      }\n\n      // Show progress step after each plugin\n      showProgressStep()\n    })\n\n    context.on('files:processing:start', (files) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      state.totalFiles = files.length\n      state.processedFiles = 0\n\n      if (state.currentConfigs.length === 1) {\n        openGroup('File Generation')\n      }\n      const text = getMessage(`Writing ${files.length} files`)\n\n      console.log(text)\n    })\n\n    context.on('files:processing:end', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n      const text = getMessage('Files written successfully')\n\n      console.log(text)\n\n      if (state.currentConfigs.length === 1) {\n        closeGroup('File Generation')\n      }\n    })\n\n    context.on('file:processing:update', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      state.processedFiles++\n    })\n\n    context.on('files:processing:end', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      // Show final progress step after files are written\n      showProgressStep()\n    })\n\n    context.on('generation:end', (config) => {\n      const text = getMessage(config.name ? `${pc.blue('âœ“')} Generation completed for ${pc.dim(config.name)}` : `${pc.blue('âœ“')} Generation completed`)\n\n      console.log(text)\n    })\n\n    context.on('format:start', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Format started')\n\n      if (state.currentConfigs.length === 1) {\n        openGroup('Formatting')\n      }\n\n      console.log(text)\n    })\n\n    context.on('format:end', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Format completed')\n\n      console.log(text)\n\n      if (state.currentConfigs.length === 1) {\n        closeGroup('Formatting')\n      }\n    })\n\n    context.on('lint:start', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Lint started')\n\n      if (state.currentConfigs.length === 1) {\n        openGroup('Linting')\n      }\n\n      console.log(text)\n    })\n\n    context.on('lint:end', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Lint completed')\n\n      console.log(text)\n\n      if (state.currentConfigs.length === 1) {\n        closeGroup('Linting')\n      }\n    })\n\n    context.on('hook:start', async ({ id, command, args }) => {\n      const commandWithArgs = args?.length ? `${command} ${args.join(' ')}` : command\n      const text = getMessage(`Hook ${pc.dim(commandWithArgs)} started`)\n\n      if (logLevel > LogLevel.silent) {\n        if (state.currentConfigs.length === 1) {\n          openGroup(`Hook ${commandWithArgs}`)\n        }\n\n        console.log(text)\n      }\n\n      // Skip hook execution if no id is provided (e.g., during benchmarks or tests)\n      if (!id) {\n        return\n      }\n\n      try {\n        const result = await execa(command, args, {\n          detached: true,\n          stripFinalNewline: true,\n        })\n\n        await context.emit('debug', {\n          date: new Date(),\n          logs: [result.stdout],\n        })\n\n        console.log(result.stdout)\n\n        await context.emit('hook:end', {\n          command,\n          args,\n          id,\n          success: true,\n          error: null,\n        })\n      } catch (err) {\n        const error = new Error('Hook execute failed')\n        error.cause = err\n\n        await context.emit('debug', {\n          date: new Date(),\n          logs: [(err as any).stdout],\n        })\n\n        await context.emit('hook:end', {\n          command,\n          args,\n          id,\n          success: false,\n          error,\n        })\n        await context.emit('error', error)\n      }\n    })\n\n    context.on('hook:end', ({ command, args }) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const commandWithArgs = args?.length ? `${command} ${args.join(' ')}` : command\n      const text = getMessage(`Hook ${pc.dim(commandWithArgs)} completed`)\n\n      console.log(text)\n\n      if (state.currentConfigs.length === 1) {\n        closeGroup(`Hook ${commandWithArgs}`)\n      }\n    })\n\n    context.on('generation:summary', (config, { status, hrStart, failedPlugins }) => {\n      const pluginsCount = config.plugins?.length || 0\n      const successCount = pluginsCount - failedPlugins.size\n      const duration = formatHrtime(hrStart)\n\n      if (state.currentConfigs.length > 1) {\n        console.log(' ')\n      }\n\n      console.log(\n        status === 'success'\n          ? `Kubb Summary: ${pc.blue('âœ“')} ${`${successCount} successful`}, ${pluginsCount} total, ${pc.green(duration)}`\n          : `Kubb Summary: ${pc.blue('âœ“')} ${`${successCount} successful`}, âœ— ${`${failedPlugins.size} failed`}, ${pluginsCount} total, ${pc.green(duration)}`,\n      )\n\n      if (state.currentConfigs.length > 1) {\n        closeGroup(config.name ? `Generation for ${pc.bold(config.name)}` : 'Generation')\n      }\n    })\n  },\n})\n","import { relative } from 'node:path'\nimport { defineLogger, LogLevel } from '@kubb/core'\nimport { formatMs } from '@kubb/core/utils'\nimport { execa } from 'execa'\nimport { getSummary } from '../utils/getSummary.ts'\n\n/**\n * Plain console adapter for non-TTY environments\n * Simple console.log output with indentation\n */\nexport const plainLogger = defineLogger({\n  name: 'plain',\n  install(context, options) {\n    const logLevel = options?.logLevel || 3\n\n    function getMessage(message: string): string {\n      if (logLevel >= LogLevel.verbose) {\n        const timestamp = new Date().toLocaleTimeString('en-US', {\n          hour12: false,\n          hour: '2-digit',\n          minute: '2-digit',\n          second: '2-digit',\n        })\n\n        return [`[${timestamp}]`, message].join(' ')\n      }\n\n      return message\n    }\n\n    context.on('info', (message, info) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage(['â„¹', message, info].join(' '))\n\n      console.log(text)\n    })\n\n    context.on('success', (message, info = '') => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage(['âœ“', message, logLevel >= LogLevel.info ? info : undefined].filter(Boolean).join(' '))\n\n      console.log(text)\n    })\n\n    context.on('warn', (message, info) => {\n      if (logLevel < LogLevel.warn) {\n        return\n      }\n\n      const text = getMessage(['âš ', message, logLevel >= LogLevel.info ? info : undefined].filter(Boolean).join(' '))\n\n      console.log(text)\n    })\n\n    context.on('error', (error) => {\n      const caused = error.cause as Error\n\n      const text = getMessage(['âœ—', error.message].join(' '))\n\n      console.log(text)\n\n      // Show stack trace in debug mode (first 3 frames)\n      if (logLevel >= LogLevel.debug && error.stack) {\n        const frames = error.stack.split('\\n').slice(1, 4)\n        for (const frame of frames) {\n          console.log(getMessage(frame.trim()))\n        }\n\n        if (caused?.stack) {\n          console.log(`â””â”€ caused by ${caused.message}`)\n\n          const frames = caused.stack.split('\\n').slice(1, 4)\n          for (const frame of frames) {\n            console.log(getMessage(`    ${frame.trim()}`))\n          }\n        }\n      }\n    })\n\n    context.on('lifecycle:start', () => {\n      console.log('Kubb CLI ðŸ§©')\n    })\n\n    context.on('config:start', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Configuration started')\n\n      console.log(text)\n    })\n\n    context.on('config:end', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Configuration completed')\n\n      console.log(text)\n    })\n\n    context.on('generation:start', () => {\n      const text = getMessage('Configuration started')\n\n      console.log(text)\n    })\n\n    context.on('plugin:start', (plugin) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n      const text = getMessage(`Generating ${plugin.name}`)\n\n      console.log(text)\n    })\n\n    context.on('plugin:end', (plugin, { duration, success }) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const durationStr = formatMs(duration)\n      const text = getMessage(success ? `${plugin.name} completed in ${durationStr}` : `${plugin.name} failed in ${durationStr}`)\n\n      console.log(text)\n    })\n\n    context.on('files:processing:start', (files) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage(`Writing ${files.length} files`)\n\n      console.log(text)\n    })\n\n    context.on('file:processing:update', ({ file, config }) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage(`Writing ${relative(config.root, file.path)}`)\n\n      console.log(text)\n    })\n\n    context.on('files:processing:end', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Files written successfully')\n\n      console.log(text)\n    })\n\n    context.on('generation:end', (config) => {\n      const text = getMessage(config.name ? `Generation completed for ${config.name}` : 'Generation completed')\n\n      console.log(text)\n    })\n\n    context.on('format:start', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Format started')\n\n      console.log(text)\n    })\n\n    context.on('format:end', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Format completed')\n\n      console.log(text)\n    })\n\n    context.on('lint:start', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Lint started')\n\n      console.log(text)\n    })\n\n    context.on('lint:end', () => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const text = getMessage('Lint completed')\n\n      console.log(text)\n    })\n\n    context.on('hook:start', async ({ id, command, args }) => {\n      const commandWithArgs = args?.length ? `${command} ${args.join(' ')}` : command\n      const text = getMessage(`Hook ${commandWithArgs} started`)\n\n      if (logLevel > LogLevel.silent) {\n        console.log(text)\n      }\n\n      // Skip hook execution if no id is provided (e.g., during benchmarks or tests)\n      if (!id) {\n        return\n      }\n\n      try {\n        const result = await execa(command, args, {\n          detached: true,\n          stripFinalNewline: true,\n        })\n\n        await context.emit('debug', {\n          date: new Date(),\n          logs: [result.stdout],\n        })\n\n        console.log(result.stdout)\n\n        await context.emit('hook:end', {\n          command,\n          args,\n          id,\n          success: true,\n          error: null,\n        })\n      } catch (err) {\n        const error = new Error('Hook execute failed')\n        error.cause = err\n\n        await context.emit('debug', {\n          date: new Date(),\n          logs: [(err as any).stdout],\n        })\n\n        await context.emit('hook:end', {\n          command,\n          args,\n          id,\n          success: false,\n          error,\n        })\n        await context.emit('error', error)\n      }\n    })\n\n    context.on('hook:end', ({ command, args }) => {\n      if (logLevel <= LogLevel.silent) {\n        return\n      }\n\n      const commandWithArgs = args?.length ? `${command} ${args.join(' ')}` : command\n      const text = getMessage(`Hook ${commandWithArgs} completed`)\n\n      console.log(text)\n    })\n\n    context.on('generation:summary', (config, { pluginTimings, status, hrStart, failedPlugins, filesCreated }) => {\n      const summary = getSummary({\n        failedPlugins,\n        filesCreated,\n        config,\n        status,\n        hrStart,\n        pluginTimings: logLevel >= LogLevel.verbose ? pluginTimings : undefined,\n      })\n\n      console.log('---------------------------')\n      console.log(summary.join('\\n'))\n      console.log('---------------------------')\n    })\n  },\n})\n","import type { Logger, LoggerContext, LoggerOptions } from '@kubb/core'\nimport { LogLevel } from '@kubb/core'\nimport { clackLogger } from './clackLogger.ts'\nimport { canUseTTY, isGitHubActions } from './envDetection.ts'\nimport { fileSystemLogger } from './fileSystemLogger.ts'\nimport { githubActionsLogger } from './githubActionsLogger.ts'\nimport { plainLogger } from './plainLogger.ts'\nimport type { LoggerType } from './types.ts'\n\nexport function detectLogger(): LoggerType {\n  if (isGitHubActions()) {\n    return 'github-actions'\n  }\n  if (canUseTTY()) {\n    return 'clack'\n  }\n  return 'plain'\n}\n\nconst logMapper = {\n  clack: clackLogger,\n  plain: plainLogger,\n  'github-actions': githubActionsLogger,\n} as const satisfies Record<LoggerType, Logger>\n\nexport async function setupLogger(context: LoggerContext, { logLevel }: LoggerOptions): Promise<void> {\n  const type = detectLogger()\n\n  const logger = logMapper[type] as Logger\n\n  if (!logger) {\n    throw new Error(`Unknown adapter type: ${type}`)\n  }\n\n  // Install primary logger\n  const cleanup = await logger.install(context, { logLevel })\n\n  if (logLevel >= LogLevel.debug) {\n    await fileSystemLogger.install(context, { logLevel })\n  }\n\n  return cleanup\n}\n","import { execaCommand } from 'execa'\n\ntype Formatter = 'biome' | 'prettier' | 'oxfmt'\n\n/**\n * Check if a formatter command is available in the system.\n *\n * @param formatter - The formatter to check ('biome', 'prettier', or 'oxfmt')\n * @returns Promise that resolves to true if the formatter is available, false otherwise\n *\n * @remarks\n * This function checks availability by running `<formatter> --version` command.\n * All supported formatters (biome, prettier, oxfmt) implement the --version flag.\n */\nasync function isFormatterAvailable(formatter: Formatter): Promise<boolean> {\n  try {\n    // Try to get the version of the formatter to check if it's installed\n    await execaCommand(`${formatter} --version`, { stdio: 'ignore' })\n    return true\n  } catch {\n    return false\n  }\n}\n\n/**\n * Detect which formatter is available in the system.\n *\n * @returns Promise that resolves to the first available formatter or undefined if none are found\n *\n * @remarks\n * Checks in order of preference: biome, oxfmt, prettier.\n * Uses the `--version` flag to detect if each formatter command is available.\n * This is a reliable method as all supported formatters implement this flag.\n *\n * @example\n * ```typescript\n * const formatter = await detectFormatter()\n * if (formatter) {\n *   console.log(`Using ${formatter} for formatting`)\n * } else {\n *   console.log('No formatter found')\n * }\n * ```\n */\nexport async function detectFormatter(): Promise<Formatter | undefined> {\n  const formatters: Formatter[] = ['biome', 'oxfmt', 'prettier']\n\n  for (const formatter of formatters) {\n    if (await isFormatterAvailable(formatter)) {\n      return formatter\n    }\n  }\n\n  return undefined\n}\n","import { execaCommand } from 'execa'\n\ntype Linter = 'biome' | 'oxlint' | 'eslint'\n\n/**\n * Check if a linter command is available in the system.\n *\n * @param linter - The linter to check ('biome', 'oxlint', or 'eslint')\n * @returns Promise that resolves to true if the linter is available, false otherwise\n *\n * @remarks\n * This function checks availability by running `<linter> --version` command.\n * All supported linters (biome, oxlint, eslint) implement the --version flag.\n */\nasync function isLinterAvailable(linter: Linter): Promise<boolean> {\n  try {\n    // Try to get the version of the linter to check if it's installed\n    await execaCommand(`${linter} --version`, { stdio: 'ignore' })\n    return true\n  } catch {\n    return false\n  }\n}\n\n/**\n * Detect which linter is available in the system.\n *\n * @returns Promise that resolves to the first available linter or undefined if none are found\n *\n * @remarks\n * Checks in order of preference: biome, oxlint, eslint.\n * Uses the `--version` flag to detect if each linter command is available.\n * This is a reliable method as all supported linters implement this flag.\n *\n * @example\n * ```typescript\n * const linter = await detectLinter()\n * if (linter) {\n *   console.log(`Using ${linter} for linting`)\n * } else {\n *   console.log('No linter found')\n * }\n * ```\n */\nexport async function detectLinter(): Promise<Linter | undefined> {\n  const linters: Linter[] = ['biome', 'oxlint', 'eslint']\n\n  for (const linter of linters) {\n    if (await isLinterAvailable(linter)) {\n      return linter\n    }\n  }\n\n  return undefined\n}\n","import { createHash } from 'node:crypto'\nimport type { Config, KubbEvents } from '@kubb/core'\nimport type { AsyncEventEmitter } from '@kubb/core/utils'\n\nimport pc from 'picocolors'\nimport { parseArgsStringToArgv } from 'string-argv'\n\ntype ExecutingHooksProps = {\n  hooks: NonNullable<Config['hooks']>\n  events: AsyncEventEmitter<KubbEvents>\n}\n\nexport async function executeHooks({ hooks, events }: ExecutingHooksProps): Promise<void> {\n  const commands = Array.isArray(hooks.done) ? hooks.done : [hooks.done].filter(Boolean)\n\n  for (const command of commands) {\n    const [cmd, ...args] = [...parseArgsStringToArgv(command)]\n\n    if (!cmd) {\n      continue\n    }\n\n    const hookId = createHash('sha256').update(command).digest('hex')\n    await events.emit('hook:start', { id: hookId, command: cmd, args })\n\n    await events.onOnce('hook:end', async ({ success, error }) => {\n      if (!success) {\n        throw error\n      }\n\n      await events.emit('success', `${pc.dim(command)} successfully executed`)\n    })\n  }\n}\n","export const formatters = {\n  prettier: {\n    command: 'prettier',\n    args: (outputPath: string) => ['--ignore-unknown', '--write', outputPath],\n    errorMessage: 'Prettier not found',\n  },\n  biome: {\n    command: 'biome',\n    args: (outputPath: string) => ['format', '--write', outputPath],\n    errorMessage: 'Biome not found',\n  },\n  oxfmt: {\n    command: 'oxfmt',\n    args: (outputPath: string) => [outputPath],\n    errorMessage: 'Oxfmt not found',\n  },\n} as const\n","import { createHash } from 'node:crypto'\nimport path from 'node:path'\nimport process from 'node:process'\nimport { type Config, type KubbEvents, LogLevel, safeBuild, setup } from '@kubb/core'\nimport type { AsyncEventEmitter } from '@kubb/core/utils'\nimport pc from 'picocolors'\nimport { detectFormatter } from '../utils/detectFormatter.ts'\nimport { detectLinter } from '../utils/detectLinter.ts'\nimport { executeHooks } from '../utils/executeHooks.ts'\nimport { formatters } from '../utils/formatters.ts'\n\ntype GenerateProps = {\n  input?: string\n  config: Config\n  events: AsyncEventEmitter<KubbEvents>\n  logLevel: number\n}\n\nexport async function generate({ input, config: userConfig, events, logLevel }: GenerateProps): Promise<void> {\n  const inputPath = input ?? ('path' in userConfig.input ? userConfig.input.path : undefined)\n  const hrStart = process.hrtime()\n\n  const config: Config = {\n    ...userConfig,\n    root: userConfig.root || process.cwd(),\n    input: inputPath\n      ? {\n          ...userConfig.input,\n          path: inputPath,\n        }\n      : userConfig.input,\n    output: {\n      write: true,\n      barrelType: 'named',\n      extension: {\n        '.ts': '.ts',\n      },\n      format: 'prettier',\n      ...userConfig.output,\n    },\n  }\n\n  await events.emit('generation:start', config)\n\n  await events.emit('info', config.name ? `Setup generation ${pc.bold(config.name)}` : 'Setup generation', inputPath)\n\n  const { fabric, pluginManager } = await setup({\n    config,\n    events,\n  })\n\n  await events.emit('info', config.name ? `Build generation ${pc.bold(config.name)}` : 'Build generation', inputPath)\n\n  const { files, failedPlugins, pluginTimings, error } = await safeBuild(\n    {\n      config,\n      events,\n    },\n    { pluginManager, fabric, events },\n  )\n\n  await events.emit('info', 'Load summary')\n\n  // Handle build failures (either from failed plugins or general errors)\n\n  const hasFailures = failedPlugins.size > 0 || error\n  if (hasFailures) {\n    // Collect all errors from failed plugins and general error\n    const allErrors: Error[] = [\n      error,\n      ...Array.from(failedPlugins)\n        .filter((it) => it.error)\n        .map((it) => it.error),\n    ].filter(Boolean)\n\n    allErrors.forEach((err) => {\n      events.emit('error', err)\n    })\n\n    await events.emit('generation:end', config)\n\n    await events.emit('generation:summary', config, {\n      failedPlugins,\n      filesCreated: files.length,\n      status: failedPlugins.size > 0 || error ? 'failed' : 'success',\n      hrStart,\n      pluginTimings: logLevel >= LogLevel.verbose ? pluginTimings : undefined,\n    })\n\n    process.exit(1)\n  }\n\n  await events.emit('success', 'Generation successfully', inputPath)\n  await events.emit('generation:end', config)\n\n  // formatting\n  if (config.output.format) {\n    await events.emit('format:start')\n\n    let formatter = config.output.format\n    if (formatter === 'auto') {\n      const detectedFormatter = await detectFormatter()\n      if (!detectedFormatter) {\n        await events.emit('warn', 'No formatter found (biome, prettier, or oxfmt). Skipping formatting.')\n      } else {\n        formatter = detectedFormatter\n        await events.emit('info', `Auto-detected formatter: ${pc.dim(formatter)}`)\n      }\n    }\n\n    if (formatter && formatter !== 'auto' && formatter in formatters) {\n      const formatterConfig = formatters[formatter as keyof typeof formatters]\n      const outputPath = path.resolve(config.root, config.output.path)\n\n      try {\n        const hookId = createHash('sha256').update([config.name, formatter].filter(Boolean).join('-')).digest('hex')\n        await events.emit('hook:start', {\n          id: hookId,\n          command: formatterConfig.command,\n          args: formatterConfig.args(outputPath),\n        })\n\n        await events.onOnce('hook:end', async ({ success, error }) => {\n          if (!success) throw error\n\n          await events.emit(\n            'success',\n            [`Formatting with ${pc.dim(formatter)}`, logLevel >= LogLevel.info ? `on ${pc.dim(outputPath)}` : undefined, 'successfully']\n              .filter(Boolean)\n              .join(' '),\n          )\n        })\n      } catch (caughtError) {\n        const error = new Error(formatterConfig.errorMessage)\n        error.cause = caughtError\n        await events.emit('error', error)\n      }\n    }\n\n    await events.emit('format:end')\n  }\n\n  // linting\n  if (config.output.lint) {\n    await events.emit('lint:start')\n\n    // Detect linter if set to 'auto'\n    let linter = config.output.lint\n    if (linter === 'auto') {\n      const detectedLinter = await detectLinter()\n      if (!detectedLinter) {\n        await events.emit('warn', 'No linter found (biome, oxlint, or eslint). Skipping linting.')\n      } else {\n        linter = detectedLinter\n        await events.emit('info', `Auto-detected linter: ${pc.dim(linter)}`)\n      }\n    }\n\n    // Only proceed with linting if we have a valid linter\n    if (linter && linter !== 'auto') {\n      await events.emit(\n        'info',\n        [`Linting with ${pc.dim(linter as string)}`, logLevel >= LogLevel.info ? `on ${pc.dim(path.resolve(config.root, config.output.path))}` : undefined]\n          .filter(Boolean)\n          .join(' '),\n      )\n\n      if (linter === 'eslint') {\n        try {\n          const hookId = createHash('sha256').update([config.name, linter].filter(Boolean).join('-')).digest('hex')\n          await events.emit('hook:start', {\n            id: hookId,\n            command: 'eslint',\n            args: [path.resolve(config.root, config.output.path), '--fix'],\n          })\n\n          await events.onOnce('hook:end', async ({ success, error }) => {\n            if (!success) {\n              throw error\n            }\n\n            await events.emit(\n              'success',\n              [\n                `Linted with ${pc.dim(linter as string)}`,\n                logLevel >= LogLevel.info ? `on ${pc.dim(path.resolve(config.root, config.output.path))}` : undefined,\n                'successfully',\n              ]\n                .filter(Boolean)\n                .join(' '),\n            )\n          })\n        } catch (caughtError) {\n          const error = new Error('Eslint not found')\n          error.cause = caughtError\n          await events.emit('error', error)\n        }\n      }\n\n      if (linter === 'biome') {\n        try {\n          const hookId = createHash('sha256').update([config.name, linter].filter(Boolean).join('-')).digest('hex')\n          await events.emit('hook:start', {\n            id: hookId,\n            command: 'biome',\n            args: ['lint', '--fix', path.resolve(config.root, config.output.path)],\n          })\n\n          await events.onOnce('hook:end', async ({ success, error }) => {\n            if (!success) {\n              throw error\n            }\n\n            await events.emit(\n              'success',\n              [\n                `Linted with ${pc.dim(linter as string)}`,\n                logLevel >= LogLevel.info ? `on ${pc.dim(path.resolve(config.root, config.output.path))}` : undefined,\n                'successfully',\n              ]\n                .filter(Boolean)\n                .join(' '),\n            )\n          })\n        } catch (caughtError) {\n          const error = new Error('Biome not found')\n          error.cause = caughtError\n          await events.emit('error', error)\n        }\n      }\n\n      if (linter === 'oxlint') {\n        try {\n          const hookId = createHash('sha256').update([config.name, linter].filter(Boolean).join('-')).digest('hex')\n          await events.emit('hook:start', {\n            id: hookId,\n            command: 'oxlint',\n            args: ['--fix', path.resolve(config.root, config.output.path)],\n          })\n\n          await events.onOnce('hook:end', async ({ success, error }) => {\n            if (!success) {\n              throw error\n            }\n\n            await events.emit(\n              'success',\n              [\n                `Linted with ${pc.dim(linter as string)}`,\n                logLevel >= LogLevel.info ? `on ${pc.dim(path.resolve(config.root, config.output.path))}` : undefined,\n                'successfully',\n              ]\n                .filter(Boolean)\n                .join(' '),\n            )\n          })\n        } catch (caughtError) {\n          const error = new Error('Oxlint not found')\n          error.cause = caughtError\n\n          await events.emit('error', error)\n        }\n      }\n    }\n\n    await events.emit('lint:end')\n  }\n\n  if (config.hooks) {\n    await events.emit('hooks:start')\n    await executeHooks({ hooks: config.hooks, events })\n\n    await events.emit('hooks:end')\n  }\n\n  await events.emit('generation:summary', config, {\n    failedPlugins,\n    filesCreated: files.length,\n    status: failedPlugins.size > 0 || error ? 'failed' : 'success',\n    hrStart,\n    pluginTimings,\n  })\n}\n","import type { UserConfig } from '@kubb/core'\n\nfunction isJSONPlugins(plugins: UserConfig['plugins']) {\n  return !!(plugins as any)?.some((plugin: any) => {\n    return Array.isArray(plugin) && typeof plugin?.at(0) === 'string'\n  })\n}\n\nfunction isObjectPlugins(plugins: UserConfig['plugins']): plugins is any {\n  return plugins instanceof Object && !Array.isArray(plugins)\n}\n\nexport function getPlugins(plugins: UserConfig['plugins']): Promise<UserConfig['plugins']> {\n  if (isObjectPlugins(plugins)) {\n    throw new Error('Object plugins are not supported anymore, best to use http://kubb.dev/getting-started/configure#json')\n  }\n\n  if (isJSONPlugins(plugins)) {\n    throw new Error('JSON plugins are not supported anymore, best to use http://kubb.dev/getting-started/configure#json')\n  }\n\n  return Promise.resolve(plugins)\n}\n","import type { CLIOptions, Config, UserConfig } from '@kubb/core'\nimport { isPromise } from '@kubb/core/utils'\nimport type { Args } from '../commands/generate.ts'\nimport type { CosmiconfigResult } from './getCosmiConfig.ts'\nimport { getPlugins } from './getPlugins.ts'\n\n/**\n * Converting UserConfig to Config Array without a change in the object beside the JSON convert.\n */\nexport async function getConfigs(result: CosmiconfigResult, args: Args): Promise<Array<Config>> {\n  const config = result?.config\n  let kubbUserConfig = Promise.resolve(config) as Promise<UserConfig | Array<UserConfig>>\n\n  // for ts or js files\n  if (typeof config === 'function') {\n    const possiblePromise = config(args as CLIOptions)\n    if (isPromise(possiblePromise)) {\n      kubbUserConfig = possiblePromise\n    }\n    kubbUserConfig = Promise.resolve(possiblePromise)\n  }\n\n  let JSONConfig = await kubbUserConfig\n\n  if (!Array.isArray(JSONConfig)) {\n    JSONConfig = [JSONConfig]\n  }\n\n  const results: Array<Config> = []\n\n  for (const item of JSONConfig) {\n    const plugins = item.plugins ? await getPlugins(item.plugins) : undefined\n\n    results.push({\n      ...item,\n      plugins,\n    } as Config)\n  }\n\n  return results\n}\n","import type { defineConfig, UserConfig } from '@kubb/core'\nimport { cosmiconfig } from 'cosmiconfig'\nimport { createJiti } from 'jiti'\n\nexport type CosmiconfigResult = {\n  filepath: string\n  isEmpty?: boolean\n  config: ReturnType<typeof defineConfig> | UserConfig\n}\n\nconst tsLoader = async (configFile: string) => {\n  const jiti = createJiti(configFile, {\n    jsx: {\n      runtime: 'automatic',\n      importSource: '@kubb/react-fabric',\n    },\n    sourceMaps: true,\n    interopDefault: true,\n  })\n\n  const mod = await jiti.import(configFile, { default: true })\n\n  return mod\n}\n\nexport async function getCosmiConfig(moduleName: string, config?: string): Promise<CosmiconfigResult> {\n  let result: CosmiconfigResult\n  const searchPlaces = [\n    'package.json',\n    `.${moduleName}rc`,\n    `.${moduleName}rc.json`,\n    `.${moduleName}rc.yaml`,\n    `.${moduleName}rc.yml`,\n\n    `.${moduleName}rc.ts`,\n    `.${moduleName}rc.js`,\n    `.${moduleName}rc.mjs`,\n    `.${moduleName}rc.cjs`,\n\n    `${moduleName}.config.ts`,\n    `${moduleName}.config.js`,\n    `${moduleName}.config.mjs`,\n    `${moduleName}.config.cjs`,\n  ]\n  const explorer = cosmiconfig(moduleName, {\n    cache: false,\n    searchPlaces: [\n      ...searchPlaces.map((searchPlace) => {\n        return `.config/${searchPlace}`\n      }),\n      ...searchPlaces.map((searchPlace) => {\n        return `configs/${searchPlace}`\n      }),\n      ...searchPlaces,\n    ],\n    loaders: {\n      '.ts': tsLoader,\n    },\n  })\n\n  try {\n    result = config ? ((await explorer.load(config)) as CosmiconfigResult) : ((await explorer.search()) as CosmiconfigResult)\n  } catch (error) {\n    throw new Error('Config failed loading', { cause: error })\n  }\n\n  if (result?.isEmpty || !result || !result.config) {\n    throw new Error('Config not defined, create a kubb.config.js or pass through your config with the option --config')\n  }\n\n  return result as CosmiconfigResult\n}\n","import pc from 'picocolors'\n\nexport async function startWatcher(path: string[], cb: (path: string[]) => Promise<void>): Promise<void> {\n  const { watch } = await import('chokidar')\n\n  const ignored = '**/{.git,node_modules}/**'\n\n  const watcher = watch(path, {\n    ignorePermissionErrors: true,\n    ignored,\n  })\n  watcher.on('all', (type, file) => {\n    console.log(pc.yellow(pc.bold(`Change detected: ${type} ${file}`)))\n\n    try {\n      cb(path)\n    } catch (_e) {\n      console.log(pc.red('Watcher failed'))\n    }\n  })\n}\n","import path from 'node:path'\nimport * as process from 'node:process'\nimport * as clack from '@clack/prompts'\nimport { isInputPath, type KubbEvents, LogLevel, PromiseManager } from '@kubb/core'\nimport { AsyncEventEmitter } from '@kubb/core/utils'\nimport type { ArgsDef, ParsedArgs } from 'citty'\nimport { defineCommand, showUsage } from 'citty'\nimport getLatestVersion from 'latest-version'\nimport pc from 'picocolors'\nimport { lt } from 'semver'\nimport { version } from '../../package.json'\nimport { setupLogger } from '../loggers/utils.ts'\nimport { generate } from '../runners/generate.ts'\nimport { getConfigs } from '../utils/getConfigs.ts'\nimport { getCosmiConfig } from '../utils/getCosmiConfig.ts'\nimport { startWatcher } from '../utils/watcher.ts'\n\nconst args = {\n  config: {\n    type: 'string',\n    description: 'Path to the Kubb config',\n    alias: 'c',\n  },\n  logLevel: {\n    type: 'string',\n    description: 'Info, silent, verbose or debug',\n    alias: 'l',\n    default: 'info',\n    valueHint: 'silent|info|verbose|debug',\n  },\n  watch: {\n    type: 'boolean',\n    description: 'Watch mode based on the input file',\n    alias: 'w',\n    default: false,\n  },\n  debug: {\n    type: 'boolean',\n    description: 'Override logLevel to debug',\n    alias: 'd',\n    default: false,\n  },\n  verbose: {\n    type: 'boolean',\n    description: 'Override logLevel to verbose',\n    alias: 'v',\n    default: false,\n  },\n  silent: {\n    type: 'boolean',\n    description: 'Override logLevel to silent',\n    alias: 's',\n    default: false,\n  },\n  help: {\n    type: 'boolean',\n    description: 'Show help',\n    alias: 'h',\n    default: false,\n  },\n} as const satisfies ArgsDef\n\nexport type Args = ParsedArgs<typeof args>\n\nconst command = defineCommand({\n  meta: {\n    name: 'generate',\n    description: \"[input] Generate files based on a 'kubb.config.ts' file\",\n  },\n  args,\n  async run(commandContext) {\n    const { args } = commandContext\n    const input = args._[0]\n    const events = new AsyncEventEmitter<KubbEvents>()\n    const promiseManager = new PromiseManager()\n\n    if (args.help) {\n      return showUsage(command)\n    }\n\n    if (args.debug) {\n      args.logLevel = 'debug'\n    }\n\n    if (args.verbose) {\n      args.logLevel = 'verbose'\n    }\n\n    if (args.silent) {\n      args.logLevel = 'silent'\n    }\n\n    const logLevel = LogLevel[args.logLevel as keyof typeof LogLevel] || 3\n\n    await setupLogger(events, { logLevel })\n\n    const latestVersion = await getLatestVersion('@kubb/cli')\n\n    if (lt(version, latestVersion)) {\n      await events.emit('version:new', version, latestVersion)\n    }\n\n    try {\n      await events.emit('lifecycle:start', version)\n\n      await events.emit('config:start')\n\n      const result = await getCosmiConfig('kubb', args.config)\n\n      await events.emit('info', 'Config loaded', path.relative(process.cwd(), result.filepath))\n\n      const configs = await getConfigs(result, args)\n\n      await events.emit('success', 'Config loaded successfully', path.relative(process.cwd(), result.filepath))\n      await events.emit('config:end', configs)\n\n      const promises = configs.map((config) => {\n        return async () => {\n          if (isInputPath(config) && args.watch) {\n            await startWatcher([input || config.input.path], async (paths) => {\n              await generate({\n                input,\n                config,\n                logLevel,\n                events,\n              })\n\n              clack.log.step(pc.yellow(`Watching for changes in ${paths.join(' and ')}`))\n            })\n\n            return\n          }\n\n          await generate({\n            input,\n            config,\n            logLevel,\n            events,\n          })\n        }\n      })\n\n      await promiseManager.run('seq', promises)\n\n      await events.emit('lifecycle:end')\n    } catch (error) {\n      await events.emit('error', error as Error)\n      process.exit(1)\n    }\n  },\n})\n\nexport default command\n"],"mappings":"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"}