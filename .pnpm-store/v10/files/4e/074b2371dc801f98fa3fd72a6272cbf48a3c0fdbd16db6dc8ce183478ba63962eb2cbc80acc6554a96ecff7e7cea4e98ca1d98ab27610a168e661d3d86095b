{"version":3,"file":"typescriptParser-D8rhO8nO.js","names":[],"sources":["../src/parsers/typescriptParser.ts"],"sourcesContent":["import path from 'node:path'\nimport ts from 'typescript'\nimport { getRelativePath } from '../utils/getRelativePath.ts'\nimport { trimExtName } from '../utils/trimExtName.ts'\nimport { defineParser } from './defineParser.ts'\n\nconst { factory } = ts\n\n/**\n * Validates TypeScript AST nodes before printing to catch invalid nodes early.\n * Throws an error if any node has SyntaxKind.Unknown which would cause the TypeScript printer to crash.\n */\nexport function validateNodes(...nodes: ts.Node[]): void {\n  for (const node of nodes) {\n    if (!node) {\n      throw new Error('Attempted to print undefined or null TypeScript node')\n    }\n    if (node.kind === ts.SyntaxKind.Unknown) {\n      throw new Error(\n        'Invalid TypeScript AST node detected with SyntaxKind.Unknown. ' +\n          `This typically indicates a schema pattern that couldn't be properly converted to TypeScript. ` +\n          `Node: ${JSON.stringify(node, null, 2)}`,\n      )\n    }\n  }\n}\n\n/**\n * Convert AST TypeScript/TSX nodes to a string based on the TypeScript printer.\n */\nexport function print(...elements: Array<ts.Node>): string {\n  const sourceFile = ts.createSourceFile('print.tsx', '', ts.ScriptTarget.ES2022, true, ts.ScriptKind.TSX)\n\n  const printer = ts.createPrinter({\n    omitTrailingSemicolon: true,\n    newLine: ts.NewLineKind.LineFeed,\n    removeComments: false,\n    noEmitHelpers: true,\n  })\n\n  for (const node of elements) {\n    if (node.kind === ts.SyntaxKind.Unknown) {\n      console.error('⚠️ Unknown node found:', node)\n    }\n  }\n\n  const output = printer.printList(ts.ListFormat.MultiLine, factory.createNodeArray(elements.filter(Boolean)), sourceFile)\n\n  return output.replace(/\\r\\n/g, '\\n')\n}\n\nexport function safePrint(...elements: Array<ts.Node>): string {\n  validateNodes(...elements)\n\n  return print(...elements)\n}\n\nexport function createImport({\n  name,\n  path,\n  root,\n  isTypeOnly = false,\n  isNameSpace = false,\n}: {\n  name: string | Array<string | { propertyName: string; name?: string }>\n  path: string\n  root?: string\n  isTypeOnly?: boolean\n  isNameSpace?: boolean\n}) {\n  const resolvePath = root ? getRelativePath(root, path) : path\n\n  // Namespace or default import\n  if (!Array.isArray(name)) {\n    if (isNameSpace) {\n      return factory.createImportDeclaration(\n        undefined,\n        factory.createImportClause(isTypeOnly, undefined, factory.createNamespaceImport(factory.createIdentifier(name))),\n        factory.createStringLiteral(resolvePath),\n        undefined,\n      )\n    }\n\n    return factory.createImportDeclaration(\n      undefined,\n      factory.createImportClause(isTypeOnly, factory.createIdentifier(name), undefined),\n      factory.createStringLiteral(resolvePath),\n      undefined,\n    )\n  }\n\n  // Named imports\n  const specifiers = name.map((item) => {\n    if (typeof item === 'object') {\n      const { propertyName, name: alias } = item\n      return factory.createImportSpecifier(false, alias ? factory.createIdentifier(propertyName) : undefined, factory.createIdentifier(alias ?? propertyName))\n    }\n\n    return factory.createImportSpecifier(false, undefined, factory.createIdentifier(item))\n  })\n\n  return factory.createImportDeclaration(\n    undefined,\n    factory.createImportClause(isTypeOnly, undefined, factory.createNamedImports(specifiers)),\n    factory.createStringLiteral(resolvePath),\n    undefined,\n  )\n}\n\nexport function createExport({\n  path,\n  asAlias,\n  isTypeOnly = false,\n  name,\n}: {\n  path: string\n  asAlias?: boolean\n  isTypeOnly?: boolean\n  name?: string | Array<ts.Identifier | string>\n}) {\n  if (name && !Array.isArray(name) && !asAlias) {\n    console.warn(`When using name as string, asAlias should be true ${name}`)\n  }\n\n  if (!Array.isArray(name)) {\n    const parsedName = name?.match(/^\\d/) ? `_${name?.slice(1)}` : name\n\n    return factory.createExportDeclaration(\n      undefined,\n      isTypeOnly,\n      asAlias && parsedName ? factory.createNamespaceExport(factory.createIdentifier(parsedName)) : undefined,\n      factory.createStringLiteral(path),\n      undefined,\n    )\n  }\n\n  return factory.createExportDeclaration(\n    undefined,\n    isTypeOnly,\n    factory.createNamedExports(\n      name.map((propertyName) => {\n        return factory.createExportSpecifier(false, undefined, typeof propertyName === 'string' ? factory.createIdentifier(propertyName) : propertyName)\n      }),\n    ),\n    factory.createStringLiteral(path),\n    undefined,\n  )\n}\n\nexport const typescriptParser = defineParser({\n  name: 'typescript',\n  extNames: ['.ts', '.js'],\n  install() {},\n  async parse(file, options = { extname: '.ts' }) {\n    const sourceParts: Array<string> = []\n    for (const item of file.sources) {\n      if (item.value) {\n        sourceParts.push(item.value)\n      }\n    }\n    const source = sourceParts.join('\\n\\n')\n\n    const importNodes: Array<ts.ImportDeclaration> = []\n    for (const item of file.imports) {\n      const importPath = item.root ? getRelativePath(item.root, item.path) : item.path\n      const hasExtname = !!path.extname(importPath)\n\n      importNodes.push(\n        createImport({\n          name: item.name,\n          path: options.extname && hasExtname ? `${trimExtName(importPath)}${options.extname}` : item.root ? trimExtName(importPath) : importPath,\n          isTypeOnly: item.isTypeOnly,\n        }),\n      )\n    }\n\n    const exportNodes: Array<ts.ExportDeclaration> = []\n    for (const item of file.exports) {\n      const exportPath = item.path\n      const hasExtname = !!path.extname(exportPath)\n\n      exportNodes.push(\n        createExport({\n          name: item.name,\n          path: options.extname && hasExtname ? `${trimExtName(item.path)}${options.extname}` : trimExtName(item.path),\n          isTypeOnly: item.isTypeOnly,\n          asAlias: item.asAlias,\n        }),\n      )\n    }\n\n    const parts = [file.banner, print(...importNodes, ...exportNodes), source, file.footer].filter((segment): segment is string => segment != null)\n    return parts.join('\\n')\n  },\n})\n"],"mappings":"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"}