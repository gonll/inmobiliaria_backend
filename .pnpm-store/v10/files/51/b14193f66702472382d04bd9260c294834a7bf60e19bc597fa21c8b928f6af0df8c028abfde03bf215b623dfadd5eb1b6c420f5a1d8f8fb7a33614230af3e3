import { n as __name, t as __exportAll } from "./chunk-Cq_TCZj9.js";

//#region src/KubbFile.d.ts
declare namespace KubbFile_d_exports {
  export { BaseName, Export, Extname, File, Import, Mode, Path, ResolvedFile, Source };
}
type ImportName = string | Array<string | {
  propertyName: string;
  name?: string;
}>;
type Import = {
  /**
   * Import name to be used
   * @example ["useState"]
   * @example "React"
   */
  name: ImportName;
  /**
   * Path for the import
   * @example '@kubb/core'
   */
  path: string;
  /**
   * Add `type` prefix to the import, this will result in: `import type { Type } from './path'`.
   */
  isTypeOnly?: boolean;
  isNameSpace?: boolean;
  /**
   * When root is set it will get the path with relative getRelativePath(root, path).
   */
  root?: string;
};
type Source = {
  name?: string;
  value?: string;
  isTypeOnly?: boolean;
  /**
   * Has const or type 'export'
   * @default false
   */
  isExportable?: boolean;
  /**
   * When set, barrel generation will add this
   * @default false
   */
  isIndexable?: boolean;
};
type Export = {
  /**
   * Export name to be used.
   * @example ["useState"]
   * @example "React"
   */
  name?: string | Array<string>;
  /**
   * Path for the import.
   * @example '@kubb/core'
   */
  path: string;
  /**
   * Add `type` prefix to the export, this will result in: `export type { Type } from './path'`.
   */
  isTypeOnly?: boolean;
  /**
   * Make it possible to override the name, this will result in: `export * as aliasName from './path'`.
   */
  asAlias?: boolean;
};
type Extname = '.ts' | '.js' | '.tsx' | '.json' | `.${string}`;
type Mode = 'single' | 'split';
/**
 * Name to be used to dynamicly create the baseName(based on input.path)
 * Based on UNIX basename
 * @link https://nodejs.org/api/path.html#pathbasenamepath-suffix
 */
type BaseName = `${string}.${string}`;
/**
 * Path will be full qualified path to a specified file
 */
type Path = string;
type File<TMeta extends object = object> = {
  /**
   * Name to be used to create the path
   * Based on UNIX basename, `${name}.extname`
   * @link https://nodejs.org/api/path.html#pathbasenamepath-suffix
   */
  baseName: BaseName;
  /**
   * Path will be full qualified path to a specified file
   */
  path: Path;
  sources: Array<Source>;
  imports: Array<Import>;
  exports: Array<Export>;
  /**
   * Use extra meta, this is getting used to generate the barrel/index files.
   */
  meta?: TMeta;
  banner?: string;
  footer?: string;
};
type ResolvedFile<TMeta extends object = object> = File<TMeta> & {
  /**
   * @default hash
   */
  id: string;
  /**
   * Contains the first part of the baseName, generated based on baseName
   * @link  https://nodejs.org/api/path.html#pathformatpathobject
   */
  name: string;
  extname: Extname;
  imports: Array<Import>;
  exports: Array<Export>;
};
//#endregion
//#region src/parsers/types.d.ts
type PrintOptions = {
  extname?: Extname;
};
type Parser<TOptions = unknown, TMeta extends object = any> = {
  name: string;
  type: 'parser';
  /**
   * Undefined is being used for the defaultParser
   */
  extNames: Array<Extname> | undefined;
  install: Install<TOptions>;
  /**
   * Convert a file to string
   */
  parse(file: ResolvedFile<TMeta>, options: PrintOptions): Promise<string>;
};
type UserParser<TOptions = unknown, TMeta extends object = any> = Omit<Parser<TOptions, TMeta>, 'type'>;
//#endregion
//#region src/utils/AsyncEventEmitter.d.ts
type Options$2 = {
  mode?: FabricMode;
  maxListener?: number;
};
declare class AsyncEventEmitter<TEvents extends Record<string, any>> {
  #private;
  constructor({
    maxListener,
    mode
  }?: Options$2);
  emit<TEventName extends keyof TEvents & string>(eventName: TEventName, ...eventArgs: TEvents[TEventName]): Promise<void>;
  on<TEventName extends keyof TEvents & string>(eventName: TEventName, handler: (...eventArg: TEvents[TEventName]) => void): void;
  onOnce<TEventName extends keyof TEvents & string>(eventName: TEventName, handler: (...eventArgs: TEvents[TEventName]) => void): void;
  off<TEventName extends keyof TEvents & string>(eventName: TEventName, handler: (...eventArg: TEvents[TEventName]) => void): void;
  removeAll(): void;
}
//#endregion
//#region src/FileProcessor.d.ts
type ProcessFilesProps = {
  parsers?: Map<Extname, Parser>;
  extension?: Record<Extname, Extname | ''>;
  dryRun?: boolean;
  /**
   * @default 'sequential'
   */
  mode?: FabricMode;
};
type GetParseOptions = {
  parsers?: Map<Extname, Parser>;
  extension?: Record<Extname, Extname | ''>;
};
type Options$1 = {
  events?: AsyncEventEmitter<FabricEvents>;
};
declare class FileProcessor {
  #private;
  events: AsyncEventEmitter<FabricEvents>;
  constructor({
    events
  }?: Options$1);
  parse(file: ResolvedFile, {
    parsers,
    extension
  }?: GetParseOptions): Promise<string>;
  run(files: Array<ResolvedFile>, {
    parsers,
    mode,
    dryRun,
    extension
  }?: ProcessFilesProps): Promise<ResolvedFile[]>;
}
//#endregion
//#region src/FileManager.d.ts
type Options = {
  events?: AsyncEventEmitter<FabricEvents>;
};
declare class FileManager {
  #private;
  events: AsyncEventEmitter<FabricEvents>;
  processor: FileProcessor;
  constructor({
    events
  }?: Options);
  add(...files: Array<File>): Array<ResolvedFile>;
  upsert(...files: Array<File>): Array<ResolvedFile>;
  flush(): void;
  getByPath(path: Path): ResolvedFile | null;
  deleteByPath(path: Path): void;
  clear(): void;
  get files(): Array<ResolvedFile>;
  write(options: ProcessFilesProps): Promise<ResolvedFile[]>;
}
//#endregion
//#region src/context.d.ts
/**
 * Context type that carries type information about its value
 * This is a branded symbol type that enables type-safe context usage
 */
type Context<T> = symbol & {
  readonly __type: T;
};
/**
 * Provides a value to descendant components (Vue 3 style)
 *
 * @example
 * ```ts
 * const ThemeKey = Symbol('theme')
 * provide(ThemeKey, { color: 'blue' })
 * ```
 */
declare function provide<T>(key: symbol | Context<T>, value: T): void;
/**
 * Injects a value provided by an ancestor component (Vue 3 style)
 *
 * @example
 * ```ts
 * const theme = inject(ThemeKey, { color: 'default' })
 * ```
 */
declare function inject<T>(key: symbol | Context<T>, defaultValue?: T): T;
/**
 * Unprovides a value (for cleanup)
 * @internal
 */
declare function unprovide<T>(key: symbol | Context<T>): void;
/**
 * Creates a context key with a default value (React-style compatibility)
 *
 * @example
 * ```ts
 * const ThemeContext = createContext({ color: 'blue' })
 * // ThemeContext is now typed as Context<{ color: string }>
 * const theme = useContext(ThemeContext) // theme is { color: string }
 * ```
 */
declare function createContext<T>(defaultValue: T): Context<T>;
//#endregion
//#region src/contexts/RenderContext.d.ts
type RenderContextProps = {
  indentLevel: number;
  indentSize: number;
  currentLineLength: number;
  shouldBreak: boolean;
};
/**
 * Provides a context for tracking rendering state such as indentation and line length.
 */
declare const RenderContext: Context<RenderContextProps>;
//#endregion
//#region src/intrinsic.d.ts
type IntrinsicType = 'br' | 'indent' | 'dedent';
type Intrinsic = {
  type: IntrinsicType;
  __intrinsic: true;
};
/**
 * Helper: render a plain string while applying current indentation at the
 * start of each logical line. This ensures `${indent}` intrinsics affect
 * subsequent string content.
 */
declare function renderIndent(content: string, renderContext: RenderContextProps): string;
declare function renderIntrinsic(children: FabricNode, context?: RenderContextProps): string;
//#endregion
//#region src/plugins/types.d.ts
type Plugin<TOptions = unknown, TAppExtension extends Record<string, any> = {}> = {
  name: string;
  type: 'plugin';
  install: Install<TOptions>;
  /**
   * Runtime app overrides or extensions.
   * Merged into the app instance after install.
   * This cannot be async
   */
  inject?: Inject<TOptions, TAppExtension>;
};
type UserPlugin<TOptions = unknown, TAppExtension extends Record<string, any> = {}> = Omit<Plugin<TOptions, TAppExtension>, 'type'>;
//#endregion
//#region src/Fabric.d.ts
declare global {
  namespace Kubb {
    interface Fabric {}
  }
}
type FabricElement<TProps extends object = object> = {
  (): FabricNode;
  type: string;
  component: (props: TProps) => FabricNode;
  props: TProps;
};
type FabricNode = FabricElement<any> | string | number | boolean | null | undefined | Intrinsic | Array<FabricNode>;
type FabricComponent<TProps extends object = object> = FabricElement<TProps> & {
  children(...children: Array<FabricNode>): FabricElement<TProps>;
};
/**
 * Defines core runtime options for Fabric.
 */
interface FabricOptions {
  /**
   * Determines how Fabric processes files.
   * - `sequential`: files are processed one by one
   * - `parallel`: files are processed concurrently
   *
   * @default 'sequential'
   */
  mode?: FabricMode;
}
/**
 * Available modes for file processing.
 */
type FabricMode = 'sequential' | 'parallel';
/**
 * Event definitions emitted during the Fabric lifecycle.
 *
 * These events allow plugins and external code to hook into different stages
 * of the file generation process. All events are asynchronous and can be
 * listened to using `fabric.context.on()` or `fabric.context.onOnce()`.
 *
 * @example
 * ```ts
 * fabric.context.on('lifecycle:start', async () => {
 *   console.log('Fabric started!')
 * })
 * ```
 */
interface FabricEvents {
  /**
   * Emitted when the Fabric application lifecycle begins.
   * This is typically the first event fired when starting a Fabric run.
   * Use this to perform initial setup or logging.
   */
  'lifecycle:start': [];
  /**
   * Emitted when the Fabric application lifecycle completes.
   * This is typically the last event fired after all processing is done.
   * Use this for cleanup tasks or final reporting.
   */
  'lifecycle:end': [];
  /**
   * Emitted when Fabric starts rendering (used with reactPlugin).
   * Provides access to the Fabric instance for render-time operations.
   */
  'lifecycle:render': [fabric: Fabric];
  /**
   * Emitted once before file processing begins.
   * Provides the complete list of files that will be processed.
   * Use this to prepare for batch operations or display initial file counts.
   */
  'files:processing:start': [files: Array<ResolvedFile>];
  /**
   * Emitted when files are successfully added to the FileManager's internal cache.
   * This happens after files pass through path and name resolution.
   * Use this to track which files have been registered.
   */
  'files:added': [files: Array<ResolvedFile>];
  /**
   * Emitted during file path resolution, before a file is cached.
   * Listeners can modify the file's path property to customize output location.
   * This is called for each file being added via `addFile()` or `upsertFile()`.
   */
  'file:resolve:path': [file: File];
  /**
   * Emitted during file name resolution, before a file is cached.
   * Listeners can modify the file's name-related properties to customize naming.
   * This is called for each file being added via `addFile()` or `upsertFile()`.
   */
  'file:resolve:name': [file: File];
  /**
   * Emitted just before files are written to disk.
   * Provides all files that will be written in this batch.
   * Use this to perform pre-write operations like creating directories.
   */
  'files:writing:start': [files: Array<ResolvedFile>];
  /**
   * Emitted after all files have been successfully written to disk.
   * Provides all files that were written in this batch.
   * Use this for post-write operations like running formatters or reporting.
   */
  'files:writing:end': [files: Array<ResolvedFile>];
  /**
   * Emitted when an individual file starts being processed.
   * This happens for each file in the queue, before parsing.
   * Use this for per-file setup or detailed logging.
   */
  'file:processing:start': [file: ResolvedFile, index: number, total: number];
  /**
   * Emitted when an individual file completes processing.
   * This happens after the file has been parsed and handled.
   * Use this for per-file cleanup or progress tracking.
   */
  'file:processing:end': [file: ResolvedFile, index: number, total: number];
  /**
   * Emitted after each file is processed, providing progress metrics.
   * This is the primary event for implementing progress bars or tracking.
   * Plugins like fsPlugin use this to write files to disk.
   *
   * @property processed - Number of files processed so far
   * @property total - Total number of files to process
   * @property percentage - Completion percentage (0-100)
   * @property source - Optional parsed source code of the file
   * @property file - The file that was just processed
   */
  'file:processing:update': [{
    processed: number;
    total: number;
    percentage: number;
    source?: string;
    file: ResolvedFile;
  }];
  /**
   * Emitted once all files have been successfully processed.
   * This marks the completion of the processing phase.
   * Use this to perform batch operations on all processed files.
   */
  'files:processing:end': [files: Array<ResolvedFile>];
}
/**
 * Shared context passed to all plugins, parsers, and Fabric internals.
 */
interface FabricContext<T extends FabricOptions = FabricOptions> extends AsyncEventEmitter<FabricEvents> {
  /** The active Fabric configuration. */
  config: FabricConfig<T>;
  /** The internal file manager handling file creation, merging, and writing. */
  fileManager: FileManager;
  /** List of files currently in memory. */
  files: ResolvedFile[];
  /** Add new files to the file manager. */
  addFile(...files: File[]): Promise<void>;
  /** Track installed plugins and parsers to prevent duplicates. */
  installedPlugins: Set<Plugin>;
  installedParsers: Map<Extname, Parser>;
}
/**
 * Base configuration object for Fabric.
 */
type FabricConfig<T extends FabricOptions = FabricOptions> = T;
/**
 * Utility type that checks whether all properties of `T` are optional.
 */
type AllOptional<T> = {} extends T ? true : false;
/**
 * Defines the signature of a plugin or parser's `install` function.
 */
type Install<TOptions = unknown> = TOptions extends any[] ? (context: FabricContext, ...options: TOptions) => void | Promise<void> : AllOptional<TOptions> extends true ? (context: FabricContext, options?: TOptions) => void | Promise<void> : (context: FabricContext, options: TOptions) => void | Promise<void>;
/**
 * Defines the signature of a plugin or parser's `inject` function.
 * Returns an object that extends the Fabric instance.
 */
type Inject<TOptions = unknown, TExtension extends Record<string, any> = {}> = TOptions extends any[] ? (context: FabricContext, ...options: TOptions) => Partial<TExtension> : AllOptional<TOptions> extends true ? (context: FabricContext, options?: TOptions) => Partial<TExtension> : (context: FabricContext, options: TOptions) => Partial<TExtension>;
/**
 * The main Fabric runtime interface.
 * Provides access to the current context, registered plugins, files, and utility methods.
 */
interface Fabric<T extends FabricOptions = FabricOptions> extends Kubb.Fabric {
  /** The shared context for this Fabric instance. */
  context: FabricContext<T>;
  /** The files managed by this Fabric instance. */
  files: ResolvedFile[];
  /**
   * Install a plugin or parser into Fabric.
   *
   * @param target - The plugin or parser to install.
   * @param options - Optional configuration or arguments for the target.
   * @returns A Fabric instance extended by the plugin (if applicable).
   */
  use<TPluginOptions = unknown, TMeta extends object = object, TExtension extends Record<string, any> = {}>(target: Plugin<TPluginOptions, TExtension> | Parser<TPluginOptions, TMeta>, ...options: TPluginOptions extends any[] ? NoInfer<TPluginOptions> : AllOptional<TPluginOptions> extends true ? [NoInfer<TPluginOptions>?] : [NoInfer<TPluginOptions>]): (this & TExtension) | Promise<this & TExtension>;
  /**
   * Add one or more files to the Fabric file manager.
   */
  addFile(...files: File[]): Promise<void>;
  /**
   * Add one or more files to the Fabric file manager and merge the source, imports, exports
   */
  upsertFile(...files: File[]): Promise<void>;
}
//#endregion
export { Path as A, UserParser as C, File as D, Extname as E, Source as M, Import as O, Parser as S, Export as T, inject as _, FabricElement as a, FileManager as b, FabricOptions as c, renderIndent as d, renderIntrinsic as f, createContext as g, Context as h, FabricContext as i, ResolvedFile as j, KubbFile_d_exports as k, Plugin as l, RenderContextProps as m, FabricComponent as n, FabricMode as o, RenderContext as p, FabricConfig as r, FabricNode as s, Fabric as t, UserPlugin as u, provide as v, BaseName as w, FileProcessor as x, unprovide as y };
//# sourceMappingURL=Fabric-dUuj_QO6.d.ts.map