{"version":3,"sources":["/home/runner/work/kubb/kubb/packages/core/dist/chunk-XTU72BHD.cjs","../src/transformers/index.ts","../src/transformers/combineCodes.ts","../src/transformers/createJSDocBlockText.ts","../src/transformers/escape.ts","../src/transformers/indent.ts","../src/transformers/nameSorter.ts","../src/transformers/searchAndReplace.ts","../src/transformers/stringify.ts","../src/transformers/trim.ts","../src/transformers/toRegExp.ts","../src/transformers/transformReservedWord.ts"],"names":[],"mappings":"AAAA;AACE;AACA;AACA;AACA;AACF,wDAA6B;AAC7B;AACE;AACF,wDAA6B;AAC7B;AACA;ACVA,8CAAA,CAAA;AACA,gCAAsB;ADYtB;AACA;AEdA,8CAAA,CAAA;AAAO,SAAS,YAAA,CAAa,KAAA,EAAyB;AACpD,EAAA,OAAO,KAAA,CAAM,IAAA,CAAK,IAAI,CAAA;AACxB;AFiBA;AACA;AGpBA,8CAAA,CAAA;AAAO,SAAS,oBAAA,CAAqB,EAAE,SAAS,CAAA,EAAwC;AACtF,EAAA,MAAM,iBAAA,EAAmB,QAAA,CAAS,MAAA,CAAO,OAAO,CAAA;AAEhD,EAAA,GAAA,CAAI,CAAC,gBAAA,CAAiB,MAAA,EAAQ;AAC5B,IAAA,OAAO,EAAA;AAAA,EACT;AAEA,EAAA,OAAO,CAAA;AAAA,GAAA,EAAW,gBAAA,CAAiB,IAAA,CAAK,OAAO,CAAC,CAAA;AAAA,GAAA,CAAA;AAClD;AHuBA;AACA;AIhCA,8CAAA,CAAA;AAAO,SAAS,MAAA,CAAO,IAAA,EAAuB;AAC5C,EAAA,OAAO,KAAA,EAAO,IAAA,CAAK,UAAA,CAAW,GAAA,EAAK,KAAK,EAAA,EAAI,EAAA;AAC9C;AAQO,SAAS,cAAA,CAAe,KAAA,EAAoB;AACjD,EAAA,OAAO,CAAA,EAAA;AACL,IAAA;AACE,MAAA;AACA,MAAA;AACA,MAAA;AACE,QAAA;AAAqB;AAEvB,MAAA;AACE,QAAA;AACF,MAAA;AACE,QAAA;AACF,MAAA;AACE,QAAA;AACF,MAAA;AACE,QAAA;AACF,MAAA;AACE,QAAA;AACJ,IAAA;AACD,EAAA;AACH;AJ4BU;AACA;AK3DV;AAAgB;AACP,EAAA;AACT;AL8DU;AACA;AMjEV;AAAgB;AACR,EAAA;AACJ,IAAA;AACF,EAAA;AACM,EAAA;AACJ,IAAA;AACF,EAAA;AACO,EAAA;AACT;ANoEU;AACA;AO7EV;AAQgB;AACN,EAAA;AAEF,EAAA;AACD,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACA,IAAA;AACC,IAAA;AACN,EAAA;AAEO,EAAA;AACL,IAAA;AACK,EAAA;AACT;APsEU;AACA;AQ/FV;ARiGU;AACA;ASlGV;AAAgB;AACP,EAAA;AACT;AAEgB;AACV,EAAA;AACF,IAAA;AACF,EAAA;AACI,EAAA;AACF,IAAA;AACF,EAAA;AAEI,EAAA;AACF,IAAA;AACF,EAAA;AAEO,EAAA;AACT;AAEgB;AACP,EAAA;AACT;ATiGU;AACA;AQrHM;AACV,EAAA;AACF,IAAA;AACF,EAAA;AAEO,EAAA;AACT;AAEgB;AACR,EAAA;AAEE,IAAA;AACF,MAAA;AACE,QAAA;AAAsB,OAAA;AAE1B,IAAA;AAEA,IAAA;AAED,EAAA;AAEI,EAAA;AACT;ARiHU;AACA;AU1IV;AAGS;AACD,EAAA;AACA,EAAA;AAEC,EAAA;AACT;AAKgB;AACV,EAAA;AACI,IAAA;AAEN,IAAA;AACF,EAAA;AAEO,EAAA;AACT;AAEgB;AACR,EAAA;AACA,EAAA;AAEA,EAAA;AAEC,EAAA;AACT;AVgIU;AACA;AW/JV;AAGM;AACJ,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AAEA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACF;AAEgB;AACT,EAAA;AACH,IAAA;AACF,EAAA;AAEO,EAAA;AACT;AX4JU;AACA;ACnOD;AAGF;AACL,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACO,EAAA;AACL,IAAA;AACF,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACA,EAAA;AACF;ADmOU;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/home/runner/work/kubb/kubb/packages/core/dist/chunk-XTU72BHD.cjs","sourcesContent":[null,"import { orderBy } from 'natural-orderby'\nimport { merge } from 'remeda'\n\nimport { camelCase, pascalCase, pathCase } from './casing.ts'\nimport { combineCodes } from './combineCodes.ts'\nimport { createJSDocBlockText } from './createJSDocBlockText.ts'\nimport { escape, jsStringEscape } from './escape.ts'\nimport { createIndent } from './indent.ts'\nimport { nameSorter } from './nameSorter.ts'\nimport { searchAndReplace } from './searchAndReplace.ts'\nimport { stringify, stringifyObject } from './stringify.ts'\nimport { toRegExp, toRegExpString } from './toRegExp.ts'\nimport { transformReservedWord } from './transformReservedWord.ts'\nimport { trim, trimExtName, trimQuotes } from './trim.ts'\n\nexport { camelCase, pascalCase, pathCase } from './casing.ts'\nexport { combineCodes } from './combineCodes.ts'\nexport { createJSDocBlockText } from './createJSDocBlockText.ts'\nexport { escape, jsStringEscape } from './escape.ts'\nexport { createIndent } from './indent.ts'\nexport { nameSorter } from './nameSorter.ts'\nexport { searchAndReplace } from './searchAndReplace.ts'\nexport { stringify, stringifyObject } from './stringify.ts'\nexport { toRegExp, toRegExpString } from './toRegExp.ts'\nexport { transformReservedWord } from './transformReservedWord.ts'\nexport { trim, trimExtName, trimQuotes } from './trim.ts'\nexport { merge } from 'remeda'\nexport { orderBy } from 'natural-orderby'\n\nexport default {\n  combineCodes,\n  escape,\n  jsStringEscape,\n  createIndent,\n  transformReservedWord,\n  nameSorter,\n  searchAndReplace,\n  stringify,\n  stringifyObject,\n  toRegExp,\n  toRegExpString,\n  trim,\n  trimQuotes,\n  trimExtName,\n  JSDoc: {\n    createJSDocBlockText,\n  },\n  orderBy,\n  merge,\n  camelCase,\n  pascalCase,\n  pathCase,\n} as const\n","export function combineCodes(codes: string[]): string {\n  return codes.join('\\n')\n}\n","export function createJSDocBlockText({ comments }: { comments: Array<string> }): string {\n  const filteredComments = comments.filter(Boolean)\n\n  if (!filteredComments.length) {\n    return ''\n  }\n\n  return `/**\\n * ${filteredComments.join('\\n * ')}\\n */`\n}\n","export function escape(text?: string): string {\n  return text ? text.replaceAll('`', '\\\\`') : ''\n}\n\n/**\n * Escape all characters not included in SingleStringCharacters and DoubleStringCharacters on\n * @link http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4\n * @link https://github.com/joliss/js-string-escape/blob/master/index.js\n */\n\nexport function jsStringEscape(input: any): string {\n  return `${input}`.replace(/[\"'\\\\\\n\\r\\u2028\\u2029]/g, (character) => {\n    switch (character) {\n      case '\"':\n      case \"'\":\n      case '\\\\':\n        return `\\\\${character}`\n      // Four possible LineTerminator characters need to be escaped:\n      case '\\n':\n        return '\\\\n'\n      case '\\r':\n        return '\\\\r'\n      case '\\u2028':\n        return '\\\\u2028'\n      case '\\u2029':\n        return '\\\\u2029'\n      default:\n        return ''\n    }\n  })\n}\n\nexport function escapeStringRegexp(string: string) {\n  if (typeof string !== 'string') {\n    throw new TypeError('Expected a string')\n  }\n\n  // Escape characters with special meaning either inside or outside character sets.\n  // Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d')\n}\n","export function createIndent(size: number): string {\n  return Array.from({ length: size + 1 }).join(' ')\n}\n","export function nameSorter<T extends { name: string }>(a: T, b: T): 0 | 1 | -1 {\n  if (a.name < b.name) {\n    return -1\n  }\n  if (a.name > b.name) {\n    return 1\n  }\n  return 0\n}\n","type Options = {\n  text: string\n  replaceBy: string\n  prefix?: string\n  key: string\n  searchValues?: (prefix: string, key: string) => Array<RegExp | string>\n}\n\nexport function searchAndReplace(options: Options): string {\n  const { text, replaceBy, prefix = '', key } = options\n\n  const searchValues = options.searchValues?.(prefix, key) || [\n    `${prefix}[\"${key}\"]`,\n    `${prefix}['${key}']`,\n    `${prefix}[\\`${key}\\`]`,\n    `${prefix}\"${key}\"`,\n    `${prefix}'${key}'`,\n    `${prefix}\\`${key}\\``,\n    new RegExp(`${prefix}${key}`, 'g'),\n  ]\n\n  return searchValues.reduce((prev, searchValue) => {\n    return prev.toString().replaceAll(searchValue, replaceBy)\n  }, text) as string\n}\n","import { trimQuotes } from './trim'\n\nexport function stringify(value: string | number | boolean | undefined): string {\n  if (value === undefined || value === null) {\n    return '\"\"'\n  }\n\n  return JSON.stringify(trimQuotes(value.toString()))\n}\n\nexport function stringifyObject(value: object): string {\n  const items = Object.entries(value)\n    .map(([key, value]) => {\n      if (typeof value === 'object') {\n        return `${key}: {\n        ${stringifyObject(value)}\n      }`\n      }\n\n      return `${key}: ${value}`\n    })\n    .filter(Boolean)\n\n  return items.join(',\\n')\n}\n","export function trim(text: string): string {\n  return text.replaceAll(/\\n/g, '').trim()\n}\n\nexport function trimQuotes(text: string): string {\n  if (text.match(/^\"(.*)\"$/)) {\n    return text.replace(/^\"(.*)\"$/, '$1')\n  }\n  if (text.match(/^'(.*)'$/)) {\n    return text.replace(/^'(.*)'$/, '$1')\n  }\n\n  if (text.match(/^`(.*)`$/)) {\n    return text.replace(/^`(.*)`$/, '$1')\n  }\n\n  return text\n}\n\nexport function trimExtName(text: string): string {\n  return text.replace(/\\.[^/.]+$/, '')\n}\n","import { jsStringEscape } from './escape'\nimport { trimQuotes } from './trim'\n\nfunction stringToRegex(text: string) {\n  const isStartWithSlash = text.startsWith('/')\n  const isEndWithSlash = text.endsWith('/')\n\n  return new RegExp(text.slice(isStartWithSlash ? 1 : 0, isEndWithSlash ? -1 : undefined))\n}\n\n/**\n * @experimental\n */\nexport function toRegExp(text: string | RegExp): RegExp {\n  if (typeof text === 'string') {\n    const source = trimQuotes(text)\n\n    return stringToRegex(source)\n  }\n\n  return stringToRegex(text.toString())\n}\n\nexport function toRegExpString(text: string, func = 'RegExp'): string {\n  const isStartWithSlash = text.startsWith('/')\n  const isEndWithSlash = text.endsWith('/')\n\n  const regexp = `new ${func}('${jsStringEscape(text.slice(isStartWithSlash ? 1 : 0, isEndWithSlash ? -1 : undefined))}')`\n\n  return regexp\n}\n","/**\n * @link https://github.com/jonschlinkert/reserved/blob/master/index.js\n */\nconst reservedWords = [\n  'abstract',\n  'arguments',\n  'boolean',\n  'break',\n  'byte',\n  'case',\n  'catch',\n  'char',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'double',\n  'else',\n  'enum',\n  'eval',\n  'export',\n  'extends',\n  'false',\n  'final',\n  'finally',\n  'float',\n  'for',\n  'function',\n  'goto',\n  'if',\n  'implements',\n  'import',\n  'in',\n  'instanceof',\n  'int',\n  'interface',\n  'let',\n  'long',\n  'native',\n  'new',\n  'null',\n  'package',\n  'private',\n  'protected',\n  'public',\n  'return',\n  'short',\n  'static',\n  'super',\n  'switch',\n  'synchronized',\n  'this',\n  'throw',\n  'throws',\n  'transient',\n  'true',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'volatile',\n  'while',\n  'with',\n  'yield',\n\n  'Array',\n  'Date',\n  'eval',\n  'function',\n  'hasOwnProperty',\n  'Infinity',\n  'isFinite',\n  'isNaN',\n  'isPrototypeOf',\n  'length',\n  'Math',\n  'name',\n  'NaN',\n  'Number',\n  'Object',\n  'prototype',\n  'String',\n  'toString',\n  'undefined',\n  'valueOf',\n]\n\nexport function transformReservedWord(word: string): string {\n  if ((word && reservedWords.includes(word)) || word?.match(/^\\d/)) {\n    return `_${word}`\n  }\n\n  return word\n}\n"]}