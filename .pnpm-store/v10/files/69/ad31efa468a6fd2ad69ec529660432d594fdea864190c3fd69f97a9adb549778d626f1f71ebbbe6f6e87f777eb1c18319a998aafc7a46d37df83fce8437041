{"version":3,"sources":["/home/runner/work/kubb/kubb/packages/plugin-oas/dist/chunk-VSCBUJRS.cjs","../src/SchemaMapper.ts","../src/SchemaGenerator.ts"],"names":["_schema","nullable","name","min","max"],"mappings":"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","file":"/home/runner/work/kubb/kubb/packages/plugin-oas/dist/chunk-VSCBUJRS.cjs","sourcesContent":[null,"import type * as KubbFile from '@kubb/fs/types'\n\nexport type SchemaKeywordMapper = {\n  object: {\n    keyword: 'object'\n    args: {\n      properties: { [x: string]: Schema[] }\n      additionalProperties: Schema[]\n      strict?: boolean\n    }\n  }\n  strict: { keyword: 'strict' }\n  url: { keyword: 'url' }\n  readOnly: { keyword: 'readOnly' }\n  writeOnly: { keyword: 'writeOnly' }\n  uuid: { keyword: 'uuid' }\n  email: { keyword: 'email' }\n  firstName: { keyword: 'firstName' }\n  lastName: { keyword: 'lastName' }\n  phone: { keyword: 'phone' }\n  password: { keyword: 'password' }\n  date: { keyword: 'date'; args: { type?: 'date' | 'string' } }\n  time: { keyword: 'time'; args: { type?: 'date' | 'string' } }\n  datetime: { keyword: 'datetime'; args: { offset?: boolean; local?: boolean } }\n  tuple: { keyword: 'tuple'; args: { items: Schema[]; min?: number; max?: number } }\n  array: {\n    keyword: 'array'\n    args: { items: Schema[]; min?: number; max?: number }\n  }\n  enum: {\n    keyword: 'enum'\n    args: {\n      name: string\n      typeName: string\n      asConst: boolean\n      items: Array<{\n        name: string | number\n        format: 'string' | 'number' | 'boolean'\n        value?: string | number | boolean\n      }>\n    }\n  }\n  and: { keyword: 'and'; args: Schema[] }\n  const: {\n    keyword: 'const'\n    args: {\n      name: string | number\n      format: 'string' | 'number' | 'boolean'\n      value?: string | number | boolean\n    }\n  }\n  union: { keyword: 'union'; args: Schema[] }\n  ref: {\n    keyword: 'ref'\n    args: { name: string; path: KubbFile.OptionalPath }\n  }\n  matches: { keyword: 'matches'; args?: string }\n  boolean: { keyword: 'boolean' }\n  default: { keyword: 'default'; args: string | number | boolean }\n  string: { keyword: 'string' }\n  integer: { keyword: 'integer' }\n  number: { keyword: 'number' }\n  max: { keyword: 'max'; args: number }\n  min: { keyword: 'min'; args: number }\n  describe: { keyword: 'describe'; args: string }\n  example: { keyword: 'example'; args: string }\n  deprecated: { keyword: 'deprecated' }\n  optional: { keyword: 'optional' }\n  undefined: { keyword: 'undefined' }\n  nullish: { keyword: 'nullish' }\n  nullable: { keyword: 'nullable' }\n  null: { keyword: 'null' }\n  any: { keyword: 'any' }\n  unknown: { keyword: 'unknown' }\n  blob: { keyword: 'blob' }\n  schema: { keyword: 'schema'; args: { type: 'string' | 'number' | 'integer' | 'boolean' | 'array' | 'object'; format?: string } }\n  name: { keyword: 'name'; args: string }\n  catchall: { keyword: 'catchall' }\n}\n\nexport const schemaKeywords = {\n  any: 'any',\n  strict: 'strict',\n  unknown: 'unknown',\n  number: 'number',\n  integer: 'integer',\n  string: 'string',\n  boolean: 'boolean',\n  undefined: 'undefined',\n  nullable: 'nullable',\n  null: 'null',\n  nullish: 'nullish',\n  array: 'array',\n  tuple: 'tuple',\n  enum: 'enum',\n  union: 'union',\n  datetime: 'datetime',\n  date: 'date',\n  email: 'email',\n  uuid: 'uuid',\n  url: 'url',\n  /* intersection */\n  default: 'default',\n  const: 'const',\n  and: 'and',\n  describe: 'describe',\n  min: 'min',\n  max: 'max',\n  optional: 'optional',\n  readOnly: 'readOnly',\n  writeOnly: 'writeOnly',\n\n  // custom ones\n  object: 'object',\n  ref: 'ref',\n  matches: 'matches',\n  firstName: 'firstName',\n  lastName: 'lastName',\n  password: 'password',\n  phone: 'phone',\n  blob: 'blob',\n  deprecated: 'deprecated',\n  example: 'example',\n  schema: 'schema',\n  catchall: 'catchall',\n  time: 'time',\n  name: 'name',\n} satisfies {\n  [K in keyof SchemaKeywordMapper]: SchemaKeywordMapper[K]['keyword']\n}\n\nexport type SchemaKeyword = keyof SchemaKeywordMapper\n\nexport type SchemaMapper<T = string | null | undefined> = {\n  [K in keyof SchemaKeywordMapper]: (() => T | undefined) | undefined\n}\n\nexport type SchemaKeywordBase<T> = {\n  keyword: SchemaKeyword\n  args: T\n}\n\nexport type Schema = { keyword: string } | SchemaKeywordMapper[keyof SchemaKeywordMapper]\n\nexport function isKeyword<T extends Schema, K extends keyof SchemaKeywordMapper>(meta: T, keyword: K): meta is Extract<T, SchemaKeywordMapper[K]> {\n  return meta.keyword === keyword\n}\n","import { type FileMetaBase, Generator } from '@kubb/core'\nimport transformers, { pascalCase } from '@kubb/core/transformers'\nimport { getUniqueName } from '@kubb/core/utils'\n\nimport { isReference } from '@kubb/oas'\nimport { isDeepEqual, isNumber, uniqueWith } from 'remeda'\nimport { isKeyword, schemaKeywords } from './SchemaMapper.ts'\nimport { getSchemaFactory } from './utils/getSchemaFactory.ts'\nimport { getSchemas } from './utils/getSchemas.ts'\n\nimport type { Plugin, PluginFactoryOptions, PluginManager, ResolveNameParams } from '@kubb/core'\nimport type * as KubbFile from '@kubb/fs/types'\n\nimport type { Oas, OpenAPIV3, SchemaObject, contentType } from '@kubb/oas'\nimport type { Schema, SchemaKeywordMapper } from './SchemaMapper.ts'\nimport type { OperationSchema, Override, Refs } from './types.ts'\n\nexport type GetSchemaGeneratorOptions<T extends SchemaGenerator<any, any, any>> = T extends SchemaGenerator<infer Options, any, any> ? Options : never\n\nexport type SchemaMethodResult<TFileMeta extends FileMetaBase> = Promise<KubbFile.File<TFileMeta> | Array<KubbFile.File<TFileMeta>> | null>\n\ntype Context<TOptions, TPluginOptions extends PluginFactoryOptions> = {\n  oas: Oas\n  pluginManager: PluginManager\n  /**\n   * Current plugin\n   */\n  plugin: Plugin<TPluginOptions>\n  mode: KubbFile.Mode\n  include?: Array<'schemas' | 'responses' | 'requestBodies'>\n  override: Array<Override<TOptions>> | undefined\n  contentType?: contentType\n  output?: string\n}\n\nexport type SchemaGeneratorOptions = {\n  dateType: false | 'string' | 'stringOffset' | 'stringLocal' | 'date'\n  unknownType: 'any' | 'unknown'\n  enumType?: 'enum' | 'asConst' | 'asPascalConst' | 'constEnum' | 'literal'\n  enumSuffix?: string\n  usedEnumNames?: Record<string, number>\n  mapper?: Record<string, string>\n  typed?: boolean\n  transformers: {\n    /**\n     * Customize the names based on the type that is provided by the plugin.\n     */\n    name?: (name: ResolveNameParams['name'], type?: ResolveNameParams['type']) => string\n    /**\n     * Receive schema and name(propertName) and return FakerMeta array\n     * TODO TODO add docs\n     * @beta\n     */\n    schema?: (schemaProps: SchemaProps, defaultSchemas: Schema[]) => Schema[] | undefined\n  }\n}\n\nexport type SchemaGeneratorBuildOptions = Omit<OperationSchema, 'name' | 'schema'>\n\ntype SchemaProps = {\n  schema?: SchemaObject\n  name?: string\n  parentName?: string\n}\n\nexport abstract class SchemaGenerator<\n  TOptions extends SchemaGeneratorOptions = SchemaGeneratorOptions,\n  TPluginOptions extends PluginFactoryOptions = PluginFactoryOptions,\n  TFileMeta extends FileMetaBase = FileMetaBase,\n> extends Generator<TOptions, Context<TOptions, TPluginOptions>> {\n  // Collect the types of all referenced schemas, so we can export them later\n  refs: Refs = {}\n\n  // Keep track of already used type aliases\n  #usedAliasNames: Record<string, number> = {}\n\n  /**\n   * Creates a type node from a given schema.\n   * Delegates to getBaseTypeFromSchema internally and\n   * optionally adds a union with null.\n   */\n  parse(props: SchemaProps): Schema[] {\n    const options = this.#getOptions(props)\n\n    const defaultSchemas = this.#parseSchemaObject(props)\n    const schemas = options.transformers?.schema?.(props, defaultSchemas) || defaultSchemas || []\n\n    return uniqueWith(schemas, isDeepEqual)\n  }\n\n  deepSearch<T extends keyof SchemaKeywordMapper>(tree: Schema[] | undefined, keyword: T): SchemaKeywordMapper[T][] {\n    return SchemaGenerator.deepSearch<T>(tree, keyword)\n  }\n\n  find<T extends keyof SchemaKeywordMapper>(tree: Schema[] | undefined, keyword: T): SchemaKeywordMapper[T] | undefined {\n    return SchemaGenerator.find<T>(tree, keyword)\n  }\n\n  static deepSearch<T extends keyof SchemaKeywordMapper>(tree: Schema[] | undefined, keyword: T): SchemaKeywordMapper[T][] {\n    const foundItems: SchemaKeywordMapper[T][] = []\n\n    tree?.forEach((schema) => {\n      if (schema.keyword === keyword) {\n        foundItems.push(schema as SchemaKeywordMapper[T])\n      }\n\n      if (schema.keyword === schemaKeywords.object) {\n        const subItem = schema as SchemaKeywordMapper['object']\n\n        Object.values(subItem.args?.properties || {}).forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>(entrySchema, keyword))\n        })\n\n        Object.values(subItem.args?.additionalProperties || {}).forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n        })\n      }\n\n      if (schema.keyword === schemaKeywords.array) {\n        const subItem = schema as SchemaKeywordMapper['array']\n\n        subItem.args.items.forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n        })\n      }\n\n      if (schema.keyword === schemaKeywords.and) {\n        const subItem = schema as SchemaKeywordMapper['and']\n\n        subItem.args.forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n        })\n      }\n\n      if (schema.keyword === schemaKeywords.tuple) {\n        const subItem = schema as SchemaKeywordMapper['tuple']\n\n        subItem.args.items.forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n        })\n      }\n\n      if (schema.keyword === schemaKeywords.union) {\n        const subItem = schema as SchemaKeywordMapper['union']\n\n        subItem.args.forEach((entrySchema) => {\n          foundItems.push(...SchemaGenerator.deepSearch<T>([entrySchema], keyword))\n        })\n      }\n    })\n\n    return foundItems\n  }\n\n  static findInObject<T extends keyof SchemaKeywordMapper>(tree: Schema[] | undefined, keyword: T): SchemaKeywordMapper[T] | undefined {\n    let foundItem: SchemaKeywordMapper[T] | undefined = undefined\n\n    tree?.forEach((schema) => {\n      if (!foundItem && schema.keyword === keyword) {\n        foundItem = schema as SchemaKeywordMapper[T]\n      }\n\n      if (schema.keyword === schemaKeywords.object) {\n        const subItem = schema as SchemaKeywordMapper['object']\n\n        Object.values(subItem.args?.properties || {}).forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>(entrySchema, keyword)\n          }\n        })\n\n        Object.values(subItem.args?.additionalProperties || {}).forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>([entrySchema], keyword)\n          }\n        })\n      }\n    })\n\n    return foundItem\n  }\n\n  static find<T extends keyof SchemaKeywordMapper>(tree: Schema[] | undefined, keyword: T): SchemaKeywordMapper[T] | undefined {\n    let foundItem: SchemaKeywordMapper[T] | undefined = undefined\n\n    tree?.forEach((schema) => {\n      if (!foundItem && schema.keyword === keyword) {\n        foundItem = schema as SchemaKeywordMapper[T]\n      }\n\n      if (schema.keyword === schemaKeywords.array) {\n        const subItem = schema as SchemaKeywordMapper['array']\n\n        subItem.args.items.forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>([entrySchema], keyword)\n          }\n        })\n      }\n\n      if (schema.keyword === schemaKeywords.and) {\n        const subItem = schema as SchemaKeywordMapper['and']\n\n        subItem.args.forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>([entrySchema], keyword)\n          }\n        })\n      }\n\n      if (schema.keyword === schemaKeywords.tuple) {\n        const subItem = schema as SchemaKeywordMapper['tuple']\n\n        subItem.args.items.forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>([entrySchema], keyword)\n          }\n        })\n      }\n\n      if (schema.keyword === schemaKeywords.union) {\n        const subItem = schema as SchemaKeywordMapper['union']\n\n        subItem.args.forEach((entrySchema) => {\n          if (!foundItem) {\n            foundItem = SchemaGenerator.find<T>([entrySchema], keyword)\n          }\n        })\n      }\n    })\n\n    return foundItem\n  }\n\n  #getUsedEnumNames(props: SchemaProps) {\n    const options = this.#getOptions(props)\n\n    return options.usedEnumNames || {}\n  }\n\n  #getOptions({ name }: SchemaProps): Partial<TOptions> {\n    const { override = [] } = this.context\n\n    return {\n      ...this.options,\n      ...(override.find(({ pattern, type }) => {\n        if (name && type === 'schemaName') {\n          return !!name.match(pattern)\n        }\n\n        return false\n      })?.options || {}),\n    }\n  }\n\n  #getUnknownReturn(props: SchemaProps) {\n    const options = this.#getOptions(props)\n\n    if (options.unknownType === 'any') {\n      return schemaKeywords.any\n    }\n\n    return schemaKeywords.unknown\n  }\n\n  /**\n   * Recursively creates a type literal with the given props.\n   */\n  #parseProperties({ schema, name }: SchemaProps): Schema[] {\n    const properties = schema?.properties || {}\n    const additionalProperties = schema?.additionalProperties\n    const required = schema?.required\n\n    const propertiesSchemas = Object.keys(properties)\n      .map((propertyName) => {\n        const validationFunctions: Schema[] = []\n        const propertySchema = properties[propertyName] as SchemaObject\n\n        const isRequired = Array.isArray(required) ? required?.includes(propertyName) : !!required\n        const nullable = propertySchema.nullable ?? propertySchema['x-nullable'] ?? false\n\n        validationFunctions.push(...this.parse({ schema: propertySchema, name: propertyName, parentName: name }))\n\n        validationFunctions.push({\n          keyword: schemaKeywords.name,\n          args: propertyName,\n        })\n\n        if (!isRequired && nullable) {\n          validationFunctions.push({ keyword: schemaKeywords.nullish })\n        } else if (!isRequired) {\n          validationFunctions.push({ keyword: schemaKeywords.optional })\n        }\n\n        return {\n          [propertyName]: validationFunctions,\n        }\n      })\n      .reduce((acc, curr) => ({ ...acc, ...curr }), {})\n    let additionalPropertiesSchemas: Schema[] = []\n\n    if (additionalProperties) {\n      additionalPropertiesSchemas =\n        additionalProperties === true || !Object.keys(additionalProperties).length\n          ? [{ keyword: this.#getUnknownReturn({ schema, name }) }]\n          : this.parse({ schema: additionalProperties as SchemaObject, parentName: name })\n    }\n\n    return [\n      {\n        keyword: schemaKeywords.object,\n        args: {\n          properties: propertiesSchemas,\n          additionalProperties: additionalPropertiesSchemas,\n        },\n      },\n    ]\n  }\n\n  /**\n   * Create a type alias for the schema referenced by the given ReferenceObject\n   */\n  #getRefAlias(obj: OpenAPIV3.ReferenceObject): Schema[] {\n    const { $ref } = obj\n    let ref = this.refs[$ref]\n\n    const originalName = getUniqueName($ref.replace(/.+\\//, ''), this.#usedAliasNames)\n    const propertyName = this.context.pluginManager.resolveName({\n      name: originalName,\n      pluginKey: this.context.plugin.key,\n      type: 'function',\n    })\n\n    if (ref) {\n      return [\n        {\n          keyword: schemaKeywords.ref,\n          args: { name: ref.propertyName, path: ref.path },\n        },\n      ]\n    }\n\n    const fileName = this.context.pluginManager.resolveName({\n      name: originalName,\n      pluginKey: this.context.plugin.key,\n      type: 'file',\n    })\n    const file = this.context.pluginManager.getFile({\n      name: fileName,\n      pluginKey: this.context.plugin.key,\n      extName: '.ts',\n    })\n\n    ref = this.refs[$ref] = {\n      propertyName,\n      originalName,\n      path: file.path,\n    }\n\n    return [\n      {\n        keyword: schemaKeywords.ref,\n        args: { name: ref.propertyName, path: ref?.path },\n      },\n    ]\n  }\n\n  #getParsedSchemaObject(schema?: SchemaObject) {\n    const parsedSchema = getSchemaFactory(this.context.oas)(schema)\n    return parsedSchema\n  }\n\n  /**\n   * This is the very core of the OpenAPI to TS conversion - it takes a\n   * schema and returns the appropriate type.\n   */\n  #parseSchemaObject({ schema: _schema, name, parentName }: SchemaProps): Schema[] {\n    const options = this.#getOptions({ schema: _schema, name })\n    const unknownReturn = this.#getUnknownReturn({ schema: _schema, name })\n    const { schema, version } = this.#getParsedSchemaObject(_schema)\n    if (!schema) {\n      return [{ keyword: unknownReturn }]\n    }\n\n    const baseItems: Schema[] = [\n      {\n        keyword: schemaKeywords.schema,\n        args: {\n          type: schema.type as any,\n          format: schema.format,\n        },\n      },\n    ]\n    const min = schema.minimum ?? schema.minLength ?? schema.minItems ?? undefined\n    const max = schema.maximum ?? schema.maxLength ?? schema.maxItems ?? undefined\n    const nullable = schema.nullable ?? schema['x-nullable'] ?? false\n\n    if (schema.default !== undefined && !Array.isArray(schema.default)) {\n      if (typeof schema.default === 'string') {\n        baseItems.push({\n          keyword: schemaKeywords.default,\n          args: transformers.stringify(schema.default),\n        })\n      } else if (typeof schema.default === 'boolean') {\n        baseItems.push({\n          keyword: schemaKeywords.default,\n          args: schema.default ?? false,\n        })\n      } else {\n        baseItems.push({\n          keyword: schemaKeywords.default,\n          args: schema.default,\n        })\n      }\n    }\n\n    if (schema.description) {\n      baseItems.push({\n        keyword: schemaKeywords.describe,\n        args: schema.description,\n      })\n    }\n\n    if (schema.pattern) {\n      baseItems.unshift({\n        keyword: schemaKeywords.matches,\n        args: schema.pattern,\n      })\n    }\n\n    if (max !== undefined) {\n      baseItems.unshift({ keyword: schemaKeywords.max, args: max })\n    }\n\n    if (min !== undefined) {\n      baseItems.unshift({ keyword: schemaKeywords.min, args: min })\n    }\n\n    if (nullable) {\n      baseItems.push({ keyword: schemaKeywords.nullable })\n    }\n\n    if (schema.type && Array.isArray(schema.type)) {\n      const [_schema, nullable] = schema.type\n\n      if (nullable === 'null') {\n        baseItems.push({ keyword: schemaKeywords.nullable })\n      }\n    }\n\n    if (schema.readOnly) {\n      baseItems.push({ keyword: schemaKeywords.readOnly })\n    }\n\n    if (schema.writeOnly) {\n      baseItems.push({ keyword: schemaKeywords.writeOnly })\n    }\n\n    if (isReference(schema)) {\n      return [\n        ...this.#getRefAlias(schema),\n        nullable && { keyword: schemaKeywords.nullable },\n        schema.readOnly && { keyword: schemaKeywords.readOnly },\n        schema.writeOnly && { keyword: schemaKeywords.writeOnly },\n        {\n          keyword: schemaKeywords.schema,\n          args: {\n            type: schema.type as any,\n            format: schema.format,\n          },\n        },\n      ].filter(Boolean)\n    }\n\n    if (schema.oneOf) {\n      // union\n      const schemaWithoutOneOf = { ...schema, oneOf: undefined }\n\n      const union: Schema = {\n        keyword: schemaKeywords.union,\n        args: schema.oneOf\n          .map((item) => {\n            return item && this.parse({ schema: item as SchemaObject, name, parentName })[0]\n          })\n          .filter(Boolean)\n          .filter((item) => {\n            return item && item.keyword !== unknownReturn\n          }),\n      }\n      if (schemaWithoutOneOf.properties) {\n        const propertySchemas = this.parse({ schema: schemaWithoutOneOf, name, parentName })\n\n        return [\n          {\n            ...union,\n            args: union.args.map((arg) => {\n              return {\n                keyword: schemaKeywords.and,\n                args: [arg, ...propertySchemas],\n              }\n            }),\n          },\n          ...baseItems,\n        ]\n      }\n\n      return [union, ...baseItems]\n    }\n\n    if (schema.anyOf) {\n      // union\n      const schemaWithoutAnyOf = { ...schema, anyOf: undefined }\n\n      const union: Schema = {\n        keyword: schemaKeywords.union,\n        args: schema.anyOf\n          .map((item) => {\n            return item && this.parse({ schema: item as SchemaObject, name, parentName })[0]\n          })\n          .filter(Boolean)\n          .filter((item) => {\n            return item && item.keyword !== unknownReturn\n          })\n          .map((item) => {\n            if (isKeyword(item, schemaKeywords.object)) {\n              return {\n                ...item,\n                args: {\n                  ...item.args,\n                  strict: true,\n                },\n              }\n            }\n            return item\n          }),\n      }\n      if (schemaWithoutAnyOf.properties) {\n        return [...this.parse({ schema: schemaWithoutAnyOf, name, parentName }), union, ...baseItems]\n      }\n\n      return [union, ...baseItems]\n    }\n    if (schema.allOf) {\n      // intersection/add\n      const schemaWithoutAllOf = { ...schema, allOf: undefined }\n\n      const and: Schema = {\n        keyword: schemaKeywords.and,\n        args: schema.allOf\n          .map((item) => {\n            return item && this.parse({ schema: item as SchemaObject, name, parentName })[0]\n          })\n          .filter(Boolean)\n          .filter((item) => {\n            return item && item.keyword !== unknownReturn\n          }),\n      }\n\n      if (schemaWithoutAllOf.properties) {\n        return [\n          {\n            ...and,\n            args: [...(and.args || []), ...this.parse({ schema: schemaWithoutAllOf, name, parentName })],\n          },\n          ...baseItems,\n        ]\n      }\n\n      return [and, ...baseItems]\n    }\n\n    if (schema.enum) {\n      const enumName = getUniqueName(pascalCase([parentName, name, options.enumSuffix].join(' ')), this.#getUsedEnumNames({ schema, name }))\n      const typeName = this.context.pluginManager.resolveName({\n        name: enumName,\n        pluginKey: this.context.plugin.key,\n        type: 'type',\n      })\n\n      const nullableEnum = schema.enum.includes(null)\n      if (nullableEnum) {\n        baseItems.push({ keyword: schemaKeywords.nullable })\n      }\n      const filteredValues = schema.enum.filter((value) => value !== null)\n\n      // x-enumNames has priority\n      const extensionEnums = ['x-enumNames', 'x-enum-varnames']\n        .filter((extensionKey) => extensionKey in schema)\n        .map((extensionKey) => {\n          return [\n            {\n              keyword: schemaKeywords.enum,\n              args: {\n                name,\n                typeName,\n                asConst: false,\n                items: [...new Set(schema[extensionKey as keyof typeof schema] as string[])].map((name: string | number, index) => ({\n                  name: transformers.stringify(name),\n                  value: schema.enum?.[index] as string | number,\n                  format: isNumber(schema.enum?.[index]) ? 'number' : 'string',\n                })),\n              },\n            },\n            ...baseItems.filter(\n              (item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max && item.keyword !== schemaKeywords.matches,\n            ),\n          ]\n        })\n\n      if (schema.type === 'number' || schema.type === 'integer') {\n        // we cannot use z.enum when enum type is number/integer\n        const enumNames = extensionEnums[0]?.find((item) => isKeyword(item, schemaKeywords.enum)) as unknown as SchemaKeywordMapper['enum']\n        return [\n          {\n            keyword: schemaKeywords.enum,\n            args: {\n              name: enumName,\n              typeName,\n              asConst: true,\n              items: enumNames?.args?.items\n                ? [...new Set(enumNames.args.items)].map(({ name, value }) => ({\n                    name,\n                    value,\n                    format: 'number',\n                  }))\n                : [...new Set(filteredValues)].map((value: string) => {\n                    return {\n                      name: value,\n                      value,\n                      format: 'number',\n                    }\n                  }),\n            },\n          },\n          ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max && item.keyword !== schemaKeywords.matches),\n        ]\n      }\n\n      if (schema.type === 'boolean') {\n        // we cannot use z.enum when enum type is boolean\n        const enumNames = extensionEnums[0]?.find((item) => isKeyword(item, schemaKeywords.enum)) as unknown as SchemaKeywordMapper['enum']\n        return [\n          {\n            keyword: schemaKeywords.enum,\n            args: {\n              name: enumName,\n              typeName,\n              asConst: true,\n              items: enumNames?.args?.items\n                ? [...new Set(enumNames.args.items)].map(({ name, value }) => ({\n                    name,\n                    value,\n                    format: 'boolean',\n                  }))\n                : [...new Set(filteredValues)].map((value: string) => {\n                    return {\n                      name: value,\n                      value,\n                      format: 'boolean',\n                    }\n                  }),\n            },\n          },\n          ...baseItems.filter((item) => item.keyword !== schemaKeywords.matches),\n        ]\n      }\n\n      if (extensionEnums.length > 0 && extensionEnums[0]) {\n        return extensionEnums[0]\n      }\n\n      return [\n        {\n          keyword: schemaKeywords.enum,\n          args: {\n            name: enumName,\n            typeName,\n            asConst: false,\n            items: [...new Set(filteredValues)].map((value: string) => ({\n              name: transformers.stringify(value),\n              value,\n              format: isNumber(value) ? 'number' : 'string',\n            })),\n          },\n        },\n        ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max && item.keyword !== schemaKeywords.matches),\n      ]\n    }\n\n    if ('prefixItems' in schema) {\n      const prefixItems = schema.prefixItems as SchemaObject[]\n      const min = schema.minimum ?? schema.minLength ?? schema.minItems ?? undefined\n      const max = schema.maximum ?? schema.maxLength ?? schema.maxItems ?? undefined\n\n      return [\n        {\n          keyword: schemaKeywords.tuple,\n          args: {\n            min,\n            max,\n            items: prefixItems\n              .map((item) => {\n                return this.parse({ schema: item, name, parentName })[0]\n              })\n              .filter(Boolean),\n          },\n        },\n        ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max),\n      ]\n    }\n\n    if (version === '3.1' && 'const' in schema) {\n      // const keyword takes precendence over the actual type.\n      if (schema['const']) {\n        return [\n          {\n            keyword: schemaKeywords.const,\n            args: {\n              name: schema['const'],\n              format: typeof schema['const'] === 'number' ? 'number' : 'string',\n              value: schema['const'],\n            },\n          },\n          ...baseItems,\n        ]\n      }\n      return [{ keyword: schemaKeywords.null }]\n    }\n\n    /**\n     * > Structural validation alone may be insufficient to allow an application to correctly utilize certain values. The \"format\"\n     * > annotation keyword is defined to allow schema authors to convey semantic information for a fixed subset of values which are\n     * > accurately described by authoritative resources, be they RFCs or other external specifications.\n     *\n     * In other words: format is more specific than type alone, hence it should override the type value, if possible.\n     *\n     * see also https://json-schema.org/draft/2020-12/draft-bhutton-json-schema-validation-00#rfc.section.7\n     */\n    if (schema.format) {\n      switch (schema.format) {\n        case 'binary':\n          baseItems.push({ keyword: schemaKeywords.blob })\n          return baseItems\n        case 'date-time':\n          if (options.dateType) {\n            if (options.dateType === 'date') {\n              baseItems.unshift({ keyword: schemaKeywords.date, args: { type: 'date' } })\n\n              return baseItems\n            }\n\n            if (options.dateType === 'stringOffset') {\n              baseItems.unshift({ keyword: schemaKeywords.datetime, args: { offset: true } })\n              return baseItems\n            }\n\n            if (options.dateType === 'stringLocal') {\n              baseItems.unshift({ keyword: schemaKeywords.datetime, args: { local: true } })\n              return baseItems\n            }\n\n            baseItems.unshift({ keyword: schemaKeywords.datetime, args: { offset: false } })\n\n            return baseItems\n          }\n          break\n        case 'date':\n          if (options.dateType) {\n            if (options.dateType === 'date') {\n              baseItems.unshift({ keyword: schemaKeywords.date, args: { type: 'date' } })\n\n              return baseItems\n            }\n\n            baseItems.unshift({ keyword: schemaKeywords.date, args: { type: 'string' } })\n\n            return baseItems\n          }\n          break\n        case 'time':\n          if (options.dateType) {\n            if (options.dateType === 'date') {\n              baseItems.unshift({ keyword: schemaKeywords.time, args: { type: 'date' } })\n\n              return baseItems\n            }\n\n            baseItems.unshift({ keyword: schemaKeywords.time, args: { type: 'string' } })\n\n            return baseItems\n          }\n          break\n        case 'uuid':\n          baseItems.unshift({ keyword: schemaKeywords.uuid })\n          break\n        case 'email':\n        case 'idn-email':\n          baseItems.unshift({ keyword: schemaKeywords.email })\n          break\n        case 'uri':\n        case 'ipv4':\n        case 'ipv6':\n        case 'uri-reference':\n        case 'hostname':\n        case 'idn-hostname':\n          baseItems.unshift({ keyword: schemaKeywords.url })\n          break\n        // case 'duration':\n        // case 'json-pointer':\n        // case 'relative-json-pointer':\n        default:\n          // formats not yet implemented: ignore.\n          break\n      }\n    }\n\n    // type based logic\n    if ('items' in schema || schema.type === ('array' as 'string')) {\n      const min = schema.minimum ?? schema.minLength ?? schema.minItems ?? undefined\n      const max = schema.maximum ?? schema.maxLength ?? schema.maxItems ?? undefined\n      const items = this.parse({ schema: 'items' in schema ? (schema.items as SchemaObject) : [], name, parentName })\n\n      return [\n        {\n          keyword: schemaKeywords.array,\n          args: {\n            items,\n            min,\n            max,\n          },\n        },\n        ...baseItems.filter((item) => item.keyword !== schemaKeywords.min && item.keyword !== schemaKeywords.max),\n      ]\n    }\n\n    if (schema.properties || schema.additionalProperties) {\n      return [...this.#parseProperties({ schema, name }), ...baseItems]\n    }\n\n    if (schema.type) {\n      if (Array.isArray(schema.type)) {\n        // OPENAPI v3.1.0: https://www.openapis.org/blog/2021/02/16/migrating-from-openapi-3-0-to-3-1-0\n        const [type] = schema.type as Array<OpenAPIV3.NonArraySchemaObjectType>\n\n        return [\n          ...this.parse({\n            schema: {\n              ...schema,\n              type,\n            },\n            name,\n            parentName,\n          }),\n          ...baseItems,\n        ].filter(Boolean)\n      }\n\n      if (!['boolean', 'object', 'number', 'string', 'integer', 'null'].includes(schema.type)) {\n        this.context.pluginManager.logger.emit('warning', `Schema type '${schema.type}' is not valid for schema ${parentName}.${name}`)\n      }\n\n      // 'string' | 'number' | 'integer' | 'boolean'\n      return [{ keyword: schema.type }, ...baseItems]\n    }\n\n    return [{ keyword: unknownReturn }]\n  }\n\n  async build(): Promise<Array<KubbFile.File<TFileMeta>>> {\n    const { oas, contentType, include } = this.context\n\n    oas.resolveDiscriminators()\n\n    const schemas = getSchemas({ oas, contentType, includes: include })\n\n    const promises = Object.entries(schemas).reduce((acc, [name, schema]) => {\n      const options = this.#getOptions({ name })\n      const promiseOperation = this.schema.call(this, name, schema, {\n        ...this.options,\n        ...options,\n      })\n\n      if (promiseOperation) {\n        acc.push(promiseOperation)\n      }\n\n      return acc\n    }, [] as SchemaMethodResult<TFileMeta>[])\n\n    const files = await Promise.all(promises)\n\n    // using .flat because schemaGenerator[method] can return a array of files or just one file\n    return files.flat().filter(Boolean)\n  }\n\n  /**\n   * Schema\n   */\n  abstract schema(name: string, object: SchemaObject, options: TOptions): SchemaMethodResult<TFileMeta>\n}\n"]}