{"version":3,"file":"index.js","names":[],"sources":["../src/composables/useContext.ts","../src/composables/useNodeTree.ts","../src/contexts/AppContext.ts","../src/components/App.ts","../src/components/Br.ts","../src/utils/createJSDoc.ts","../src/components/Const.ts","../src/components/Dedent.ts","../src/contexts/FileContext.ts","../src/composables/useFile.ts","../src/composables/useFileManager.ts","../src/components/File.ts","../src/components/Indent.ts","../src/components/Function.ts","../src/components/Type.ts","../src/composables/useApp.ts","../src/composables/useLifecycle.ts","../src/createFabric.ts"],"sourcesContent":["import type { Context } from '../context.ts'\nimport { inject } from '../context.ts'\n\n/**\n * React-style alias for inject\n *\n * @example\n * ```ts\n * const theme = useContext(ThemeContext) // type is inferred from ThemeContext\n * ```\n */\nexport function useContext<T>(key: Context<T>): T\nexport function useContext<T, TValue = T>(key: Context<T>, defaultValue: TValue): NonNullable<T> | TValue\nexport function useContext<T>(key: Context<T>, defaultValue?: T): T {\n  return inject(key, defaultValue)\n}\n","import { NodeTreeContext } from '../contexts/NodeTreeContext.ts'\nimport type { TreeNode } from '../utils/TreeNode.ts'\nimport { useContext } from './useContext.ts'\n\nexport type ComponentNode = {\n  type: string\n  props: Record<string, unknown>\n}\n\nexport function useNodeTree(): TreeNode<ComponentNode> | null {\n  return useContext(NodeTreeContext)\n}\n","import { createContext } from '../context.ts'\n\nexport type AppContextProps<TMeta extends object = object> = {\n  /**\n   * Exit (unmount)\n   */\n  exit: (error?: Error) => void\n  meta: TMeta\n}\n\n/**\n * Provides app-level metadata and lifecycle hooks (like `exit`) to\n * components and composables within a Fabric runtime.\n */\nexport const AppContext = createContext<AppContextProps>({\n  exit: () => {},\n  meta: {},\n})\n","import { useContext } from '../composables/useContext.ts'\nimport { useNodeTree } from '../composables/useNodeTree.ts'\nimport { provide } from '../context.ts'\nimport { AppContext } from '../contexts/AppContext.ts'\nimport { NodeTreeContext } from '../contexts/NodeTreeContext.ts'\nimport { RootContext } from '../contexts/RootContext.ts'\nimport { createComponent } from '../createComponent.ts'\nimport type { FabricNode } from '../Fabric.ts'\n\nexport type AppProps<TMeta extends Object = Object> = {\n  /**\n   * Metadata associated with the App.\n   */\n  meta?: TMeta\n  /**\n   * Children nodes.\n   */\n  children?: FabricNode\n}\n\n/**\n * App container containing the AppContext carrying `meta` and an `exit` hook.\n */\nexport const App = createComponent('App', ({ children, ...props }: AppProps) => {\n  const { meta = {} } = props\n\n  const { exit } = useContext(RootContext)\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'App', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  provide(AppContext, { exit, meta })\n\n  return children\n})\n\nApp.displayName = 'KubbApp'\n","import { createComponent } from '../createComponent.ts'\nimport { createIntrinsic } from '../intrinsic.ts'\n\n/**\n * Generates a line break in the output.\n */\nexport const Br = createComponent('br', () => {\n  return createIntrinsic('br')\n})\n\nBr.displayName = 'Br'\n","/**\n * Create JSDoc comment block from comments array\n */\nexport function createJSDoc({ comments }: { comments: string[] }): string {\n  if (!comments || comments.length === 0) return ''\n\n  const lines = comments\n    .flatMap((c) => String(c ?? '').split(/\\r?\\n/))\n    .map((l) => l.replace(/\\*\\//g, '*\\\\/').replace(/\\r/g, ''))\n    .filter((l) => l.trim().length > 0)\n\n  if (lines.length === 0) return ''\n\n  return ['/**', ...lines.map((l) => ` * ${l}`), ' */'].join('\\n')\n}\n","import { useNodeTree } from '../composables/useNodeTree.ts'\nimport { provide } from '../context.ts'\nimport { NodeTreeContext } from '../contexts/NodeTreeContext.ts'\nimport { createComponent } from '../createComponent.ts'\nimport type { FabricNode } from '../Fabric.ts'\nimport type { JSDoc } from '../types.ts'\nimport { createJSDoc } from '../utils/createJSDoc.ts'\n\nexport type ConstProps = {\n  /**\n   * Name of the const\n   */\n  name: string\n  /**\n   * Does this type need to be exported.\n   */\n  export?: boolean\n  /**\n   * Type to make the const being typed\n   */\n  type?: string\n  /**\n   * Options for JSdocs.\n   */\n  JSDoc?: JSDoc\n  /**\n   * Use of `const` assertions\n   */\n  asConst?: boolean\n  /**\n   * Children nodes.\n   */\n  children?: FabricNode\n}\n\n/**\n * Generates a TypeScript constant declaration.\n */\nexport const Const = createComponent('Const', ({ children, ...props }: ConstProps) => {\n  const { name, export: canExport, type, JSDoc, asConst } = props\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'Const', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  let result = ''\n\n  if (JSDoc?.comments) {\n    result += createJSDoc({ comments: JSDoc.comments })\n    result += '\\n'\n  }\n\n  if (canExport) {\n    result += 'export '\n  }\n\n  result += `const ${name}`\n\n  if (type) {\n    result += `: ${type}`\n  }\n\n  result += ` = ${children ? children : ''}`\n\n  if (asConst) {\n    result += ' as const'\n  }\n\n  return result\n})\n\nConst.displayName = 'KubbConst'\n","import { createComponent } from '../createComponent.ts'\nimport { createIntrinsic } from '../intrinsic.ts'\n\n/**\n * Dedent component for reducing indentation level in rendered output.\n */\nexport const Dedent = createComponent('dedent', () => {\n  return createIntrinsic('dedent')\n})\nDedent.displayName = 'Dedent'\n","import { createContext } from '../context.ts'\nimport type * as KubbFile from '../KubbFile.ts'\n\n/**\n * Provides app-level metadata and lifecycle hooks (like `exit`) to\n * components and composables within a Fabric runtime.\n */\nexport const FileContext = createContext<KubbFile.ResolvedFile | null>(null)\n","import { FileContext } from '../contexts/FileContext.ts'\nimport type * as KubbFile from '../KubbFile.ts'\nimport { useContext } from './useContext.ts'\n\n/**\n * `useFile` will return the current FileCollector for registering files.\n *\n * Throws when no FileCollector is present in context â€” ensure a Fabric that\n * provides a FileCollector is mounted before calling this hook.\n */\nexport function useFile(): KubbFile.ResolvedFile | null {\n  return useContext(FileContext)\n}\n","import { RootContext } from '../contexts/RootContext.ts'\nimport type { FileManager } from '../FileManager.ts'\nimport { useContext } from './useContext.ts'\n\nexport function useFileManager(): FileManager {\n  const { fileManager } = useContext(RootContext)\n\n  return fileManager\n}\n","import { useFile } from '../composables/useFile.ts'\nimport { useFileManager } from '../composables/useFileManager.ts'\nimport { useNodeTree } from '../composables/useNodeTree.ts'\nimport { provide } from '../context.ts'\nimport { FileContext } from '../contexts/FileContext.ts'\nimport { NodeTreeContext } from '../contexts/NodeTreeContext.ts'\nimport { type ComponentBuilder, createComponent } from '../createComponent.ts'\nimport type { FabricNode } from '../Fabric.ts'\nimport { renderIntrinsic } from '../intrinsic.ts'\nimport { createExport, createImport, print } from '../parsers/typescriptParser.ts'\nimport type { KubbFile } from '../types.ts'\n\nexport type FileProps<TMeta extends object = object> = {\n  /**\n   * Name to be used to dynamically create the baseName(based on input.path).\n   * Based on UNIX basename\n   * @link https://nodejs.org/api/path.html#pathbasenamepath-suffix\n   */\n  baseName: KubbFile.BaseName\n  /**\n   * Path will be full qualified path to a specified file.\n   */\n  path: KubbFile.Path\n  meta?: TMeta\n  banner?: string\n  footer?: string\n  /**\n   * Children nodes.\n   */\n  children?: FabricNode\n}\n\n/**\n * Adds files to the FileManager\n */\nexport const File = createComponent('File', ({ children, ...props }: FileProps) => {\n  const { baseName, path, meta = {}, footer, banner } = props\n\n  const fileManager = useFileManager()\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'File', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  const file: KubbFile.File = {\n    baseName,\n    path,\n    meta,\n    banner,\n    footer,\n    sources: [],\n    imports: [],\n    exports: [],\n  }\n\n  const [resolvedFile] = fileManager.add(file)\n  provide(FileContext, resolvedFile)\n\n  return children\n}) as ComponentBuilder<FileProps<object>> & { Source: typeof FileSource; Import: typeof FileImport; Export: typeof FileExport }\n\ntype FileSourceProps = Omit<KubbFile.Source, 'value'> & {\n  /**\n   * Children nodes.\n   */\n  children?: FabricNode\n}\n\n/**\n * FileSource - for adding source code to a file\n *\n * Returns the provided children string so the fsx renderer can collect it.\n */\nexport const FileSource = createComponent('FileSource', ({ children, ...props }: FileSourceProps) => {\n  const { name, isExportable, isIndexable, isTypeOnly } = props\n\n  const nodeTree = useNodeTree()\n  const file = useFile()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'FileSource', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  const value = renderIntrinsic(children)\n\n  if (file) {\n    file.sources.push({\n      name,\n      isExportable,\n      isIndexable,\n      isTypeOnly,\n      value,\n    })\n  }\n\n  return value\n})\n\nexport type FileExportProps = KubbFile.Export\n\n/**\n * FileExport - for adding exports to a file\n *\n * No-op function used by renderers to record exports.\n */\nexport const FileExport = createComponent('FileExport', (props: FileExportProps) => {\n  const { name, path, isTypeOnly, asAlias } = props\n\n  const nodeTree = useNodeTree()\n  const file = useFile()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'FileExport', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  if (file) {\n    file.exports.push({\n      name,\n      path,\n      asAlias,\n      isTypeOnly,\n    })\n  }\n\n  return print(createExport({ name, path, isTypeOnly, asAlias }))\n})\n\nexport type FileImportProps = KubbFile.Import\n\n/**\n * FileImport - for adding imports to a file\n *\n * No-op function used by renderers to record imports.\n */\nexport const FileImport = createComponent('FileImport', (props: FileImportProps) => {\n  const { name, path, root, isNameSpace, isTypeOnly } = props\n\n  const nodeTree = useNodeTree()\n  const file = useFile()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'FileImport', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  if (file) {\n    file.imports.push({\n      name,\n      path,\n      root,\n      isNameSpace,\n      isTypeOnly,\n    })\n  }\n\n  return print(createImport({ name, path, root, isNameSpace, isTypeOnly }))\n})\n\nFile.Source = FileSource\nFile.Import = FileImport\nFile.Export = FileExport\n","import { createComponent } from '../createComponent.ts'\nimport { createIntrinsic } from '../intrinsic.ts'\n\nexport const Indent = createComponent('indent', () => {\n  return createIntrinsic('indent')\n})\nIndent.displayName = 'Indent'\n","import { useNodeTree } from '../composables/useNodeTree.ts'\nimport { provide } from '../context.ts'\nimport { NodeTreeContext } from '../contexts/NodeTreeContext.ts'\nimport { type ComponentBuilder, createComponent } from '../createComponent.ts'\nimport type { FabricNode } from '../Fabric.ts'\nimport type { JSDoc } from '../types.ts'\nimport { createJSDoc } from '../utils/createJSDoc.ts'\nimport { Br } from './Br.ts'\nimport { Dedent } from './Dedent.ts'\nimport { Indent } from './Indent.ts'\n\ntype FunctionProps = {\n  /**\n   * Name of the function.\n   */\n  name: string\n  /**\n   * Add default when export is being used\n   */\n  default?: boolean\n  /**\n   * Parameters/options/props that need to be used.\n   */\n  params?: string\n  /**\n   * Does this function need to be exported.\n   */\n  export?: boolean\n  /**\n   * Does the function has async/promise behaviour.\n   * This will also add `Promise<returnType>` as the returnType.\n   */\n  async?: boolean\n  /**\n   * Generics that needs to be added for TypeScript.\n   */\n  generics?: string | string[]\n  /**\n   * ReturnType(see async for adding Promise type).\n   */\n  returnType?: string\n  /**\n   * Options for JSdocs.\n   */\n  JSDoc?: JSDoc\n  /**\n   * Children nodes.\n   */\n  children?: FabricNode\n}\n\n/**\n * Generates a TypeScript function declaration.\n */\nexport const Function = createComponent('Function', ({ children, ...props }: FunctionProps) => {\n  const { name, default: isDefault, export: canExport, async, generics, params, returnType, JSDoc } = props\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'Function', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  const parts: string[] = []\n\n  if (JSDoc?.comments) {\n    parts.push(createJSDoc({ comments: JSDoc.comments }))\n    parts.push('\\n')\n  }\n\n  if (canExport) {\n    parts.push('export ')\n  }\n\n  if (isDefault) {\n    parts.push('default ')\n  }\n\n  if (async) {\n    parts.push('async ')\n  }\n\n  parts.push(`function ${name}`)\n\n  if (generics) {\n    parts.push('<')\n    parts.push(Array.isArray(generics) ? generics.join(', ').trim() : generics)\n    parts.push('>')\n  }\n\n  parts.push(`(${params || ''})`)\n\n  if (returnType && !async) {\n    parts.push(`: ${returnType}`)\n  }\n\n  if (returnType && async) {\n    parts.push(`: Promise<${returnType}>`)\n  }\n\n  parts.push(' {')\n\n  if (children) {\n    return [parts.join(''), Br(), Indent(), children, Br(), Dedent(), '}']\n  }\n\n  return [parts.join(''), '}']\n}) as ComponentBuilder<FunctionProps> & { Arrow: typeof ArrowFunction }\n\nFunction.displayName = 'KubbFunction'\n\ntype ArrowFunctionProps = FunctionProps & {\n  /**\n   * Create Arrow function in one line\n   */\n  singleLine?: boolean\n}\n\n/**\n * ArrowFunction\n *\n * Builds an arrow function declaration string for the fsx renderer. Supports\n * the same options as `Function`. Use `singleLine` to produce a one-line\n * arrow expression.\n */\nconst ArrowFunction = createComponent('ArrowFunction', ({ children, ...props }: ArrowFunctionProps) => {\n  const { name, default: isDefault, export: canExport, async, generics, params, returnType, JSDoc, singleLine } = props\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'ArrowFunction', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  const parts: string[] = []\n\n  if (JSDoc?.comments) {\n    parts.push(createJSDoc({ comments: JSDoc.comments }))\n    parts.push('\\n')\n  }\n\n  if (canExport) {\n    parts.push('export ')\n  }\n\n  if (isDefault) {\n    parts.push('default ')\n  }\n\n  parts.push(`const ${name} = `)\n\n  if (async) {\n    parts.push('async ')\n  }\n\n  if (generics) {\n    parts.push('<')\n    parts.push(Array.isArray(generics) ? generics.join(', ').trim() : generics)\n    parts.push('>')\n  }\n\n  parts.push(`(${params || ''})`)\n\n  if (returnType && !async) {\n    parts.push(`: ${returnType}`)\n  }\n\n  if (returnType && async) {\n    parts.push(`: Promise<${returnType}>`)\n  }\n\n  if (singleLine) {\n    parts.push(` => ${children || ''}\\n`)\n    return parts.join('')\n  }\n\n  if (children) {\n    return [parts.join(''), ' => {', Br(), Indent(), children, Br(), Dedent(), '}']\n  }\n\n  return [parts.join(''), ' => {}']\n})\n\nArrowFunction.displayName = 'KubbArrowFunction'\nFunction.Arrow = ArrowFunction\n","import { useNodeTree } from '../composables/useNodeTree.ts'\nimport { provide } from '../context.ts'\nimport { NodeTreeContext } from '../contexts/NodeTreeContext.ts'\nimport { createComponent } from '../createComponent.ts'\nimport type { FabricNode } from '../Fabric.ts'\nimport type { JSDoc } from '../types.ts'\nimport { createJSDoc } from '../utils/createJSDoc.ts'\n\nexport type TypeProps = {\n  /**\n   * Name of the type, this needs to start with a capital letter.\n   */\n  name: string\n  /**\n   * Does this type need to be exported.\n   */\n  export?: boolean\n  /**\n   * Options for JSdocs.\n   */\n  JSDoc?: JSDoc\n  /**\n   * Children nodes.\n   */\n  children?: FabricNode\n}\n\n/**\n * Generates a TypeScript type declaration.\n */\nexport const Type = createComponent('Type', ({ children, ...props }: TypeProps) => {\n  const { name, export: canExport, JSDoc } = props\n\n  const nodeTree = useNodeTree()\n\n  if (nodeTree) {\n    const childTree = nodeTree.addChild({ type: 'Type', props })\n\n    provide(NodeTreeContext, childTree)\n  }\n\n  if (name.charAt(0).toUpperCase() !== name.charAt(0)) {\n    throw new Error('Name should start with a capital letter (see TypeScript types)')\n  }\n\n  let result = ''\n\n  if (JSDoc?.comments) {\n    result += createJSDoc({ comments: JSDoc.comments })\n    result += '\\n'\n  }\n\n  if (canExport) {\n    result += 'export '\n  }\n\n  result += `type ${name} = ${children || ''}`\n\n  return result\n})\n\nType.displayName = 'KubbType'\n","import { AppContext, type AppContextProps } from '../contexts/AppContext.ts'\nimport { useContext } from './useContext.ts'\n\n/**\n * `useApp` will return the current App with meta and exit function.\n *\n * Throws an error when there is no AppContext available.\n */\nexport function useApp<TMeta extends object = object>(): AppContextProps<TMeta> {\n  return useContext(AppContext) as AppContextProps<TMeta>\n}\n","import { RootContext } from '../contexts/RootContext.ts'\nimport { useContext } from './useContext.ts'\n\n/**\n * `useLifecycle` will return some helpers to exit/restart the generation.\n *\n * This hook reads the RootContext and exposes lifecycle helpers (like `exit`)\n * for consumers to programmatically stop generation or perform teardown.\n */\nexport function useLifecycle() {\n  const { exit } = useContext(RootContext)\n\n  return {\n    exit,\n  }\n}\n","import { isFunction } from 'remeda'\nimport type { Fabric, FabricConfig, FabricContext, FabricEvents, FabricOptions } from './Fabric.ts'\nimport { FileManager } from './FileManager.ts'\nimport type * as KubbFile from './KubbFile.ts'\nimport type { Parser } from './parsers/types.ts'\nimport type { Plugin } from './plugins/types.ts'\nimport { AsyncEventEmitter } from './utils/AsyncEventEmitter.ts'\n\n/**\n * Creates a new Fabric instance\n *\n * @example\n * const fabric = createFabric()\n * fabric.use(myPlugin())\n */\nexport function createFabric<T extends FabricOptions>(config: FabricConfig<T> = { mode: 'sequential' } as FabricConfig<T>): Fabric<T> {\n  const events = new AsyncEventEmitter<FabricEvents>()\n  const installedPlugins = new Set<Plugin<any>>()\n  const installedParsers = new Map<KubbFile.Extname, Parser<any>>()\n  const installedParserNames = new Set<string>()\n  const fileManager = new FileManager({ events })\n\n  const context: FabricContext<T> = {\n    get files() {\n      return fileManager.files\n    },\n    async addFile(...files) {\n      await fileManager.add(...files)\n    },\n    config,\n    fileManager,\n    installedPlugins,\n    installedParsers,\n    on: events.on.bind(events),\n    off: events.off.bind(events),\n    onOnce: events.onOnce.bind(events),\n    removeAll: events.removeAll.bind(events),\n    emit: events.emit.bind(events),\n  } as FabricContext<T>\n\n  const fabric: Fabric<T> = {\n    context,\n    get files() {\n      return fileManager.files\n    },\n    async addFile(...files) {\n      await fileManager.add(...files)\n    },\n    async upsertFile(...files) {\n      await fileManager.upsert(...files)\n    },\n    async use(pluginOrParser, ...options) {\n      if (pluginOrParser.type === 'plugin') {\n        if (installedPlugins.has(pluginOrParser)) {\n          console.warn(`Plugin \"${pluginOrParser.name}\" already applied.`)\n        } else {\n          installedPlugins.add(pluginOrParser)\n        }\n\n        if (isFunction(pluginOrParser.inject)) {\n          const injecter = pluginOrParser.inject\n\n          const injected = (injecter as any)(context, ...options)\n          Object.assign(fabric, injected)\n        }\n      }\n\n      if (pluginOrParser.type === 'parser') {\n        if (installedParserNames.has(pluginOrParser.name)) {\n          console.warn(`Parser \"${pluginOrParser.name}\" already applied.`)\n        } else {\n          installedParserNames.add(pluginOrParser.name)\n        }\n\n        if (pluginOrParser.extNames) {\n          for (const extName of pluginOrParser.extNames) {\n            const existing = installedParsers.get(extName)\n            if (existing && existing.name !== pluginOrParser.name) {\n              console.warn(`Parser \"${pluginOrParser.name}\" is overriding parser \"${existing.name}\" for extension \"${extName}\".`)\n            }\n            installedParsers.set(extName, pluginOrParser)\n          }\n        }\n      }\n\n      if (isFunction(pluginOrParser.install)) {\n        const installer = pluginOrParser.install\n\n        await (installer as any)(context, ...options)\n      }\n\n      return fabric\n    },\n  } as Fabric<T>\n\n  return fabric\n}\n"],"mappings":"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"}