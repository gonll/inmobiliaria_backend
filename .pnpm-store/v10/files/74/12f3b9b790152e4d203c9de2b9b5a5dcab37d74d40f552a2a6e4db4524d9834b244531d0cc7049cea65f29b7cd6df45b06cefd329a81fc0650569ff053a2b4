{"version":3,"file":"getBarrelFiles-p2qZTkRB.cjs","names":["#head","#tail","#size","#options","path","#plugins","#usedPluginNames","#promiseManager","#parse","#getSortedPlugins","trim","transformReservedWord","#execute","#executeSync","performance","#emitter","NodeEventEmitter","path","#options","isValidVarName","camelCase","#cachedLeaves","item","getRelativePath"],"sources":["../src/errors.ts","../../../node_modules/.pnpm/yocto-queue@1.2.2/node_modules/yocto-queue/index.js","../../../node_modules/.pnpm/p-limit@7.2.0/node_modules/p-limit/index.js","../src/utils/executeStrategies.ts","../src/PromiseManager.ts","../src/utils/uniqueName.ts","../src/PluginManager.ts","../src/utils/AsyncEventEmitter.ts","../src/utils/formatHrtime.ts","../src/utils/URLPath.ts","../src/utils/TreeNode.ts","../src/BarrelManager.ts","../src/utils/getBarrelFiles.ts"],"sourcesContent":["export class ValidationPluginError extends Error {}\n\nexport class BuildError extends Error {\n  cause: Error | undefined\n  errors: Array<Error>\n\n  constructor(message: string, options: { cause?: Error; errors: Array<Error> }) {\n    super(message, { cause: options.cause })\n\n    this.name = 'BuildError'\n    this.cause = options.cause\n    this.errors = options.errors\n  }\n}\n","/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\n\nclass Node {\n\tvalue;\n\tnext;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n}\n\nexport default class Queue {\n\t#head;\n\t#tail;\n\t#size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this.#head) {\n\t\t\tthis.#tail.next = node;\n\t\t\tthis.#tail = node;\n\t\t} else {\n\t\t\tthis.#head = node;\n\t\t\tthis.#tail = node;\n\t\t}\n\n\t\tthis.#size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this.#head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#head = this.#head.next;\n\t\tthis.#size--;\n\n\t\t// Clean up tail reference when queue becomes empty\n\t\tif (!this.#head) {\n\t\t\tthis.#tail = undefined;\n\t\t}\n\n\t\treturn current.value;\n\t}\n\n\tpeek() {\n\t\tif (!this.#head) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn this.#head.value;\n\n\t\t// TODO: Node.js 18.\n\t\t// return this.#head?.value;\n\t}\n\n\tclear() {\n\t\tthis.#head = undefined;\n\t\tthis.#tail = undefined;\n\t\tthis.#size = 0;\n\t}\n\n\tget size() {\n\t\treturn this.#size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this.#head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n\n\t* drain() {\n\t\twhile (this.#head) {\n\t\t\tyield this.dequeue();\n\t\t}\n\t}\n}\n","import Queue from 'yocto-queue';\n\nexport default function pLimit(concurrency) {\n\tvalidateConcurrency(concurrency);\n\n\tconst queue = new Queue();\n\tlet activeCount = 0;\n\n\tconst resumeNext = () => {\n\t\t// Process the next queued function if we're under the concurrency limit\n\t\tif (activeCount < concurrency && queue.size > 0) {\n\t\t\tactiveCount++;\n\t\t\tqueue.dequeue()();\n\t\t}\n\t};\n\n\tconst next = () => {\n\t\tactiveCount--;\n\t\tresumeNext();\n\t};\n\n\tconst run = async (function_, resolve, arguments_) => {\n\t\t// Execute the function and capture the result promise\n\t\tconst result = (async () => function_(...arguments_))();\n\n\t\t// Resolve immediately with the promise (don't wait for completion)\n\t\tresolve(result);\n\n\t\t// Wait for the function to complete (success or failure)\n\t\t// We catch errors here to prevent unhandled rejections,\n\t\t// but the original promise rejection is preserved for the caller\n\t\ttry {\n\t\t\tawait result;\n\t\t} catch {}\n\n\t\t// Decrement active count and process next queued function\n\t\tnext();\n\t};\n\n\tconst enqueue = (function_, resolve, arguments_) => {\n\t\t// Queue the internal resolve function instead of the run function\n\t\t// to preserve the asynchronous execution context.\n\t\tnew Promise(internalResolve => { // eslint-disable-line promise/param-names\n\t\t\tqueue.enqueue(internalResolve);\n\t\t}).then(run.bind(undefined, function_, resolve, arguments_)); // eslint-disable-line promise/prefer-await-to-then\n\n\t\t// Start processing immediately if we haven't reached the concurrency limit\n\t\tif (activeCount < concurrency) {\n\t\t\tresumeNext();\n\t\t}\n\t};\n\n\tconst generator = (function_, ...arguments_) => new Promise(resolve => {\n\t\tenqueue(function_, resolve, arguments_);\n\t});\n\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount,\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.size,\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue() {\n\t\t\t\tqueue.clear();\n\t\t\t},\n\t\t},\n\t\tconcurrency: {\n\t\t\tget: () => concurrency,\n\n\t\t\tset(newConcurrency) {\n\t\t\t\tvalidateConcurrency(newConcurrency);\n\t\t\t\tconcurrency = newConcurrency;\n\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\t// eslint-disable-next-line no-unmodified-loop-condition\n\t\t\t\t\twhile (activeCount < concurrency && queue.size > 0) {\n\t\t\t\t\t\tresumeNext();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t},\n\t\tmap: {\n\t\t\tasync value(iterable, function_) {\n\t\t\t\tconst promises = Array.from(iterable, (value, index) => this(function_, value, index));\n\t\t\t\treturn Promise.all(promises);\n\t\t\t},\n\t\t},\n\t});\n\n\treturn generator;\n}\n\nexport function limitFunction(function_, options) {\n\tconst {concurrency} = options;\n\tconst limit = pLimit(concurrency);\n\n\treturn (...arguments_) => limit(() => function_(...arguments_));\n}\n\nfunction validateConcurrency(concurrency) {\n\tif (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n}\n","import pLimit from 'p-limit'\n\ntype PromiseFunc<T = unknown, T2 = never> = (state?: T) => T2 extends never ? Promise<T> : Promise<T> | T2\n\ntype ValueOfPromiseFuncArray<TInput extends Array<unknown>> = TInput extends Array<PromiseFunc<infer X, infer Y>> ? X | Y : never\n\ntype SeqOutput<TInput extends Array<PromiseFunc<TValue, null>>, TValue> = Promise<Array<Awaited<ValueOfPromiseFuncArray<TInput>>>>\n\n/**\n * Chains promises\n */\nexport function hookSeq<TInput extends Array<PromiseFunc<TValue, null>>, TValue, TOutput = SeqOutput<TInput, TValue>>(promises: TInput): TOutput {\n  return promises.filter(Boolean).reduce(\n    (promise, func) => {\n      if (typeof func !== 'function') {\n        throw new Error('HookSeq needs a function that returns a promise `() => Promise<unknown>`')\n      }\n\n      return promise.then((state) => {\n        const calledFunc = func(state as TValue)\n\n        if (calledFunc) {\n          return calledFunc.then(Array.prototype.concat.bind(state))\n        }\n      })\n    },\n    Promise.resolve([] as unknown),\n  ) as TOutput\n}\n\ntype HookFirstOutput<TInput extends Array<PromiseFunc<TValue, null>>, TValue = unknown> = ValueOfPromiseFuncArray<TInput>\n\n/**\n * Chains promises, first non-null result stops and returns\n */\nexport function hookFirst<TInput extends Array<PromiseFunc<TValue, null>>, TValue = unknown, TOutput = HookFirstOutput<TInput, TValue>>(\n  promises: TInput,\n  nullCheck = (state: any) => state !== null,\n): TOutput {\n  let promise: Promise<unknown> = Promise.resolve(null) as Promise<unknown>\n\n  for (const func of promises.filter(Boolean)) {\n    promise = promise.then((state) => {\n      if (nullCheck(state)) {\n        return state\n      }\n\n      return func(state as TValue)\n    })\n  }\n\n  return promise as TOutput\n}\n\ntype HookParallelOutput<TInput extends Array<PromiseFunc<TValue, null>>, TValue> = Promise<PromiseSettledResult<Awaited<ValueOfPromiseFuncArray<TInput>>>[]>\n\n/**\n * Runs an array of promise functions with optional concurrency limit.\n */\nexport function hookParallel<TInput extends Array<PromiseFunc<TValue, null>>, TValue = unknown, TOutput = HookParallelOutput<TInput, TValue>>(\n  promises: TInput,\n  concurrency: number = Number.POSITIVE_INFINITY,\n): TOutput {\n  const limit = pLimit(concurrency)\n\n  const tasks = promises.filter(Boolean).map((promise) => limit(() => promise()))\n\n  return Promise.allSettled(tasks) as TOutput\n}\n\nexport type Strategy = 'seq' | 'first' | 'parallel'\n\nexport type StrategySwitch<TStrategy extends Strategy, TInput extends Array<PromiseFunc<TValue, null>>, TValue> = TStrategy extends 'first'\n  ? HookFirstOutput<TInput, TValue>\n  : TStrategy extends 'seq'\n    ? SeqOutput<TInput, TValue>\n    : TStrategy extends 'parallel'\n      ? HookParallelOutput<TInput, TValue>\n      : never\n","import type { Strategy, StrategySwitch } from './utils/executeStrategies.ts'\nimport { hookFirst, hookParallel, hookSeq } from './utils/executeStrategies.ts'\n\ntype PromiseFunc<T = unknown, T2 = never> = () => T2 extends never ? Promise<T> : Promise<T> | T2\n\ntype Options<TState = any> = {\n  nullCheck?: (state: TState) => boolean\n}\n\nexport class PromiseManager<TState = any> {\n  #options: Options<TState> = {}\n\n  constructor(options: Options<TState> = {}) {\n    this.#options = options\n\n    return this\n  }\n\n  run<TInput extends Array<PromiseFunc<TValue, null>>, TValue, TStrategy extends Strategy, TOutput = StrategySwitch<TStrategy, TInput, TValue>>(\n    strategy: TStrategy,\n    promises: TInput,\n    { concurrency = Number.POSITIVE_INFINITY }: { concurrency?: number } = {},\n  ): TOutput {\n    if (strategy === 'seq') {\n      return hookSeq<TInput, TValue, TOutput>(promises)\n    }\n\n    if (strategy === 'first') {\n      return hookFirst<TInput, TValue, TOutput>(promises, this.#options.nullCheck)\n    }\n\n    if (strategy === 'parallel') {\n      return hookParallel<TInput, TValue, TOutput>(promises, concurrency)\n    }\n\n    throw new Error(`${strategy} not implemented`)\n  }\n}\n\nexport function isPromiseRejectedResult<T>(result: PromiseSettledResult<unknown>): result is Omit<PromiseRejectedResult, 'reason'> & { reason: T } {\n  return result.status === 'rejected'\n}\n","export function getUniqueName(originalName: string, data: Record<string, number>): string {\n  let used = data[originalName] || 0\n  if (used) {\n    data[originalName] = ++used\n    originalName += used\n  }\n  data[originalName] = 1\n  return originalName\n}\n\nexport function setUniqueName(originalName: string, data: Record<string, number>): string {\n  let used = data[originalName] || 0\n  if (used) {\n    data[originalName] = ++used\n\n    return originalName\n  }\n  data[originalName] = 1\n  return originalName\n}\n","import path from 'node:path'\nimport { performance } from 'node:perf_hooks'\nimport type { KubbFile } from '@kubb/fabric-core/types'\nimport type { Fabric } from '@kubb/react-fabric'\nimport { ValidationPluginError } from './errors.ts'\nimport { isPromiseRejectedResult, PromiseManager } from './PromiseManager.ts'\nimport { transformReservedWord } from './transformers/transformReservedWord.ts'\nimport { trim } from './transformers/trim.ts'\nimport type {\n  Config,\n  GetPluginFactoryOptions,\n  KubbEvents,\n  Plugin,\n  PluginContext,\n  PluginFactoryOptions,\n  PluginLifecycle,\n  PluginLifecycleHooks,\n  PluginParameter,\n  PluginWithLifeCycle,\n  ResolveNameParams,\n  ResolvePathParams,\n  UserPlugin,\n} from './types.ts'\nimport type { AsyncEventEmitter } from './utils/AsyncEventEmitter.ts'\nimport { setUniqueName } from './utils/uniqueName.ts'\n\ntype RequiredPluginLifecycle = Required<PluginLifecycle>\n\nexport type Strategy = 'hookFirst' | 'hookForPlugin' | 'hookParallel' | 'hookSeq'\n\ntype ParseResult<H extends PluginLifecycleHooks> = RequiredPluginLifecycle[H]\n\ntype SafeParseResult<H extends PluginLifecycleHooks, Result = ReturnType<ParseResult<H>>> = {\n  result: Result\n  plugin: Plugin\n}\n\n// inspired by: https://github.com/rollup/rollup/blob/master/src/utils/PluginDriver.ts#\n\ntype Options = {\n  fabric: Fabric\n  events: AsyncEventEmitter<KubbEvents>\n  /**\n   * @default Number.POSITIVE_INFINITY\n   */\n  concurrency?: number\n}\n\ntype GetFileProps<TOptions = object> = {\n  name: string\n  mode?: KubbFile.Mode\n  extname: KubbFile.Extname\n  pluginKey: Plugin['key']\n  options?: TOptions\n}\n\nexport function getMode(fileOrFolder: string | undefined | null): KubbFile.Mode {\n  if (!fileOrFolder) {\n    return 'split'\n  }\n  return path.extname(fileOrFolder) ? 'single' : 'split'\n}\n\nexport class PluginManager {\n  readonly config: Config\n  readonly options: Options\n\n  readonly #plugins = new Set<Plugin<GetPluginFactoryOptions<any>>>()\n  readonly #usedPluginNames: Record<string, number> = {}\n  readonly #promiseManager: PromiseManager\n\n  constructor(config: Config, options: Options) {\n    this.config = config\n    this.options = options\n    this.#promiseManager = new PromiseManager({\n      nullCheck: (state: SafeParseResult<'resolveName'> | null) => !!state?.result,\n    })\n    ;[...(config.plugins || [])].forEach((plugin) => {\n      const parsedPlugin = this.#parse(plugin as UserPlugin)\n\n      this.#plugins.add(parsedPlugin)\n    })\n\n    return this\n  }\n\n  get events() {\n    return this.options.events\n  }\n\n  getContext<TOptions extends PluginFactoryOptions>(plugin: Plugin<TOptions>): PluginContext<TOptions> & Record<string, any> {\n    const plugins = [...this.#plugins]\n    const baseContext = {\n      fabric: this.options.fabric,\n      config: this.config,\n      plugin,\n      events: this.options.events,\n      pluginManager: this,\n      mode: getMode(path.resolve(this.config.root, this.config.output.path)),\n      addFile: async (...files: Array<KubbFile.File>) => {\n        await this.options.fabric.addFile(...files)\n      },\n      upsertFile: async (...files: Array<KubbFile.File>) => {\n        await this.options.fabric.upsertFile(...files)\n      },\n    } as unknown as PluginContext<TOptions>\n\n    const mergedExtras: Record<string, any> = {}\n    for (const p of plugins) {\n      if (typeof p.inject === 'function') {\n        const injector = p.inject.bind(baseContext as any) as any\n\n        const result = injector(baseContext)\n        if (result && typeof result === 'object') {\n          Object.assign(mergedExtras, result)\n        }\n      }\n    }\n\n    return {\n      ...baseContext,\n      ...mergedExtras,\n    }\n  }\n\n  get plugins(): Array<Plugin> {\n    return this.#getSortedPlugins()\n  }\n\n  getFile<TOptions = object>({ name, mode, extname, pluginKey, options }: GetFileProps<TOptions>): KubbFile.File<{ pluginKey: Plugin['key'] }> {\n    const baseName = `${name}${extname}` as const\n    const path = this.resolvePath({ baseName, mode, pluginKey, options })\n\n    if (!path) {\n      throw new Error(`Filepath should be defined for resolvedName \"${name}\" and pluginKey [${JSON.stringify(pluginKey)}]`)\n    }\n\n    return {\n      path,\n      baseName,\n      meta: {\n        pluginKey,\n      },\n      sources: [],\n      imports: [],\n      exports: [],\n    }\n  }\n\n  resolvePath = <TOptions = object>(params: ResolvePathParams<TOptions>): KubbFile.Path => {\n    const root = path.resolve(this.config.root, this.config.output.path)\n    const defaultPath = path.resolve(root, params.baseName)\n\n    if (params.pluginKey) {\n      const paths = this.hookForPluginSync({\n        pluginKey: params.pluginKey,\n        hookName: 'resolvePath',\n        parameters: [params.baseName, params.mode, params.options as object],\n      })\n\n      return paths?.at(0) || defaultPath\n    }\n\n    const firstResult = this.hookFirstSync({\n      hookName: 'resolvePath',\n      parameters: [params.baseName, params.mode, params.options as object],\n    })\n\n    return firstResult?.result || defaultPath\n  }\n  //TODO refactor by using the order of plugins and the cache of the fileManager instead of guessing and recreating the name/path\n  resolveName = (params: ResolveNameParams): string => {\n    if (params.pluginKey) {\n      const names = this.hookForPluginSync({\n        pluginKey: params.pluginKey,\n        hookName: 'resolveName',\n        parameters: [trim(params.name), params.type],\n      })\n\n      const uniqueNames = new Set(names)\n\n      return transformReservedWord([...uniqueNames].at(0) || params.name)\n    }\n\n    const name = this.hookFirstSync({\n      hookName: 'resolveName',\n      parameters: [trim(params.name), params.type],\n    }).result\n\n    return transformReservedWord(name)\n  }\n\n  /**\n   * Run a specific hookName for plugin x.\n   */\n  async hookForPlugin<H extends PluginLifecycleHooks>({\n    pluginKey,\n    hookName,\n    parameters,\n  }: {\n    pluginKey: Plugin['key']\n    hookName: H\n    parameters: PluginParameter<H>\n  }): Promise<Array<ReturnType<ParseResult<H>> | null>> {\n    const plugins = this.getPluginsByKey(hookName, pluginKey)\n\n    this.events.emit('plugins:hook:progress:start', {\n      hookName,\n      plugins,\n    })\n\n    const items: Array<ReturnType<ParseResult<H>>> = []\n\n    for (const plugin of plugins) {\n      const result = await this.#execute<H>({\n        strategy: 'hookFirst',\n        hookName,\n        parameters,\n        plugin,\n      })\n\n      if (result !== undefined && result !== null) {\n        items.push(result)\n      }\n    }\n\n    this.events.emit('plugins:hook:progress:end', { hookName })\n\n    return items\n  }\n  /**\n   * Run a specific hookName for plugin x.\n   */\n\n  hookForPluginSync<H extends PluginLifecycleHooks>({\n    pluginKey,\n    hookName,\n    parameters,\n  }: {\n    pluginKey: Plugin['key']\n    hookName: H\n    parameters: PluginParameter<H>\n  }): Array<ReturnType<ParseResult<H>>> | null {\n    const plugins = this.getPluginsByKey(hookName, pluginKey)\n\n    const result = plugins\n      .map((plugin) => {\n        return this.#executeSync<H>({\n          strategy: 'hookFirst',\n          hookName,\n          parameters,\n          plugin,\n        })\n      })\n      .filter(Boolean)\n\n    return result\n  }\n\n  /**\n   * Returns the first non-null result.\n   */\n  async hookFirst<H extends PluginLifecycleHooks>({\n    hookName,\n    parameters,\n    skipped,\n  }: {\n    hookName: H\n    parameters: PluginParameter<H>\n    skipped?: ReadonlySet<Plugin> | null\n  }): Promise<SafeParseResult<H>> {\n    const plugins = this.#getSortedPlugins(hookName).filter((plugin) => {\n      return skipped ? skipped.has(plugin) : true\n    })\n\n    this.events.emit('plugins:hook:progress:start', { hookName, plugins })\n\n    const promises = plugins.map((plugin) => {\n      return async () => {\n        const value = await this.#execute<H>({\n          strategy: 'hookFirst',\n          hookName,\n          parameters,\n          plugin,\n        })\n\n        return Promise.resolve({\n          plugin,\n          result: value,\n        } as SafeParseResult<H>)\n      }\n    })\n\n    const result = await this.#promiseManager.run('first', promises)\n\n    this.events.emit('plugins:hook:progress:end', { hookName })\n\n    return result\n  }\n\n  /**\n   * Returns the first non-null result.\n   */\n  hookFirstSync<H extends PluginLifecycleHooks>({\n    hookName,\n    parameters,\n    skipped,\n  }: {\n    hookName: H\n    parameters: PluginParameter<H>\n    skipped?: ReadonlySet<Plugin> | null\n  }): SafeParseResult<H> {\n    let parseResult: SafeParseResult<H> = null as unknown as SafeParseResult<H>\n    const plugins = this.#getSortedPlugins(hookName).filter((plugin) => {\n      return skipped ? skipped.has(plugin) : true\n    })\n\n    for (const plugin of plugins) {\n      parseResult = {\n        result: this.#executeSync<H>({\n          strategy: 'hookFirst',\n          hookName,\n          parameters,\n          plugin,\n        }),\n        plugin,\n      } as SafeParseResult<H>\n\n      if (parseResult?.result != null) {\n        break\n      }\n    }\n\n    return parseResult\n  }\n\n  /**\n   * Runs all plugins in parallel based on `this.plugin` order and `pre`/`post` settings.\n   */\n  async hookParallel<H extends PluginLifecycleHooks, TOutput = void>({\n    hookName,\n    parameters,\n  }: {\n    hookName: H\n    parameters?: Parameters<RequiredPluginLifecycle[H]> | undefined\n  }): Promise<Awaited<TOutput>[]> {\n    const plugins = this.#getSortedPlugins(hookName)\n    this.events.emit('plugins:hook:progress:start', { hookName, plugins })\n\n    const promises = plugins.map((plugin) => {\n      return () =>\n        this.#execute({\n          strategy: 'hookParallel',\n          hookName,\n          parameters,\n          plugin,\n        }) as Promise<TOutput>\n    })\n\n    const results = await this.#promiseManager.run('parallel', promises, {\n      concurrency: this.options.concurrency,\n    })\n\n    results.forEach((result, index) => {\n      if (isPromiseRejectedResult<Error>(result)) {\n        const plugin = this.#getSortedPlugins(hookName)[index]\n\n        if (plugin) {\n          this.events.emit('error', result.reason, {\n            plugin,\n            hookName,\n            strategy: 'hookParallel',\n            duration: 0,\n            parameters,\n          })\n        }\n      }\n    })\n\n    this.events.emit('plugins:hook:progress:end', { hookName })\n\n    return results.reduce((acc, result) => {\n      if (result.status === 'fulfilled') {\n        acc.push(result.value)\n      }\n      return acc\n    }, [] as Awaited<TOutput>[])\n  }\n\n  /**\n   * Chains plugins\n   */\n  async hookSeq<H extends PluginLifecycleHooks>({ hookName, parameters }: { hookName: H; parameters?: PluginParameter<H> }): Promise<void> {\n    const plugins = this.#getSortedPlugins(hookName)\n    this.events.emit('plugins:hook:progress:start', { hookName, plugins })\n\n    const promises = plugins.map((plugin) => {\n      return () =>\n        this.#execute({\n          strategy: 'hookSeq',\n          hookName,\n          parameters,\n          plugin,\n        })\n    })\n\n    await this.#promiseManager.run('seq', promises)\n\n    this.events.emit('plugins:hook:progress:end', { hookName })\n  }\n\n  #getSortedPlugins(hookName?: keyof PluginLifecycle): Array<Plugin> {\n    const plugins = [...this.#plugins]\n\n    if (hookName) {\n      return plugins.filter((plugin) => hookName in plugin)\n    }\n    // TODO add test case for sorting with pre/post\n\n    return plugins\n      .map((plugin) => {\n        if (plugin.pre) {\n          const missingPlugins = plugin.pre.filter((pluginName) => !plugins.find((pluginToFind) => pluginToFind.name === pluginName))\n\n          if (missingPlugins.length > 0) {\n            throw new ValidationPluginError(`The plugin '${plugin.name}' has a pre set that references missing plugins for '${missingPlugins.join(', ')}'`)\n          }\n        }\n\n        return plugin\n      })\n      .sort((a, b) => {\n        if (b.pre?.includes(a.name)) {\n          return 1\n        }\n        if (b.post?.includes(a.name)) {\n          return -1\n        }\n        return 0\n      })\n  }\n\n  getPluginByKey(pluginKey: Plugin['key']): Plugin | undefined {\n    const plugins = [...this.#plugins]\n    const [searchPluginName] = pluginKey\n\n    return plugins.find((item) => {\n      const [name] = item.key\n\n      return name === searchPluginName\n    })\n  }\n\n  getPluginsByKey(hookName: keyof PluginWithLifeCycle, pluginKey: Plugin['key']): Plugin[] {\n    const plugins = [...this.plugins]\n    const [searchPluginName, searchIdentifier] = pluginKey\n\n    const pluginByPluginName = plugins\n      .filter((plugin) => hookName in plugin)\n      .filter((item) => {\n        const [name, identifier] = item.key\n\n        const identifierCheck = identifier?.toString() === searchIdentifier?.toString()\n        const nameCheck = name === searchPluginName\n\n        if (searchIdentifier) {\n          return identifierCheck && nameCheck\n        }\n\n        return nameCheck\n      })\n\n    if (!pluginByPluginName?.length) {\n      // fallback on the core plugin when there is no match\n\n      const corePlugin = plugins.find((plugin) => plugin.name === 'core' && hookName in plugin)\n      // Removed noisy debug logs for missing hooks - these are expected behavior, not errors\n\n      return corePlugin ? [corePlugin] : []\n    }\n\n    return pluginByPluginName\n  }\n\n  /**\n   * Run an async plugin hook and return the result.\n   * @param hookName Name of the plugin hook. Must be either in `PluginHooks` or `OutputPluginValueHooks`.\n   * @param args Arguments passed to the plugin hook.\n   * @param plugin The actual pluginObject to run.\n   */\n  // Implementation signature\n  #execute<H extends PluginLifecycleHooks>({\n    strategy,\n    hookName,\n    parameters,\n    plugin,\n  }: {\n    strategy: Strategy\n    hookName: H\n    parameters: unknown[] | undefined\n    plugin: PluginWithLifeCycle\n  }): Promise<ReturnType<ParseResult<H>> | null> | null {\n    const hook = plugin[hookName]\n    let output: unknown\n\n    if (!hook) {\n      return null\n    }\n\n    this.events.emit('plugins:hook:processing:start', {\n      strategy,\n      hookName,\n      parameters,\n      plugin,\n    })\n\n    const startTime = performance.now()\n\n    const task = (async () => {\n      try {\n        if (typeof hook === 'function') {\n          const context = this.getContext(plugin)\n          const result = await Promise.resolve((hook as Function).apply(context, parameters))\n\n          output = result\n\n          this.events.emit('plugins:hook:processing:end', {\n            duration: Math.round(performance.now() - startTime),\n            parameters,\n            output,\n            strategy,\n            hookName,\n            plugin,\n          })\n\n          return result\n        }\n\n        output = hook\n\n        this.events.emit('plugins:hook:processing:end', {\n          duration: Math.round(performance.now() - startTime),\n          parameters,\n          output,\n          strategy,\n          hookName,\n          plugin,\n        })\n\n        return hook\n      } catch (error) {\n        this.events.emit('error', error as Error, {\n          plugin,\n          hookName,\n          strategy,\n          duration: Math.round(performance.now() - startTime),\n        })\n\n        return null\n      }\n    })()\n\n    return task\n  }\n\n  /**\n   * Run a sync plugin hook and return the result.\n   * @param hookName Name of the plugin hook. Must be in `PluginHooks`.\n   * @param args Arguments passed to the plugin hook.\n   * @param plugin The actual plugin\n   * @param replaceContext When passed, the plugin context can be overridden.\n   */\n  #executeSync<H extends PluginLifecycleHooks>({\n    strategy,\n    hookName,\n    parameters,\n    plugin,\n  }: {\n    strategy: Strategy\n    hookName: H\n    parameters: PluginParameter<H>\n    plugin: PluginWithLifeCycle\n  }): ReturnType<ParseResult<H>> | null {\n    const hook = plugin[hookName]\n    let output: unknown\n\n    if (!hook) {\n      return null\n    }\n\n    this.events.emit('plugins:hook:processing:start', {\n      strategy,\n      hookName,\n      parameters,\n      plugin,\n    })\n\n    const startTime = performance.now()\n\n    try {\n      if (typeof hook === 'function') {\n        const context = this.getContext(plugin)\n        const fn = (hook as Function).apply(context, parameters) as ReturnType<ParseResult<H>>\n\n        output = fn\n\n        this.events.emit('plugins:hook:processing:end', {\n          duration: Math.round(performance.now() - startTime),\n          parameters,\n          output,\n          strategy,\n          hookName,\n          plugin,\n        })\n\n        return fn\n      }\n\n      output = hook\n\n      this.events.emit('plugins:hook:processing:end', {\n        duration: Math.round(performance.now() - startTime),\n        parameters,\n        output,\n        strategy,\n        hookName,\n        plugin,\n      })\n\n      return hook\n    } catch (error) {\n      this.events.emit('error', error as Error, {\n        plugin,\n        hookName,\n        strategy,\n        duration: Math.round(performance.now() - startTime),\n      })\n\n      return null\n    }\n  }\n\n  #parse(plugin: UserPlugin): Plugin {\n    const usedPluginNames = this.#usedPluginNames\n\n    setUniqueName(plugin.name, usedPluginNames)\n\n    return {\n      install() {},\n      ...plugin,\n      key: [plugin.name, usedPluginNames[plugin.name]].filter(Boolean) as [typeof plugin.name, string],\n    } as unknown as Plugin\n  }\n}\n","import { EventEmitter as NodeEventEmitter } from 'node:events'\n\nexport class AsyncEventEmitter<TEvents extends Record<string, any>> {\n  constructor(maxListener = 100) {\n    this.#emitter.setMaxListeners(maxListener)\n  }\n  #emitter = new NodeEventEmitter()\n\n  async emit<TEventName extends keyof TEvents & string>(eventName: TEventName, ...eventArgs: TEvents[TEventName]): Promise<void> {\n    const listeners = this.#emitter.listeners(eventName) as Array<(...args: TEvents[TEventName]) => any>\n\n    if (listeners.length === 0) {\n      return undefined\n    }\n\n    await Promise.all(\n      listeners.map(async (listener) => {\n        try {\n          return await listener(...eventArgs)\n        } catch (err) {\n          const causedError = err as Error\n          const error = new Error(`Error in async listener for \"${eventName}\" with eventArgs \"${eventArgs}\"`, { cause: causedError })\n\n          throw error\n        }\n      }),\n    )\n  }\n\n  on<TEventName extends keyof TEvents & string>(eventName: TEventName, handler: (...eventArg: TEvents[TEventName]) => void): void {\n    this.#emitter.on(eventName, handler as any)\n  }\n\n  onOnce<TEventName extends keyof TEvents & string>(eventName: TEventName, handler: (...eventArgs: TEvents[TEventName]) => void): void {\n    const wrapper = (...args: TEvents[TEventName]) => {\n      this.off(eventName, wrapper)\n      handler(...args)\n    }\n    this.on(eventName, wrapper)\n  }\n\n  off<TEventName extends keyof TEvents & string>(eventName: TEventName, handler: (...eventArg: TEvents[TEventName]) => void): void {\n    this.#emitter.off(eventName, handler as any)\n  }\n  removeAll(): void {\n    this.#emitter.removeAllListeners()\n  }\n}\n","/**\n * Calculates elapsed time in milliseconds from a high-resolution start time.\n * Rounds to 2 decimal places to provide sub-millisecond precision without noise.\n */\nexport function getElapsedMs(hrStart: [number, number]): number {\n  const [seconds, nanoseconds] = process.hrtime(hrStart)\n  const ms = seconds * 1000 + nanoseconds / 1e6\n  return Math.round(ms * 100) / 100\n}\n\n/**\n * Converts a millisecond duration into a human-readable string.\n * Adjusts units (ms, s, m s) based on the magnitude of the duration.\n */\nexport function formatMs(ms: number): string {\n  if (ms >= 60000) {\n    const mins = Math.floor(ms / 60000)\n    const secs = ((ms % 60000) / 1000).toFixed(1)\n    return `${mins}m ${secs}s`\n  }\n\n  if (ms >= 1000) {\n    return `${(ms / 1000).toFixed(2)}s`\n  }\n  return `${Math.round(ms).toFixed(0)}ms`\n}\n\n/**\n * Convenience helper to get and format elapsed time in one step.\n */\nexport function formatHrtime(hrStart: [number, number]): string {\n  return formatMs(getElapsedMs(hrStart))\n}\n","import { camelCase, isValidVarName } from '../transformers'\n\nexport type URLObject = {\n  url: string\n  params?: Record<string, string>\n}\n\ntype ObjectOptions = {\n  type?: 'path' | 'template'\n  replacer?: (pathParam: string) => string\n  stringify?: boolean\n}\n\ntype Options = {\n  casing?: 'camelcase'\n}\n\nexport class URLPath {\n  path: string\n  #options: Options\n\n  constructor(path: string, options: Options = {}) {\n    this.path = path\n    this.#options = options\n\n    return this\n  }\n\n  /**\n   * Convert Swagger path to URLPath(syntax of Express)\n   * @example /pet/{petId} => /pet/:petId\n   */\n  get URL(): string {\n    return this.toURLPath()\n  }\n  get isURL(): boolean {\n    try {\n      const url = new URL(this.path)\n      if (url?.href) {\n        return true\n      }\n    } catch (_error) {\n      return false\n    }\n    return false\n  }\n\n  /**\n   * Convert Swagger path to template literals/ template strings(camelcase)\n   * @example /pet/{petId} => `/pet/${petId}`\n   * @example /account/monetary-accountID => `/account/${monetaryAccountId}`\n   * @example /account/userID => `/account/${userId}`\n   */\n  get template(): string {\n    return this.toTemplateString()\n  }\n  get object(): URLObject | string {\n    return this.toObject()\n  }\n  get params(): Record<string, string> | undefined {\n    return this.getParams()\n  }\n\n  toObject({ type = 'path', replacer, stringify }: ObjectOptions = {}): URLObject | string {\n    const object = {\n      url: type === 'path' ? this.toURLPath() : this.toTemplateString({ replacer }),\n      params: this.getParams(),\n    }\n\n    if (stringify) {\n      if (type === 'template') {\n        return JSON.stringify(object).replaceAll(\"'\", '').replaceAll(`\"`, '')\n      }\n\n      if (object.params) {\n        return `{ url: '${object.url}', params: ${JSON.stringify(object.params).replaceAll(\"'\", '').replaceAll(`\"`, '')} }`\n      }\n\n      return `{ url: '${object.url}' }`\n    }\n\n    return object\n  }\n\n  /**\n   * Convert Swagger path to template literals/ template strings(camelcase)\n   * @example /pet/{petId} => `/pet/${petId}`\n   * @example /account/monetary-accountID => `/account/${monetaryAccountId}`\n   * @example /account/userID => `/account/${userId}`\n   */\n  toTemplateString({ prefix = '', replacer }: { prefix?: string; replacer?: (pathParam: string) => string } = {}): string {\n    const regex = /{(\\w|-)*}/g\n    const found = this.path.match(regex)\n    let newPath = this.path.replaceAll('{', '${')\n\n    if (found) {\n      newPath = found.reduce((prev, path) => {\n        const pathWithoutBrackets = path.replaceAll('{', '').replaceAll('}', '')\n\n        let param = isValidVarName(pathWithoutBrackets) ? pathWithoutBrackets : camelCase(pathWithoutBrackets)\n\n        if (this.#options.casing === 'camelcase') {\n          param = camelCase(param)\n        }\n\n        return prev.replace(path, `\\${${replacer ? replacer(param) : param}}`)\n      }, this.path)\n    }\n\n    return `\\`${prefix}${newPath}\\``\n  }\n\n  getParams(replacer?: (pathParam: string) => string): Record<string, string> | undefined {\n    const regex = /{(\\w|-)*}/g\n    const found = this.path.match(regex)\n\n    if (!found) {\n      return undefined\n    }\n\n    const params: Record<string, string> = {}\n    found.forEach((item) => {\n      item = item.replaceAll('{', '').replaceAll('}', '')\n\n      let param = isValidVarName(item) ? item : camelCase(item)\n\n      if (this.#options.casing === 'camelcase') {\n        param = camelCase(param)\n      }\n\n      const key = replacer ? replacer(param) : param\n\n      params[key] = key\n    }, this.path)\n\n    return params\n  }\n\n  /**\n   * Convert Swagger path to URLPath(syntax of Express)\n   * @example /pet/{petId} => /pet/:petId\n   */\n  toURLPath(): string {\n    return this.path.replaceAll('{', ':').replaceAll('}', '')\n  }\n}\n","import type { KubbFile } from '@kubb/fabric-core/types'\nimport { getMode } from '../PluginManager.ts'\n\ntype BarrelData = {\n  file?: KubbFile.File\n  /**\n   * @deprecated use file instead\n   */\n  type: KubbFile.Mode\n  path: string\n  name: string\n}\n\nexport class TreeNode {\n  data: BarrelData\n  parent?: TreeNode\n  children: Array<TreeNode> = []\n  #cachedLeaves?: Array<TreeNode> = undefined\n\n  constructor(data: BarrelData, parent?: TreeNode) {\n    this.data = data\n    this.parent = parent\n    return this\n  }\n\n  addChild(data: BarrelData): TreeNode {\n    const child = new TreeNode(data, this)\n    if (!this.children) {\n      this.children = []\n    }\n    this.children.push(child)\n    return child\n  }\n\n  get root(): TreeNode {\n    if (!this.parent) {\n      return this\n    }\n    return this.parent.root\n  }\n\n  get leaves(): Array<TreeNode> {\n    if (!this.children || this.children.length === 0) {\n      // this is a leaf\n      return [this]\n    }\n\n    if (this.#cachedLeaves) {\n      return this.#cachedLeaves\n    }\n\n    // if not a leaf, return all children's leaves recursively\n    const leaves: TreeNode[] = []\n    if (this.children) {\n      for (let childIndex = 0, { length } = this.children; childIndex < length; childIndex++) {\n        leaves.push.apply(leaves, this.children[childIndex]!.leaves)\n      }\n    }\n\n    this.#cachedLeaves = leaves\n\n    return leaves\n  }\n\n  forEach(callback: (treeNode: TreeNode) => void): this {\n    if (typeof callback !== 'function') {\n      throw new TypeError('forEach() callback must be a function')\n    }\n\n    // run this node through function\n    callback(this)\n\n    // do the same for all children\n    if (this.children) {\n      for (let childIndex = 0, { length } = this.children; childIndex < length; childIndex++) {\n        this.children[childIndex]?.forEach(callback)\n      }\n    }\n\n    return this\n  }\n\n  findDeep(predicate?: (value: TreeNode, index: number, obj: TreeNode[]) => boolean): TreeNode | undefined {\n    if (typeof predicate !== 'function') {\n      throw new TypeError('find() predicate must be a function')\n    }\n\n    return this.leaves.find(predicate)\n  }\n\n  forEachDeep(callback: (treeNode: TreeNode) => void): void {\n    if (typeof callback !== 'function') {\n      throw new TypeError('forEach() callback must be a function')\n    }\n\n    this.leaves.forEach(callback)\n  }\n\n  filterDeep(callback: (treeNode: TreeNode) => boolean): Array<TreeNode> {\n    if (typeof callback !== 'function') {\n      throw new TypeError('filter() callback must be a function')\n    }\n\n    return this.leaves.filter(callback)\n  }\n\n  mapDeep<T>(callback: (treeNode: TreeNode) => T): Array<T> {\n    if (typeof callback !== 'function') {\n      throw new TypeError('map() callback must be a function')\n    }\n\n    return this.leaves.map(callback)\n  }\n\n  public static build(files: KubbFile.File[], root?: string): TreeNode | null {\n    try {\n      const filteredTree = buildDirectoryTree(files, root)\n\n      if (!filteredTree) {\n        return null\n      }\n\n      const treeNode = new TreeNode({\n        name: filteredTree.name,\n        path: filteredTree.path,\n        file: filteredTree.file,\n        type: getMode(filteredTree.path),\n      })\n\n      const recurse = (node: typeof treeNode, item: DirectoryTree) => {\n        const subNode = node.addChild({\n          name: item.name,\n          path: item.path,\n          file: item.file,\n          type: getMode(item.path),\n        })\n\n        if (item.children?.length) {\n          item.children?.forEach((child) => {\n            recurse(subNode, child)\n          })\n        }\n      }\n\n      filteredTree.children?.forEach((child) => {\n        recurse(treeNode, child)\n      })\n\n      return treeNode\n    } catch (error) {\n      throw new Error('Something went wrong with creating barrel files with the TreeNode class', { cause: error })\n    }\n  }\n}\n\nexport type DirectoryTree = {\n  name: string\n  path: string\n  file?: KubbFile.File\n  children: Array<DirectoryTree>\n}\n\nconst normalizePath = (p: string): string => p.replace(/\\\\/g, '/')\n\nexport function buildDirectoryTree(files: Array<KubbFile.File>, rootFolder = ''): DirectoryTree | null {\n  const normalizedRootFolder = normalizePath(rootFolder)\n  const rootPrefix = normalizedRootFolder.endsWith('/') ? normalizedRootFolder : `${normalizedRootFolder}/`\n\n  const filteredFiles = files.filter((file) => {\n    const normalizedFilePath = normalizePath(file.path)\n    return rootFolder ? normalizedFilePath.startsWith(rootPrefix) && !normalizedFilePath.endsWith('.json') : !normalizedFilePath.endsWith('.json')\n  })\n\n  if (filteredFiles.length === 0) {\n    return null // No files match the root folder\n  }\n\n  const root: DirectoryTree = {\n    name: rootFolder || '',\n    path: rootFolder || '',\n    children: [],\n  }\n\n  filteredFiles.forEach((file) => {\n    const path = file.path.slice(rootFolder.length)\n    const parts = path.split('/')\n    let currentLevel: DirectoryTree[] = root.children\n    let currentPath = rootFolder\n\n    parts.forEach((part, index) => {\n      if (index !== 0) {\n        currentPath += `/${part}`\n      } else {\n        currentPath += `${part}`\n      }\n\n      let existingNode = currentLevel.find((node) => node.name === part)\n\n      if (!existingNode) {\n        if (index === parts.length - 1) {\n          // If its the last part, its a file\n          existingNode = {\n            name: part,\n            file,\n            path: currentPath,\n          } as DirectoryTree\n        } else {\n          // Otherwise, its a folder\n          existingNode = {\n            name: part,\n            path: currentPath,\n            children: [],\n          } as DirectoryTree\n        }\n        currentLevel.push(existingNode)\n      }\n\n      // Move to the next level if its a folder\n      if (!existingNode.file) {\n        currentLevel = existingNode.children\n      }\n    })\n  })\n\n  return root\n}\n","/** biome-ignore-all lint/suspicious/useIterableCallbackReturn: not needed */\nimport { join } from 'node:path'\nimport type { KubbFile } from '@kubb/fabric-core/types'\nimport { getRelativePath } from './fs/index.ts'\n\nimport type { FileMetaBase } from './utils/getBarrelFiles.ts'\nimport { TreeNode } from './utils/TreeNode.ts'\n\ntype BarrelManagerOptions = {}\n\nexport class BarrelManager {\n  constructor(_options: BarrelManagerOptions = {}) {\n    return this\n  }\n\n  getFiles({ files: generatedFiles, root }: { files: KubbFile.File[]; root?: string; meta?: FileMetaBase | undefined }): Array<KubbFile.File> {\n    const cachedFiles = new Map<KubbFile.Path, KubbFile.File>()\n\n    TreeNode.build(generatedFiles, root)?.forEach((treeNode) => {\n      if (!treeNode || !treeNode.children || !treeNode.parent?.data.path) {\n        return undefined\n      }\n\n      const barrelFile: KubbFile.File = {\n        path: join(treeNode.parent?.data.path, 'index.ts') as KubbFile.Path,\n        baseName: 'index.ts',\n        exports: [],\n        imports: [],\n        sources: [],\n      }\n      const previousBarrelFile = cachedFiles.get(barrelFile.path)\n      const leaves = treeNode.leaves\n\n      leaves.forEach((item) => {\n        if (!item.data.name) {\n          return undefined\n        }\n\n        const sources = item.data.file?.sources || []\n\n        sources.forEach((source) => {\n          if (!item.data.file?.path || !source.isIndexable || !source.name) {\n            return undefined\n          }\n          const alreadyContainInPreviousBarrelFile = previousBarrelFile?.sources.some(\n            (item) => item.name === source.name && item.isTypeOnly === source.isTypeOnly,\n          )\n\n          if (alreadyContainInPreviousBarrelFile) {\n            return undefined\n          }\n\n          if (!barrelFile.exports) {\n            barrelFile.exports = []\n          }\n\n          // true when we have a subdirectory that also contains barrel files\n          const isSubExport = !!treeNode.parent?.data.path?.split?.('/')?.length\n\n          if (isSubExport) {\n            barrelFile.exports.push({\n              name: [source.name],\n              path: getRelativePath(treeNode.parent?.data.path, item.data.path),\n              isTypeOnly: source.isTypeOnly,\n            })\n          } else {\n            barrelFile.exports.push({\n              name: [source.name],\n              path: `./${item.data.file.baseName}`,\n              isTypeOnly: source.isTypeOnly,\n            })\n          }\n\n          barrelFile.sources.push({\n            name: source.name,\n            isTypeOnly: source.isTypeOnly,\n            //TODO use parser to generate import\n            value: '',\n            isExportable: false,\n            isIndexable: false,\n          })\n        })\n      })\n\n      if (previousBarrelFile) {\n        previousBarrelFile.sources.push(...barrelFile.sources)\n        previousBarrelFile.exports?.push(...(barrelFile.exports || []))\n      } else {\n        cachedFiles.set(barrelFile.path, barrelFile)\n      }\n    })\n\n    return [...cachedFiles.values()]\n  }\n}\n","import { join } from 'node:path'\nimport type { KubbFile } from '@kubb/fabric-core/types'\nimport { BarrelManager } from '../BarrelManager.ts'\nimport type { BarrelType, Plugin } from '../types.ts'\n\nexport type FileMetaBase = {\n  pluginKey?: Plugin['key']\n}\n\ntype AddIndexesProps = {\n  type: BarrelType | false | undefined\n  /**\n   * Root based on root and output.path specified in the config\n   */\n  root: string\n  /**\n   * Output for plugin\n   */\n  output: {\n    path: string\n  }\n  group?: {\n    output: string\n    exportAs: string\n  }\n\n  meta?: FileMetaBase\n}\n\nfunction trimExtName(text: string): string {\n  return text.replace(/\\.[^/.]+$/, '')\n}\n\nexport async function getBarrelFiles(files: Array<KubbFile.ResolvedFile>, { type, meta = {}, root, output }: AddIndexesProps): Promise<KubbFile.File[]> {\n  if (!type || type === 'propagate') {\n    return []\n  }\n\n  const barrelManager = new BarrelManager({})\n\n  const pathToBuildFrom = join(root, output.path)\n\n  if (trimExtName(pathToBuildFrom).endsWith('index')) {\n    return []\n  }\n\n  const barrelFiles = barrelManager.getFiles({\n    files,\n    root: pathToBuildFrom,\n    meta,\n  })\n\n  if (type === 'all') {\n    return barrelFiles.map((file) => {\n      return {\n        ...file,\n        exports: file.exports?.map((exportItem) => {\n          return {\n            ...exportItem,\n            name: undefined,\n          }\n        }),\n      }\n    })\n  }\n\n  return barrelFiles.map((indexFile) => {\n    return {\n      ...indexFile,\n      meta,\n    }\n  })\n}\n"],"x_google_ignoreList":[1,2],"mappings":"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"}