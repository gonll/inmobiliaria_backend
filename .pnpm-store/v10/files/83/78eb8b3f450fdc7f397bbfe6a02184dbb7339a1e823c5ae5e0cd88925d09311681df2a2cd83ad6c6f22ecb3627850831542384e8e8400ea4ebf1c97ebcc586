{"version":3,"sources":["../src/build.ts","../src/PluginManager.ts","../src/utils/executeStrategies.ts","../src/PromiseManager.ts","../src/errors.ts","../src/plugin.ts","../src/utils/cache.ts","../src/config.ts","../src/Generator.ts","../src/PackageManager.ts"],"sourcesContent":["import c from 'tinyrainbow'\n\nimport { clean, read } from '@kubb/fs'\nimport { FileManager, type ResolvedFile } from './FileManager.ts'\nimport { PluginManager } from './PluginManager.ts'\nimport { isPromise } from './PromiseManager.ts'\nimport { isInputPath } from './config.ts'\nimport { LogLevel, createLogger, randomCliColour } from './logger.ts'\nimport { URLPath } from './utils/URLPath.ts'\n\nimport type { Logger } from './logger.ts'\nimport type { Plugin, PluginContext, PluginParameter, TransformResult } from './types.ts'\n\ntype BuildOptions = {\n  config: PluginContext['config']\n  /**\n   * @default Logger without the spinner\n   */\n  logger?: Logger\n}\n\ntype BuildOutput = {\n  files: FileManager['files']\n  pluginManager: PluginManager\n  /**\n   * Only for safeBuild\n   */\n  error?: Error\n}\n\nasync function transformReducer(\n  this: PluginContext,\n  _previousCode: string,\n  result: TransformResult | Promise<TransformResult>,\n  _plugin: Plugin,\n): Promise<string | null> {\n  return result\n}\n\nasync function setup(options: BuildOptions): Promise<PluginManager> {\n  const { config, logger = createLogger({ logLevel: LogLevel.silent }) } = options\n  let count = 0\n\n  try {\n    if (isInputPath(config) && !new URLPath(config.input.path).isURL) {\n      await read(config.input.path)\n    }\n  } catch (e) {\n    if (isInputPath(config)) {\n      throw new Error(\n        `Cannot read file/URL defined in \\`input.path\\` or set with \\`kubb generate PATH\\` in the CLI of your Kubb config ${c.dim(config.input.path)}`,\n        {\n          cause: e,\n        },\n      )\n    }\n  }\n\n  if (config.output.clean) {\n    await clean(config.output.path)\n  }\n\n  const task = async (file: ResolvedFile): Promise<ResolvedFile> => {\n    const { path } = file\n\n    let source: string | null = await FileManager.getSource(file)\n\n    const { result: loadedResult } = await pluginManager.hookFirst({\n      hookName: 'load',\n      parameters: [path],\n    })\n    if (loadedResult && isPromise(loadedResult)) {\n      source = await loadedResult\n    }\n    if (loadedResult && !isPromise(loadedResult)) {\n      source = loadedResult\n    }\n\n    if (source) {\n      source = await pluginManager.hookReduceArg0({\n        hookName: 'transform',\n        parameters: [path, source],\n        reduce: transformReducer,\n      })\n\n      if (config.output.write || config.output.write === undefined) {\n        if (file.meta?.pluginKey) {\n          // run only for pluginKey defined in the meta of the file\n          await pluginManager.hookForPlugin({\n            pluginKey: file.meta?.pluginKey,\n            hookName: 'writeFile',\n            parameters: [path, source],\n          })\n        }\n\n        await pluginManager.hookFirst({\n          hookName: 'writeFile',\n          parameters: [path, source],\n        })\n      }\n    }\n\n    return {\n      ...file,\n      source: source || '',\n    }\n  }\n\n  const pluginManager = new PluginManager(config, { logger, task })\n\n  pluginManager.on('execute', (executer) => {\n    const { hookName, parameters, plugin } = executer\n\n    if (hookName === 'writeFile') {\n      const [code] = parameters as PluginParameter<'writeFile'>\n\n      logger.emit('debug', [`PluginKey ${c.dim(JSON.stringify(plugin.key))} \\nwith source\\n\\n${code}`])\n    }\n  })\n\n  pluginManager.queue.on('add', () => {\n    if (logger.logLevel !== LogLevel.info) {\n      return\n    }\n\n    if (count === 0) {\n      logger.emit('start', 'ðŸ’¾ Writing')\n    }\n  })\n\n  pluginManager.queue.on('active', () => {\n    if (logger.logLevel !== LogLevel.info) {\n      return\n    }\n\n    if (logger.spinner && pluginManager.queue.size > 0) {\n      const text = `Item: ${count} Size: ${pluginManager.queue.size}  Pending: ${pluginManager.queue.pending}`\n\n      logger.spinner.suffixText = c.dim(text)\n    }\n    ++count\n  })\n\n  pluginManager.queue.on('completed', () => {\n    if (logger.logLevel !== LogLevel.info) {\n      return\n    }\n\n    if (logger.spinner) {\n      const text = `Item: ${count} Size: ${pluginManager.queue.size}  Pending: ${pluginManager.queue.pending}`\n\n      logger.spinner.suffixText = c.dim(text)\n    }\n  })\n\n  pluginManager.on('executed', (executer) => {\n    const { hookName, plugin, output, parameters } = executer\n\n    const logs = [\n      `${randomCliColour(plugin.name)} Executing ${hookName}`,\n      parameters && `${c.bgWhite('Parameters')} ${randomCliColour(plugin.name)} ${hookName}`,\n      JSON.stringify(parameters, undefined, 2),\n      output && `${c.bgWhite('Output')} ${randomCliColour(plugin.name)} ${hookName}`,\n      output,\n    ].filter(Boolean)\n\n    logger.emit('debug', logs as string[])\n  })\n\n  return pluginManager\n}\n\nexport async function build(options: BuildOptions): Promise<BuildOutput> {\n  const pluginManager = await setup(options)\n\n  const { fileManager, logger } = pluginManager\n\n  await pluginManager.hookParallel({\n    hookName: 'buildStart',\n    parameters: [options.config],\n  })\n\n  await pluginManager.hookParallel({ hookName: 'buildEnd' })\n\n  if (logger.logLevel === LogLevel.info) {\n    logger.emit('end', 'ðŸ’¾ Writing completed')\n  }\n\n  const files = await Promise.all(\n    fileManager.files.map(async (file) => ({\n      ...file,\n      source: await FileManager.getSource(file),\n    })),\n  )\n\n  return {\n    files,\n    pluginManager,\n  }\n}\n\nexport async function safeBuild(options: BuildOptions): Promise<BuildOutput> {\n  const pluginManager = await setup(options)\n\n  const { fileManager, logger } = pluginManager\n\n  try {\n    await pluginManager.hookParallel({\n      hookName: 'buildStart',\n      parameters: [options.config],\n    })\n\n    await pluginManager.hookParallel({ hookName: 'buildEnd' })\n\n    if (logger.logLevel === LogLevel.info) {\n      logger.emit('end', 'ðŸ’¾ Writing completed')\n    }\n  } catch (e) {\n    const files = await Promise.all(\n      fileManager.files.map(async (file) => ({\n        ...file,\n        source: await FileManager.getSource(file),\n      })),\n    )\n\n    return {\n      files,\n      pluginManager,\n      error: e as Error,\n    }\n  }\n\n  const files = await Promise.all(\n    fileManager.files.map(async (file) => ({\n      ...file,\n      source: await FileManager.getSource(file),\n    })),\n  )\n\n  return {\n    files,\n    pluginManager,\n  }\n}\n","import PQueue from 'p-queue'\n\nimport { readSync } from '@kubb/fs'\nimport { FileManager, type ResolvedFile } from './FileManager.ts'\nimport { isPromise, isPromiseRejectedResult } from './PromiseManager.ts'\nimport { PromiseManager } from './PromiseManager.ts'\nimport { ValidationPluginError } from './errors.ts'\nimport { LogLevel } from './logger.ts'\nimport { pluginCore } from './plugin.ts'\nimport { transformReservedWord } from './transformers/transformReservedWord.ts'\nimport { EventEmitter } from './utils/EventEmitter.ts'\nimport { setUniqueName } from './utils/uniqueName.ts'\n\nimport type * as KubbFile from '@kubb/fs/types'\nimport type { PossiblePromise } from '@kubb/types'\nimport type { Logger } from './logger.ts'\nimport type { PluginCore } from './plugin.ts'\nimport type {\n  Config,\n  GetPluginFactoryOptions,\n  Plugin,\n  PluginFactoryOptions,\n  PluginLifecycle,\n  PluginLifecycleHooks,\n  PluginParameter,\n  PluginWithLifeCycle,\n  ResolveNameParams,\n  ResolvePathParams,\n  UserPlugin,\n  UserPluginWithLifeCycle,\n} from './types.ts'\n\ntype RequiredPluginLifecycle = Required<PluginLifecycle>\n\n/**\n * Get the type of the first argument in a function.\n * @example Arg0<(a: string, b: number) => void> -> string\n */\ntype Argument0<H extends keyof PluginLifecycle> = Parameters<RequiredPluginLifecycle[H]>[0]\n\ntype Strategy = 'hookFirst' | 'hookForPlugin' | 'hookParallel' | 'hookReduceArg0' | 'hookSeq'\n\ntype Executer<H extends PluginLifecycleHooks = PluginLifecycleHooks> = {\n  strategy: Strategy\n  hookName: H\n  plugin: Plugin\n  parameters?: unknown[] | undefined\n  output?: unknown\n}\n\ntype ParseResult<H extends PluginLifecycleHooks> = RequiredPluginLifecycle[H]\n\ntype SafeParseResult<H extends PluginLifecycleHooks, Result = ReturnType<ParseResult<H>>> = {\n  result: Result\n  plugin: Plugin\n}\n\n// inspired by: https://github.com/rollup/rollup/blob/master/src/utils/PluginDriver.ts#\n\ntype Options = {\n  logger: Logger\n\n  /**\n   * Task for the FileManager\n   */\n  task: (file: ResolvedFile) => Promise<ResolvedFile>\n}\n\ntype Events = {\n  execute: [executer: Executer]\n  executed: [executer: Executer]\n  error: [error: Error]\n}\n\ntype GetFileProps<TOptions = object> = {\n  name: string\n  mode?: KubbFile.Mode\n  extName: KubbFile.Extname\n  pluginKey: Plugin['key']\n  options?: TOptions\n}\n\nexport class PluginManager {\n  readonly plugins: PluginWithLifeCycle[]\n  readonly fileManager: FileManager\n  readonly events: EventEmitter<Events> = new EventEmitter()\n\n  readonly config: Config\n\n  readonly executed: Array<Executer> = []\n  readonly logger: Logger\n  readonly #core: Plugin<PluginCore>\n\n  readonly #usedPluginNames: Record<string, number> = {}\n  readonly #promiseManager: PromiseManager\n\n  readonly queue: PQueue\n\n  constructor(config: Config, options: Options) {\n    this.config = config\n    this.logger = options.logger\n    this.queue = new PQueue({ concurrency: 1 })\n    this.fileManager = new FileManager({\n      task: options.task,\n      queue: this.queue,\n    })\n    this.#promiseManager = new PromiseManager({\n      nullCheck: (state: SafeParseResult<'resolveName'> | null) => !!state?.result,\n    })\n\n    const plugins = config.plugins || []\n\n    const core = pluginCore({\n      config,\n      logger: this.logger,\n      pluginManager: this,\n      fileManager: this.fileManager,\n      resolvePath: this.resolvePath.bind(this),\n      resolveName: this.resolveName.bind(this),\n      getPlugins: this.#getSortedPlugins.bind(this),\n    })\n\n    // call core.api.call with empty context so we can transform `api()` to `api: {}`\n    this.#core = this.#parse(core as unknown as UserPlugin, this as any, core.api.call(null as any)) as Plugin<PluginCore>\n\n    this.plugins = [this.#core, ...plugins].map((plugin) => {\n      return this.#parse(plugin as UserPlugin, this, this.#core.api)\n    })\n\n    return this\n  }\n\n  getFile<TOptions = object>({ name, mode, extName, pluginKey, options }: GetFileProps<TOptions>): KubbFile.File<{ pluginKey: Plugin['key'] }> {\n    let source = ''\n    const baseName = `${name}${extName}` as const\n    const path = this.resolvePath({ baseName, mode, pluginKey, options })\n\n    if (!path) {\n      throw new Error(`Filepath should be defined for resolvedName \"${name}\" and pluginKey [${JSON.stringify(pluginKey)}]`)\n    }\n\n    try {\n      source = readSync(path)\n    } catch (_e) {\n      //\n    }\n\n    return {\n      path,\n      baseName,\n      meta: {\n        pluginKey,\n      },\n      source,\n    }\n  }\n\n  resolvePath = <TOptions = object>(params: ResolvePathParams<TOptions>): KubbFile.OptionalPath => {\n    if (params.pluginKey) {\n      const paths = this.hookForPluginSync({\n        pluginKey: params.pluginKey,\n        hookName: 'resolvePath',\n        parameters: [params.baseName, params.mode, params.options as object],\n      })\n\n      if (paths && paths?.length > 1) {\n        this.logger.emit('debug', [\n          `Cannot return a path where the 'pluginKey' ${\n            params.pluginKey ? JSON.stringify(params.pluginKey) : '\"'\n          } is not unique enough\\n\\nPaths: ${JSON.stringify(paths, undefined, 2)}\\n\\nFalling back on the first item.\\n`,\n        ])\n      }\n\n      return paths?.at(0)\n    }\n    return this.hookFirstSync({\n      hookName: 'resolvePath',\n      parameters: [params.baseName, params.mode, params.options as object],\n    }).result\n  }\n  resolveName = (params: ResolveNameParams): string => {\n    if (params.pluginKey) {\n      const names = this.hookForPluginSync({\n        pluginKey: params.pluginKey,\n        hookName: 'resolveName',\n        parameters: [params.name, params.type],\n      })\n\n      if (names && names?.length > 1) {\n        this.logger.emit('debug', [\n          `Cannot return a name where the 'pluginKey' ${\n            params.pluginKey ? JSON.stringify(params.pluginKey) : '\"'\n          } is not unique enough\\n\\nNames: ${JSON.stringify(names, undefined, 2)}\\n\\nFalling back on the first item.\\n`,\n        ])\n      }\n\n      return transformReservedWord(names?.at(0) || params.name)\n    }\n\n    const name = this.hookFirstSync({\n      hookName: 'resolveName',\n      parameters: [params.name, params.type],\n    }).result\n\n    return transformReservedWord(name)\n  }\n\n  /**\n   * Instead of calling `pluginManager.events.on` you can use `pluginManager.on`. This one also has better types.\n   */\n  on<TEventName extends keyof Events & string>(eventName: TEventName, handler: (...eventArg: Events[TEventName]) => void): void {\n    this.events.on(eventName, handler as any)\n  }\n\n  /**\n   * Run a specific hookName for plugin x.\n   */\n  hookForPlugin<H extends PluginLifecycleHooks>({\n    pluginKey,\n    hookName,\n    parameters,\n  }: {\n    pluginKey: Plugin['key']\n    hookName: H\n    parameters: PluginParameter<H>\n  }): Promise<Array<ReturnType<ParseResult<H>> | null>> | null {\n    const plugins = this.getPluginsByKey(hookName, pluginKey)\n\n    const promises = plugins\n      .map((plugin) => {\n        return this.#execute<H>({\n          strategy: 'hookFirst',\n          hookName,\n          parameters,\n          plugin,\n        })\n      })\n      .filter(Boolean)\n\n    return Promise.all(promises)\n  }\n  /**\n   * Run a specific hookName for plugin x.\n   */\n\n  hookForPluginSync<H extends PluginLifecycleHooks>({\n    pluginKey,\n    hookName,\n    parameters,\n  }: {\n    pluginKey: Plugin['key']\n    hookName: H\n    parameters: PluginParameter<H>\n  }): Array<ReturnType<ParseResult<H>>> | null {\n    const plugins = this.getPluginsByKey(hookName, pluginKey)\n\n    return plugins\n      .map((plugin) => {\n        return this.#executeSync<H>({\n          strategy: 'hookFirst',\n          hookName,\n          parameters,\n          plugin,\n        })\n      })\n      .filter(Boolean)\n  }\n\n  /**\n   * First non-null result stops and will return it's value.\n   */\n  async hookFirst<H extends PluginLifecycleHooks>({\n    hookName,\n    parameters,\n    skipped,\n  }: {\n    hookName: H\n    parameters: PluginParameter<H>\n    skipped?: ReadonlySet<Plugin> | null\n  }): Promise<SafeParseResult<H>> {\n    const promises = this.#getSortedPlugins()\n      .filter((plugin) => {\n        return skipped ? skipped.has(plugin) : true\n      })\n      .map((plugin) => {\n        return async () => {\n          const value = await this.#execute<H>({\n            strategy: 'hookFirst',\n            hookName,\n            parameters,\n            plugin,\n          })\n\n          return Promise.resolve({\n            plugin,\n            result: value,\n          } as SafeParseResult<H>)\n        }\n      })\n\n    return this.#promiseManager.run('first', promises)\n  }\n\n  /**\n   * First non-null result stops and will return it's value.\n   */\n  hookFirstSync<H extends PluginLifecycleHooks>({\n    hookName,\n    parameters,\n    skipped,\n  }: {\n    hookName: H\n    parameters: PluginParameter<H>\n    skipped?: ReadonlySet<Plugin> | null\n  }): SafeParseResult<H> {\n    let parseResult: SafeParseResult<H> = null as unknown as SafeParseResult<H>\n\n    for (const plugin of this.#getSortedPlugins()) {\n      if (skipped?.has(plugin)) {\n        continue\n      }\n\n      parseResult = {\n        result: this.#executeSync<H>({\n          strategy: 'hookFirst',\n          hookName,\n          parameters,\n          plugin,\n        }),\n        plugin,\n      } as SafeParseResult<H>\n\n      if (parseResult?.result != null) {\n        break\n      }\n    }\n    return parseResult\n  }\n\n  /**\n   * Run all plugins in parallel(order will be based on `this.plugin` and if `pre` or `post` is set).\n   */\n  async hookParallel<H extends PluginLifecycleHooks, TOuput = void>({\n    hookName,\n    parameters,\n  }: {\n    hookName: H\n    parameters?: Parameters<RequiredPluginLifecycle[H]> | undefined\n  }): Promise<Awaited<TOuput>[]> {\n    const promises = this.#getSortedPlugins().map((plugin) => {\n      return () =>\n        this.#execute({\n          strategy: 'hookParallel',\n          hookName,\n          parameters,\n          plugin,\n        }) as Promise<TOuput>\n    })\n\n    const results = await this.#promiseManager.run('parallel', promises)\n\n    results.forEach((result, index) => {\n      if (isPromiseRejectedResult<Error>(result)) {\n        const plugin = this.#getSortedPlugins()[index]\n\n        this.#catcher<H>(result.reason, plugin, hookName)\n      }\n    })\n\n    return results.filter((result) => result.status === 'fulfilled').map((result) => (result as PromiseFulfilledResult<Awaited<TOuput>>).value)\n  }\n\n  /**\n   * Chain all plugins, `reduce` can be passed through to handle every returned value. The return value of the first plugin will be used as the first parameter for the plugin after that.\n   */\n  hookReduceArg0<H extends PluginLifecycleHooks>({\n    hookName,\n    parameters,\n    reduce,\n  }: {\n    hookName: H\n    parameters: PluginParameter<H>\n    reduce: (reduction: Argument0<H>, result: ReturnType<ParseResult<H>>, plugin: Plugin) => PossiblePromise<Argument0<H> | null>\n  }): Promise<Argument0<H>> {\n    const [argument0, ...rest] = parameters\n\n    let promise: Promise<Argument0<H>> = Promise.resolve(argument0)\n    for (const plugin of this.#getSortedPlugins()) {\n      promise = promise\n        .then((arg0) => {\n          const value = this.#execute({\n            strategy: 'hookReduceArg0',\n            hookName,\n            parameters: [arg0, ...rest] as PluginParameter<H>,\n            plugin,\n          })\n          return value\n        })\n        .then((result) => reduce.call(this.#core.api, argument0, result as ReturnType<ParseResult<H>>, plugin)) as Promise<Argument0<H>>\n    }\n\n    return promise\n  }\n\n  /**\n   * Chains plugins\n   */\n  async hookSeq<H extends PluginLifecycleHooks>({ hookName, parameters }: { hookName: H; parameters?: PluginParameter<H> }): Promise<void> {\n    const promises = this.#getSortedPlugins().map((plugin) => {\n      return () =>\n        this.#execute({\n          strategy: 'hookSeq',\n          hookName,\n          parameters,\n          plugin,\n        })\n    })\n\n    return this.#promiseManager.run('seq', promises)\n  }\n\n  #getSortedPlugins(hookName?: keyof PluginLifecycle): Plugin[] {\n    const plugins = [...this.plugins].filter((plugin) => plugin.name !== 'core')\n\n    if (hookName) {\n      if (this.logger.logLevel === LogLevel.info) {\n        const containsHookName = plugins.some((item) => item[hookName])\n        if (!containsHookName) {\n          this.logger.emit('warning', `No hook ${hookName} found`)\n        }\n      }\n\n      return plugins.filter((item) => item[hookName])\n    }\n    // TODO add test case for sorting with pre/post\n\n    return plugins\n      .map((plugin) => {\n        if (plugin.pre) {\n          const isValid = plugin.pre.every((pluginName) => plugins.find((pluginToFind) => pluginToFind.name === pluginName))\n\n          if (!isValid) {\n            throw new ValidationPluginError(`This plugin has a pre set that is not valid(${JSON.stringify(plugin.pre, undefined, 2)})`)\n          }\n        }\n\n        return plugin\n      })\n      .sort((a, b) => {\n        if (b.pre?.includes(a.name)) {\n          return 1\n        }\n        if (b.post?.includes(a.name)) {\n          return -1\n        }\n        return 0\n      })\n  }\n\n  getPluginsByKey(hookName: keyof PluginLifecycle, pluginKey: Plugin['key']): Plugin[] {\n    const plugins = [...this.plugins]\n    const [searchPluginName, searchIdentifier] = pluginKey\n\n    const pluginByPluginName = plugins\n      .filter((plugin) => plugin[hookName])\n      .filter((item) => {\n        const [name, identifier] = item.key\n\n        const identifierCheck = identifier?.toString() === searchIdentifier?.toString()\n        const nameCheck = name === searchPluginName\n\n        if (searchIdentifier) {\n          return identifierCheck && nameCheck\n        }\n\n        return nameCheck\n      })\n\n    if (!pluginByPluginName?.length) {\n      // fallback on the core plugin when there is no match\n\n      const corePlugin = plugins.find((plugin) => plugin.name === 'core' && plugin[hookName])\n\n      if (corePlugin) {\n        this.logger.emit('debug', [`No hook '${hookName}' for pluginKey '${JSON.stringify(pluginKey)}' found, falling back on the '@kubb/core' plugin`])\n      } else {\n        this.logger.emit('debug', [`No hook '${hookName}' for pluginKey '${JSON.stringify(pluginKey)}' found, no fallback found in the '@kubb/core' plugin`])\n      }\n      return corePlugin ? [corePlugin] : []\n    }\n\n    return pluginByPluginName\n  }\n\n  #addExecutedToCallStack(executer: Executer | undefined) {\n    if (executer) {\n      this.events.emit('executed', executer)\n      this.executed.push(executer)\n    }\n  }\n\n  /**\n   * Run an async plugin hook and return the result.\n   * @param hookName Name of the plugin hook. Must be either in `PluginHooks` or `OutputPluginValueHooks`.\n   * @param args Arguments passed to the plugin hook.\n   * @param plugin The actual pluginObject to run.\n   */\n  // Implementation signature\n  #execute<H extends PluginLifecycleHooks>({\n    strategy,\n    hookName,\n    parameters,\n    plugin,\n  }: {\n    strategy: Strategy\n    hookName: H\n    parameters: unknown[] | undefined\n    plugin: PluginWithLifeCycle\n  }): Promise<ReturnType<ParseResult<H>> | null> | null {\n    const hook = plugin[hookName]\n    let output: unknown\n\n    if (!hook) {\n      return null\n    }\n\n    this.events.emit('execute', { strategy, hookName, parameters, plugin })\n\n    const task = Promise.resolve()\n      .then(() => {\n        if (typeof hook === 'function') {\n          const possiblePromiseResult = (hook as Function).apply({ ...this.#core.api, plugin }, parameters) as Promise<ReturnType<ParseResult<H>>>\n\n          if (isPromise(possiblePromiseResult)) {\n            return Promise.resolve(possiblePromiseResult)\n          }\n          return possiblePromiseResult\n        }\n\n        return hook\n      })\n      .then((result) => {\n        output = result\n\n        this.#addExecutedToCallStack({\n          parameters,\n          output,\n          strategy,\n          hookName,\n          plugin,\n        })\n\n        return result\n      })\n      .catch((e: Error) => {\n        this.#catcher<H>(e, plugin, hookName)\n\n        return null\n      })\n\n    return task\n  }\n\n  /**\n   * Run a sync plugin hook and return the result.\n   * @param hookName Name of the plugin hook. Must be in `PluginHooks`.\n   * @param args Arguments passed to the plugin hook.\n   * @param plugin The acutal plugin\n   * @param replaceContext When passed, the plugin context can be overridden.\n   */\n  #executeSync<H extends PluginLifecycleHooks>({\n    strategy,\n    hookName,\n    parameters,\n    plugin,\n  }: {\n    strategy: Strategy\n    hookName: H\n    parameters: PluginParameter<H>\n    plugin: PluginWithLifeCycle\n  }): ReturnType<ParseResult<H>> | null {\n    const hook = plugin[hookName]\n    let output: unknown\n\n    if (!hook) {\n      return null\n    }\n\n    this.events.emit('execute', { strategy, hookName, parameters, plugin })\n\n    try {\n      if (typeof hook === 'function') {\n        const fn = (hook as Function).apply({ ...this.#core.api, plugin }, parameters) as ReturnType<ParseResult<H>>\n\n        output = fn\n        return fn\n      }\n\n      output = hook\n\n      this.#addExecutedToCallStack({\n        parameters,\n        output,\n        strategy,\n        hookName,\n        plugin,\n      })\n\n      return hook\n    } catch (e) {\n      this.#catcher<H>(e as Error, plugin, hookName)\n\n      return null\n    }\n  }\n\n  #catcher<H extends PluginLifecycleHooks>(cause: Error, plugin?: Plugin, hookName?: H) {\n    const text = `${cause.message} (plugin: ${plugin?.name || 'unknown'}, hook: ${hookName || 'unknown'})`\n\n    this.logger.emit('error', text, cause)\n    this.events.emit('error', cause)\n  }\n\n  #parse<TPlugin extends UserPluginWithLifeCycle>(\n    plugin: TPlugin,\n    pluginManager: PluginManager,\n    context: PluginCore['api'] | undefined,\n  ): Plugin<GetPluginFactoryOptions<TPlugin>> {\n    const usedPluginNames = pluginManager.#usedPluginNames\n\n    setUniqueName(plugin.name, usedPluginNames)\n\n    const key = [plugin.name, usedPluginNames[plugin.name]].filter(Boolean) as [typeof plugin.name, string]\n\n    // default transform\n    if (!plugin.transform) {\n      plugin.transform = function transform(_path, code) {\n        return code\n      }\n    }\n\n    if (plugin.api && typeof plugin.api === 'function') {\n      const api = (plugin.api as Function).call(context) as typeof plugin.api\n\n      return {\n        ...plugin,\n        key,\n        api,\n      } as unknown as Plugin<GetPluginFactoryOptions<TPlugin>>\n    }\n\n    return {\n      ...plugin,\n      key,\n    } as unknown as Plugin<GetPluginFactoryOptions<TPlugin>>\n  }\n\n  static getDependedPlugins<\n    T1 extends PluginFactoryOptions,\n    T2 extends PluginFactoryOptions = never,\n    T3 extends PluginFactoryOptions = never,\n    TOutput = T3 extends never ? (T2 extends never ? [T1: Plugin<T1>] : [T1: Plugin<T1>, T2: Plugin<T2>]) : [T1: Plugin<T1>, T2: Plugin<T2>, T3: Plugin<T3>],\n  >(plugins: Array<Plugin>, dependedPluginNames: string | string[]): TOutput {\n    let pluginNames: string[] = []\n    if (typeof dependedPluginNames === 'string') {\n      pluginNames = [dependedPluginNames]\n    } else {\n      pluginNames = dependedPluginNames\n    }\n\n    return pluginNames.map((pluginName) => {\n      const plugin = plugins.find((plugin) => plugin.name === pluginName)\n      if (!plugin) {\n        throw new ValidationPluginError(`This plugin depends on the ${pluginName} plugin.`)\n      }\n      return plugin\n    }) as TOutput\n  }\n\n  static get hooks() {\n    return ['buildStart', 'resolvePath', 'resolveName', 'load', 'transform', 'writeFile', 'buildEnd'] as const\n  }\n}\n","type PromiseFunc<T = unknown, T2 = never> = (state?: T) => T2 extends never ? Promise<T> : Promise<T> | T2\n\nexport type ValueOfPromiseFuncArray<TInput extends Array<unknown>> = TInput extends Array<PromiseFunc<infer X, infer Y>> ? X | Y : never\n\nexport function noReturn(): void {}\n\ntype SeqOutput<TInput extends Array<PromiseFunc<TValue, null>>, TValue> = Array<Awaited<ValueOfPromiseFuncArray<TInput>>>\n\n/**\n * Chains promises\n */\nexport function hookSeq<TInput extends Array<PromiseFunc<TValue, null>>, TValue, TOutput = SeqOutput<TInput, TValue>>(promises: TInput): TOutput {\n  return promises.filter(Boolean).reduce(\n    (promise, func) => {\n      if (typeof func !== 'function') {\n        throw new Error('HookSeq needs a function that returns a promise `() => Promise<unknown>`')\n      }\n\n      return promise.then((state) => {\n        const calledFunc = func(state as TValue)\n\n        if (calledFunc) {\n          return calledFunc.then(Array.prototype.concat.bind(state))\n        }\n      })\n    },\n    Promise.resolve([] as unknown),\n  ) as TOutput\n}\n\ntype HookFirstOutput<TInput extends Array<PromiseFunc<TValue, null>>, TValue = unknown> = ValueOfPromiseFuncArray<TInput>\n\n/**\n * Chains promises, first non-null result stops and returns\n */\nexport function hookFirst<TInput extends Array<PromiseFunc<TValue, null>>, TValue = unknown, TOutput = HookFirstOutput<TInput, TValue>>(\n  promises: TInput,\n  nullCheck = (state: any) => state !== null,\n): TOutput {\n  let promise: Promise<unknown> = Promise.resolve(null) as Promise<unknown>\n\n  for (const func of promises.filter(Boolean)) {\n    promise = promise.then((state) => {\n      if (nullCheck(state)) {\n        return state\n      }\n\n      const calledFunc = func(state as TValue)\n\n      return calledFunc\n    })\n  }\n\n  return promise as TOutput\n}\n\ntype HookParallelOutput<TInput extends Array<PromiseFunc<TValue, null>>, TValue> = Promise<PromiseSettledResult<Awaited<ValueOfPromiseFuncArray<TInput>>>[]>\n\n/**\n * Run promises in parallel with allSettled\n */\nexport function hookParallel<TInput extends Array<PromiseFunc<TValue, null>>, TValue = unknown, TOutput = HookParallelOutput<TInput, TValue>>(\n  promises: TInput,\n): TOutput {\n  return Promise.allSettled(promises.filter(Boolean).map((promise) => promise())) as TOutput\n}\n\nexport type Strategy = 'seq' | 'first' | 'parallel'\n\nexport type StrategySwitch<TStrategy extends Strategy, TInput extends Array<PromiseFunc<TValue, null>>, TValue> = TStrategy extends 'first'\n  ? HookFirstOutput<TInput, TValue>\n  : TStrategy extends 'seq'\n    ? SeqOutput<TInput, TValue>\n    : TStrategy extends 'parallel'\n      ? HookParallelOutput<TInput, TValue>\n      : never\n\n// tests\n\ntype test = ValueOfPromiseFuncArray<Array<PromiseFunc<number, null>>>\n//    ^?\n","import { hookFirst, hookParallel, hookSeq } from './utils/executeStrategies.ts'\n\nimport type { PossiblePromise } from '@kubb/types'\nimport type { Strategy, StrategySwitch } from './utils/executeStrategies.ts'\n\ntype PromiseFunc<T = unknown, T2 = never> = () => T2 extends never ? Promise<T> : Promise<T> | T2\n\ntype Options<TState = any> = {\n  nullCheck?: (state: TState) => boolean\n}\n\nexport class PromiseManager<TState = any> {\n  #options: Options<TState> = {}\n\n  constructor(options: Options<TState> = {}) {\n    this.#options = options\n\n    return this\n  }\n\n  run<TInput extends Array<PromiseFunc<TValue, null>>, TValue, TStrategy extends Strategy, TOutput = StrategySwitch<TStrategy, TInput, TValue>>(\n    strategy: TStrategy,\n    promises: TInput,\n  ): TOutput {\n    if (strategy === 'seq') {\n      return hookSeq<TInput, TValue, TOutput>(promises)\n    }\n\n    if (strategy === 'first') {\n      return hookFirst<TInput, TValue, TOutput>(promises, this.#options.nullCheck)\n    }\n\n    if (strategy === 'parallel') {\n      return hookParallel<TInput, TValue, TOutput>(promises)\n    }\n\n    throw new Error(`${strategy} not implemented`)\n  }\n}\n\nexport function isPromise<T>(result: PossiblePromise<T>): result is Promise<T> {\n  return !!result && typeof (result as Promise<unknown>)?.then === 'function'\n}\n\nexport function isPromiseFulfilledResult<T = unknown>(result: PromiseSettledResult<unknown>): result is PromiseFulfilledResult<T> {\n  return result.status === 'fulfilled'\n}\n\nexport function isPromiseRejectedResult<T>(result: PromiseSettledResult<unknown>): result is Omit<PromiseRejectedResult, 'reason'> & { reason: T } {\n  return result.status === 'rejected'\n}\n","/**\n * Behaves as an Error to log a warning in the console(still stops the execution)\n */\nexport class Warning extends Error {\n  constructor(message?: string, options?: { cause: Error }) {\n    super(message, { cause: options?.cause })\n\n    this.name = 'Warning'\n  }\n}\n\nexport class ValidationPluginError extends Error {}\n","import path from 'node:path'\n\nimport { createPluginCache } from './utils/cache.ts'\n\nimport type { FileManager } from './FileManager.ts'\nimport type { PluginManager } from './PluginManager.ts'\nimport type { Plugin, PluginContext, PluginFactoryOptions, UserPluginWithLifeCycle } from './types.ts'\n\ntype PluginFactory<T extends PluginFactoryOptions = PluginFactoryOptions> = (options: T['options']) => UserPluginWithLifeCycle<T>\n\ntype OptionalPluginFactory<T extends PluginFactoryOptions = PluginFactoryOptions> = (options?: T['options']) => UserPluginWithLifeCycle<T>\n\nexport function createPlugin<T extends PluginFactoryOptions = PluginFactoryOptions>(factory: PluginFactory<T>): OptionalPluginFactory<T> {\n  return (options = {}) => {\n    return factory(options)\n  }\n}\n\ntype Options = {\n  config: PluginContext['config']\n  fileManager: FileManager\n  pluginManager: PluginManager\n  resolvePath: PluginContext['resolvePath']\n  resolveName: PluginContext['resolveName']\n  logger: PluginContext['logger']\n  getPlugins: () => Array<Plugin>\n  plugin?: PluginContext['plugin']\n}\n\n// not publicly exported\nexport type PluginCore = PluginFactoryOptions<'core', Options, Options, PluginContext, never>\n\nexport const pluginCore = createPlugin<PluginCore>((options) => {\n  const { fileManager, pluginManager, resolvePath, resolveName, logger } = options\n\n  return {\n    name: 'core',\n    options,\n    key: ['core'],\n    api() {\n      return {\n        get config() {\n          return options.config\n        },\n        get plugins() {\n          return options.getPlugins()\n        },\n        get plugin() {\n          // see pluginManger.#execute where we override with `.call` the this with the correct plugin\n          return options.plugin as NonNullable<Options['plugin']>\n        },\n        logger,\n        fileManager,\n        pluginManager,\n        async addFile(...files) {\n          const resolvedFiles = await fileManager.add(...files)\n\n          if (!Array.isArray(resolvedFiles)) {\n            return [resolvedFiles]\n          }\n\n          return resolvedFiles\n        },\n        resolvePath,\n        resolveName,\n        cache: createPluginCache(),\n      }\n    },\n    resolvePath(baseName) {\n      const root = path.resolve(this.config.root, this.config.output.path)\n\n      return path.resolve(root, baseName)\n    },\n    resolveName(name) {\n      return name\n    },\n  }\n})\n","import type { PluginCache } from '../types.ts'\n\nexport interface Cache<TStore extends object = object> {\n  delete(id: keyof TStore): boolean\n  get(id: keyof TStore): TStore[keyof TStore] | null\n  has(id: keyof TStore): boolean\n  set(id: keyof TStore, value: unknown): void\n}\n\nexport function createPluginCache<TStore extends PluginCache>(Store: TStore = Object.create(null) as TStore): Cache<TStore> {\n  return {\n    set(id, value): void {\n      Store[id] = [0, value] as TStore[keyof TStore]\n    },\n    get(id): TStore[keyof TStore] | null {\n      const item = Store[id]\n      if (!item) {\n        return null\n      }\n      item[0] = 0\n      return item[1] as TStore[keyof TStore]\n    },\n    has(id): boolean {\n      const item = Store[id]\n      if (!item) {\n        return false\n      }\n      item[0] = 0\n      return true\n    },\n    delete(id: keyof TStore): boolean {\n      return delete Store[id]\n    },\n  }\n}\n","import type { PossiblePromise } from '@kubb/types'\nimport type { Config, InputPath, UserConfig } from './types.ts'\n\ntype Args = {\n  /**\n   * Path to `kubb.config.js`\n   */\n  config?: string\n  /**\n   * Watch changes on input\n   */\n  watch?: boolean\n\n  /**\n   * Log level to report when using the CLI\n   *\n   * `silent` will hide all information that is not relevant\n   *\n   * `info` will show all information possible(not related to the PluginManager)\n   *\n   * `debug` will show all information possible(related to the PluginManager), handy for seeing logs\n   * @default `silent`\n   */\n  logLevel?: string\n  /**\n   * Run Kubb with Bun\n   */\n  bun?: boolean\n}\n\n/**\n * Type helper to make it easier to use kubb.config.js\n * accepts a direct {@link Config} object, or a function that returns it.\n * The function receives a {@link ConfigEnv} object that exposes two properties:\n */\nexport function defineConfig(\n  options:\n    | PossiblePromise<UserConfig | Array<UserConfig>>\n    | ((\n        /** The options derived from the CLI flags */\n        args: Args,\n      ) => PossiblePromise<UserConfig | Array<UserConfig>>),\n): typeof options {\n  return options\n}\n\nexport function isInputPath(result: Config | undefined): result is Config<InputPath> {\n  return !!result && 'path' in (result as any)\n}\n","/**\n * Abstract class that contains the building blocks for plugins to create their own Generator\n * @link idea based on https://github.com/colinhacks/zod/blob/master/src/types.ts#L137\n */\nexport abstract class Generator<TOptions = unknown, TContext = unknown> {\n  #options: TOptions = {} as TOptions\n  #context: TContext = {} as TContext\n\n  constructor(options?: TOptions, context?: TContext) {\n    if (context) {\n      this.#context = context\n    }\n\n    if (options) {\n      this.#options = options\n    }\n\n    return this\n  }\n\n  get options(): TOptions {\n    return this.#options\n  }\n\n  get context(): TContext {\n    return this.#context\n  }\n\n  set options(options: TOptions) {\n    this.#options = { ...this.#options, ...options }\n  }\n\n  abstract build(...params: unknown[]): unknown\n}\n","import mod from 'node:module'\nimport os from 'node:os'\nimport { pathToFileURL } from 'node:url'\n\nimport { findUp, findUpSync } from 'find-up'\nimport { coerce, satisfies } from 'semver'\n\nimport { read, readSync } from '@kubb/fs'\n\ntype PackageJSON = {\n  dependencies?: Record<string, string>\n  devDependencies?: Record<string, string>\n}\n\ntype DependencyName = string\n\ntype DependencyVersion = string\n\nexport class PackageManager {\n  static #cache: Record<DependencyName, DependencyVersion> = {}\n\n  #cwd?: string\n  #SLASHES = new Set(['/', '\\\\'])\n  constructor(workspace?: string) {\n    if (workspace) {\n      this.#cwd = workspace\n    }\n\n    return this\n  }\n\n  set workspace(workspace: string) {\n    this.#cwd = workspace\n  }\n\n  get workspace(): string | undefined {\n    return this.#cwd\n  }\n\n  normalizeDirectory(directory: string): string {\n    if (!this.#SLASHES.has(directory[directory.length - 1]!)) {\n      return `${directory}/`\n    }\n\n    return directory\n  }\n\n  getLocation(path: string): string {\n    let location = path\n\n    if (this.#cwd) {\n      const require = mod.createRequire(this.normalizeDirectory(this.#cwd))\n      location = require.resolve(path)\n    }\n\n    return location\n  }\n\n  async import(path: string): Promise<any | undefined> {\n    try {\n      let location = this.getLocation(path)\n\n      if (os.platform() === 'win32') {\n        location = pathToFileURL(location).href\n      }\n\n      const module = await import(location)\n\n      return module?.default ?? module\n    } catch (e) {\n      console.log(e)\n      return undefined\n    }\n  }\n\n  async getPackageJSON(): Promise<PackageJSON | undefined> {\n    const pkgPath = await findUp(['package.json'], {\n      cwd: this.#cwd,\n    })\n    if (!pkgPath) {\n      return undefined\n    }\n\n    const json = await read(pkgPath)\n\n    return JSON.parse(json) as PackageJSON\n  }\n\n  getPackageJSONSync(): PackageJSON | undefined {\n    const pkgPath = findUpSync(['package.json'], {\n      cwd: this.#cwd,\n    })\n    if (!pkgPath) {\n      return undefined\n    }\n\n    const json = readSync(pkgPath)\n\n    return JSON.parse(json) as PackageJSON\n  }\n\n  static setVersion(dependency: DependencyName, version: DependencyVersion): void {\n    PackageManager.#cache[dependency] = version\n  }\n\n  #match(packageJSON: PackageJSON, dependency: DependencyName | RegExp): string | undefined {\n    const dependencies = {\n      ...(packageJSON['dependencies'] || {}),\n      ...(packageJSON['devDependencies'] || {}),\n    }\n\n    if (typeof dependency === 'string' && dependencies[dependency]) {\n      return dependencies[dependency]\n    }\n\n    const matchedDependency = Object.keys(dependencies).find((dep) => dep.match(dependency))\n\n    return matchedDependency ? dependencies[matchedDependency] : undefined\n  }\n\n  async getVersion(dependency: DependencyName | RegExp): Promise<DependencyVersion | undefined> {\n    if (typeof dependency === 'string' && PackageManager.#cache[dependency]) {\n      return PackageManager.#cache[dependency]\n    }\n\n    const packageJSON = await this.getPackageJSON()\n\n    if (!packageJSON) {\n      return undefined\n    }\n\n    return this.#match(packageJSON, dependency)\n  }\n\n  getVersionSync(dependency: DependencyName | RegExp): DependencyVersion | undefined {\n    if (typeof dependency === 'string' && PackageManager.#cache[dependency]) {\n      return PackageManager.#cache[dependency]\n    }\n\n    const packageJSON = this.getPackageJSONSync()\n\n    if (!packageJSON) {\n      return undefined\n    }\n\n    return this.#match(packageJSON, dependency)\n  }\n\n  async isValid(dependency: DependencyName | RegExp, version: DependencyVersion): Promise<boolean> {\n    const packageVersion = await this.getVersion(dependency)\n\n    if (!packageVersion) {\n      return false\n    }\n\n    if (packageVersion === version) {\n      return true\n    }\n\n    const semVer = coerce(packageVersion)\n\n    if (!semVer) {\n      throw new Error(`${packageVersion} is not valid`)\n    }\n\n    return satisfies(semVer, version)\n  }\n  isValidSync(dependency: DependencyName | RegExp, version: DependencyVersion): boolean {\n    const packageVersion = this.getVersionSync(dependency)\n\n    if (!packageVersion) {\n      return false\n    }\n    const semVer = coerce(packageVersion)\n\n    if (!semVer) {\n      throw new Error(`${packageVersion} is not valid`)\n    }\n\n    return satisfies(semVer, version)\n  }\n}\n"],"mappings":"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","names":["path","plugin","path","files","_options","read","readSync","path","require","read","readSync"]}