{"version":3,"sources":["/home/runner/work/kubb/kubb/packages/core/dist/chunk-2IH3FIGI.cjs","../src/utils/index.ts","../src/utils/FunctionParams.ts","../src/utils/promise.ts","../src/utils/renderTemplate.ts","../src/utils/timeout.ts","../src/utils/uniqueName.ts","../src/utils/URLPath.ts","../src/utils/getParser.ts"],"names":["item","_a"],"mappings":"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","file":"/home/runner/work/kubb/kubb/packages/core/dist/chunk-2IH3FIGI.cjs","sourcesContent":[null,"export type { FunctionParamsAST } from './FunctionParams.ts'\nexport { FunctionParams } from './FunctionParams.ts'\nexport {\n  isPromise,\n  isPromiseFulfilledResult,\n  isPromiseRejectedResult,\n} from './promise.ts'\nexport { renderTemplate } from './renderTemplate.ts'\nexport { timeout } from './timeout.ts'\nexport { getUniqueName, setUniqueName } from './uniqueName.ts'\nexport type { URLObject } from './URLPath.ts'\nexport { URLPath } from './URLPath.ts'\nexport { getParser } from './getParser.ts'\n","import { orderBy } from 'natural-orderby'\n\nimport { camelCase } from '../transformers/casing.ts'\n\ntype FunctionParamsASTWithoutType = {\n  name?: string\n  type?: string\n  /**\n   * @default true\n   */\n  required?: boolean\n  /**\n   * @default true\n   */\n  enabled?: boolean\n  default?: string\n}\n\ntype FunctionParamsASTWithType = {\n  name?: never\n  type: string\n  /**\n   * @default true\n   */\n  required?: boolean\n  /**\n   * @default true\n   */\n  enabled?: boolean\n  default?: string\n}\n/**\n * @deprecated\n */\nexport type FunctionParamsAST = FunctionParamsASTWithoutType | FunctionParamsASTWithType\n\n/**\n * @deprecated\n */\nexport class FunctionParams {\n  #items: Array<FunctionParamsAST | FunctionParamsAST[]> = []\n  constructor() {\n    return this\n  }\n\n  get items(): FunctionParamsAST[] {\n    return this.#items.flat()\n  }\n\n  add(item: FunctionParamsAST | Array<FunctionParamsAST | FunctionParamsAST[] | undefined> | undefined): FunctionParams {\n    if (!item) {\n      return this\n    }\n\n    if (Array.isArray(item)) {\n      item.filter(Boolean).forEach((it) => this.#items.push(it))\n      return this\n    }\n    this.#items.push(item)\n\n    return this\n  }\n  static #orderItems(items: Array<FunctionParamsAST | FunctionParamsAST[]>) {\n    return orderBy(\n      items.filter(Boolean),\n      [\n        (v) => {\n          if (Array.isArray(v)) {\n            return undefined\n          }\n          return !v.default\n        },\n        (v) => {\n          if (Array.isArray(v)) {\n            return undefined\n          }\n          return v.required ?? true\n        },\n      ],\n      ['desc', 'desc'],\n    )\n  }\n\n  static #addParams(acc: string[], item: FunctionParamsAST) {\n    const { enabled = true, name, type, required = true, ...rest } = item\n\n    if (!enabled) {\n      return acc\n    }\n\n    if (!name) {\n      // when name is not se we will use TypeScript generics\n      acc.push(`${type}${rest.default ? ` = ${rest.default}` : ''}`)\n\n      return acc\n    }\n    // TODO check whey we still need the camelcase here\n    const parameterName = name.startsWith('{') ? name : camelCase(name)\n\n    if (type) {\n      if (required) {\n        acc.push(`${parameterName}: ${type}${rest.default ? ` = ${rest.default}` : ''}`)\n      } else {\n        acc.push(`${parameterName}?: ${type}`)\n      }\n    } else {\n      acc.push(`${parameterName}`)\n    }\n\n    return acc\n  }\n\n  static toObject(items: FunctionParamsAST[]): FunctionParamsAST {\n    let type: string[] = []\n    let name: string[] = []\n\n    const enabled = items.every((item) => item.enabled) ? items.at(0)?.enabled : true\n    const required = items.every((item) => item.required) ?? true\n\n    items.forEach((item) => {\n      name = FunctionParams.#addParams(name, { ...item, type: undefined })\n      if (items.some((item) => item.type)) {\n        type = FunctionParams.#addParams(type, item)\n      }\n    })\n\n    return {\n      name: `{ ${name.join(', ')} }`,\n      type: type.length ? `{ ${type.join('; ')} }` : undefined,\n      enabled,\n      required,\n    }\n  }\n\n  static toString(items: (FunctionParamsAST | FunctionParamsAST[])[]): string {\n    const sortedData = FunctionParams.#orderItems(items)\n\n    return sortedData\n      .reduce((acc, item) => {\n        if (Array.isArray(item)) {\n          if (item.length <= 0) {\n            return acc\n          }\n          const subItems = FunctionParams.#orderItems(item) as FunctionParamsAST[]\n          const objectItem = FunctionParams.toObject(subItems)\n\n          return FunctionParams.#addParams(acc, objectItem)\n        }\n\n        return FunctionParams.#addParams(acc, item)\n      }, [] as string[])\n      .join(', ')\n  }\n\n  toObject(): FunctionParamsAST {\n    const items = FunctionParams.#orderItems(this.#items).flat()\n\n    return FunctionParams.toObject(items)\n  }\n\n  toString(): string {\n    const items = FunctionParams.#orderItems(this.#items)\n\n    return FunctionParams.toString(items)\n  }\n}\n","import type { PossiblePromise } from '@kubb/types'\n\nexport function isPromise<T>(result: PossiblePromise<T>): result is Promise<T> {\n  return !!result && typeof (result as Promise<unknown>)?.then === 'function'\n}\n\nexport function isPromiseFulfilledResult<T = unknown>(result: PromiseSettledResult<unknown>): result is PromiseFulfilledResult<T> {\n  return result.status === 'fulfilled'\n}\n\nexport function isPromiseRejectedResult<T>(result: PromiseSettledResult<unknown>): result is Omit<PromiseRejectedResult, 'reason'> & { reason: T } {\n  return result.status === 'rejected'\n}\n","export function renderTemplate<TData extends Record<string, unknown> = Record<string, unknown>>(template: string, data: TData | undefined = undefined): string {\n  if (!data || !Object.keys(data).length) {\n    return template.replace(/{{(.*?)}}/g, '')\n  }\n\n  const matches = template.match(/{{(.*?)}}/g)\n\n  return (\n    matches?.reduce((prev, curr) => {\n      const index = curr.split(/{{|}}/).filter(Boolean)[0]?.trim()\n      if (index === undefined) {\n        return prev\n      }\n      const value = data[index]\n\n      if (value === undefined) {\n        return prev\n      }\n\n      return prev\n        .replace(curr, () => {\n          if (typeof value === 'boolean') {\n            return `${value.toString()}` || 'false'\n          }\n\n          return (value as string) || ''\n        })\n        .trim()\n    }, template) || ''\n  )\n}\n","export async function timeout(ms: number): Promise<unknown> {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(true)\n    }, ms)\n  })\n}\n","export function getUniqueName(originalName: string, data: Record<string, number>): string {\n  let used = data[originalName] || 0\n  if (used) {\n    data[originalName] = ++used\n    originalName += used\n  }\n  data[originalName] = 1\n  return originalName\n}\n\nexport function setUniqueName(originalName: string, data: Record<string, number>): string {\n  let used = data[originalName] || 0\n  if (used) {\n    data[originalName] = ++used\n\n    return originalName\n  }\n  data[originalName] = 1\n  return originalName\n}\n","import { camelCase } from '../transformers/casing.ts'\n\nexport type URLObject = {\n  url: string\n  params?: Record<string, string>\n}\n\ntype ObjectOptions = {\n  type?: 'path' | 'template'\n  replacer?: (pathParam: string) => string\n  stringify?: boolean\n}\n\nexport class URLPath {\n  path: string\n\n  constructor(path: string) {\n    this.path = path\n\n    return this\n  }\n\n  /**\n   * Convert Swagger path to URLPath(syntax of Express)\n   * @example /pet/{petId} => /pet/:petId\n   */\n  get URL(): string {\n    return this.toURLPath()\n  }\n  get isURL(): boolean {\n    try {\n      const url = new URL(this.path)\n      if (url?.href) {\n        return true\n      }\n    } catch (error) {\n      return false\n    }\n    return false\n  }\n\n  /**\n   * Convert Swagger path to template literals/ template strings(camelcase)\n   * @example /pet/{petId} => `/pet/${petId}`\n   * @example /account/monetary-accountID => `/account/${monetaryAccountId}`\n   * @example /account/userID => `/account/${userId}`\n   */\n  get template(): string {\n    return this.toTemplateString()\n  }\n  get object(): URLObject | string {\n    return this.toObject()\n  }\n  get params(): Record<string, string> | undefined {\n    return this.getParams()\n  }\n\n  toObject({ type = 'path', replacer, stringify }: ObjectOptions = {}): URLObject | string {\n    const object = {\n      url: type === 'path' ? this.toURLPath() : this.toTemplateString(replacer),\n      params: this.getParams(),\n    }\n\n    if (stringify) {\n      if (type === 'template') {\n        return JSON.stringify(object).replaceAll(\"'\", '').replaceAll(`\"`, '')\n      }\n\n      if (object.params) {\n        return `{ url: '${object.url}', params: ${JSON.stringify(object.params).replaceAll(\"'\", '').replaceAll(`\"`, '')} }`\n      }\n\n      return `{ url: '${object.url}' }`\n    }\n\n    return object\n  }\n\n  /**\n   * Convert Swagger path to template literals/ template strings(camelcase)\n   * @example /pet/{petId} => `/pet/${petId}`\n   * @example /account/monetary-accountID => `/account/${monetaryAccountId}`\n   * @example /account/userID => `/account/${userId}`\n   */\n  toTemplateString(replacer?: (pathParam: string) => string): string {\n    const regex = /{(\\w|-)*}/g\n    const found = this.path.match(regex)\n    let newPath = this.path.replaceAll('{', '${')\n\n    if (found) {\n      newPath = found.reduce((prev, curr) => {\n        const pathParam = replacer ? replacer(camelCase(curr)) : camelCase(curr)\n        const replacement = `\\${${pathParam}}`\n\n        return prev.replace(curr, replacement)\n      }, this.path)\n    }\n\n    return `\\`${newPath}\\``\n  }\n\n  getParams(replacer?: (pathParam: string) => string): Record<string, string> | undefined {\n    const regex = /{(\\w|-)*}/g\n    const found = this.path.match(regex)\n\n    if (!found) {\n      return undefined\n    }\n\n    const params: Record<string, string> = {}\n    found.forEach((item) => {\n      item = item.replaceAll('{', '').replaceAll('}', '')\n\n      const pathParam = replacer ? replacer(camelCase(item)) : camelCase(item)\n\n      params[pathParam] = pathParam\n    }, this.path)\n\n    return params\n  }\n\n  /**\n   * Convert Swagger path to URLPath(syntax of Express)\n   * @example /pet/{petId} => /pet/:petId\n   */\n  toURLPath(): string {\n    return this.path.replaceAll('{', ':').replaceAll('}', '')\n  }\n}\n","type ParserModuleTs = typeof import('@kubb/parser-ts')\n\nexport type ParserModule = ParserModuleTs\n\nexport async function getParser(language: string | undefined) {\n  let modulePromise: Promise<ParserModule>\n\n  switch (language) {\n    default:\n      modulePromise = import('@kubb/parser-ts')\n      break\n  }\n\n  const module = await modulePromise\n\n  return module\n}\n"]}