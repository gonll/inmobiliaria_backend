{"version":3,"sources":["../src/utils.ts","../src/Oas.ts"],"sourcesContent":["import { isRef, isSchema } from 'oas/types'\nimport { isPlainObject } from 'remeda'\n\nimport type { ParameterObject, SchemaObject } from 'oas/types'\nimport type { OpenAPIV2, OpenAPIV3, OpenAPIV3_1 } from 'openapi-types'\n\nexport function isOpenApiV2Document(doc: any): doc is OpenAPIV2.Document {\n  return doc && isPlainObject(doc) && !('openapi' in doc)\n}\nexport function isOpenApiV3Document(doc: any): doc is OpenAPIV3.Document {\n  return doc && isPlainObject(doc) && 'openapi' in doc\n}\n\nexport function isOpenApiV3_1Document(doc: any): doc is OpenAPIV3_1.Document {\n  return doc && isPlainObject<OpenAPIV3_1.Document>(doc) && 'openapi' in doc && doc.openapi.startsWith('3.1')\n}\n\nexport function isJSONSchema(obj?: unknown): obj is SchemaObject {\n  return !!obj && isSchema(obj)\n}\n\nexport function isParameterObject(obj: ParameterObject | SchemaObject): obj is ParameterObject {\n  return obj && 'in' in obj\n}\n\nexport function isReference(obj?: unknown): obj is OpenAPIV3.ReferenceObject | OpenAPIV3_1.ReferenceObject {\n  return !!obj && isRef(obj)\n}\n\nexport function isRequired(schema?: SchemaObject): boolean {\n  if (!schema) {\n    return false\n  }\n\n  return Array.isArray(schema.required) ? !!schema.required?.length : !!schema.required\n}\n\nexport function isOptional(schema?: SchemaObject): boolean {\n  return !isRequired(schema)\n}\n","import BaseOas from 'oas'\nimport OASNormalize from 'oas-normalize'\nimport { matchesMimeType } from 'oas/utils'\n\nimport jsonpointer from 'jsonpointer'\n\nimport { isReference } from './utils.ts'\n\nimport type { Operation } from 'oas/operation'\nimport type { MediaTypeObject, OASDocument, ResponseObject, SchemaObject, User } from 'oas/types'\nimport type { OasTypes, OpenAPIV3 } from './index.ts'\nimport type { contentType } from './types.ts'\n\ntype Options = {\n  contentType?: contentType\n}\n\nexport class Oas<const TOAS = unknown> extends BaseOas {\n  #options: Options = {}\n  document: TOAS = undefined as unknown as TOAS\n\n  constructor({ oas, user }: { oas: TOAS | OASDocument | string; user?: User }, options: Options = {}) {\n    if (typeof oas === 'string') {\n      oas = JSON.parse(oas)\n    }\n\n    super(oas as OASDocument, user)\n\n    this.document = oas as TOAS\n    this.#options = options\n  }\n\n  get($ref: string) {\n    const origRef = $ref\n    $ref = $ref.trim()\n    if ($ref === '') {\n      return false\n    }\n    if ($ref.startsWith('#')) {\n      $ref = globalThis.decodeURIComponent($ref.substring(1))\n    } else {\n      throw new Error(`Could not find a definition for ${origRef}.`)\n    }\n    const current = jsonpointer.get(this.api, $ref)\n\n    if (!current) {\n      throw new Error(`Could not find a definition for ${origRef}.`)\n    }\n    return current\n  }\n\n  set($ref: string, value: unknown) {\n    const origRef = $ref\n    $ref = $ref.trim()\n    if ($ref === '') {\n      return false\n    }\n    if ($ref.startsWith('#')) {\n      $ref = globalThis.decodeURIComponent($ref.substring(1))\n    } else {\n      throw new Error(`Could not find a definition for ${origRef}.`)\n    }\n\n    jsonpointer.set(this.api, $ref, value)\n  }\n\n  resolveDiscriminators(): void {\n    const schemas = (this.api.components?.schemas || {}) as Record<string, OasTypes.SchemaObject>\n\n    Object.entries(schemas).forEach(([key, schemaObject]) => {\n      if ('discriminator' in schemaObject) {\n        const { mapping = {}, propertyName } = (schemaObject.discriminator || {}) as OpenAPIV3.DiscriminatorObject\n\n        Object.entries(mapping).forEach(([mappingKey, mappingValue]) => {\n          if (mappingValue) {\n            const childSchema = this.get(mappingValue)\n            const property = childSchema.properties?.[propertyName] as SchemaObject\n\n            if (property) {\n              childSchema.properties[propertyName] = {\n                ...childSchema.properties[propertyName],\n                enum: [...(property?.enum?.filter((value) => value !== mappingKey) ?? []), mappingKey],\n              }\n\n              childSchema.required = [...(childSchema.required ?? []), propertyName]\n\n              this.set(mappingValue, childSchema)\n            }\n          }\n        })\n      }\n    })\n  }\n\n  dereferenceWithRef(schema?: unknown) {\n    if (isReference(schema)) {\n      return {\n        ...this.get(schema.$ref),\n        $ref: schema.$ref,\n      }\n    }\n\n    return schema\n  }\n\n  /**\n   * Oas does not have a getResponseBody(contentType)\n   */\n  #getResponseBodyFactory(responseBody: boolean | ResponseObject): (contentType?: string) => MediaTypeObject | false | [string, MediaTypeObject, ...string[]] {\n    function hasResponseBody(res = responseBody): res is ResponseObject {\n      return !!res\n    }\n\n    return (contentType) => {\n      if (!hasResponseBody(responseBody)) {\n        return false\n      }\n\n      if (isReference(responseBody)) {\n        // If the request body is still a `$ref` pointer we should return false because this library\n        // assumes that you've run dereferencing beforehand.\n        return false\n      }\n\n      if (!responseBody.content) {\n        return false\n      }\n\n      if (contentType) {\n        if (!(contentType in responseBody.content)) {\n          return false\n        }\n\n        return responseBody.content[contentType]!\n      }\n\n      // Since no media type was supplied we need to find either the first JSON-like media type that\n      // we've got, or the first available of anything else if no JSON-like media types are present.\n      let availablecontentType: string | undefined = undefined\n      const contentTypes = Object.keys(responseBody.content)\n      contentTypes.forEach((mt: string) => {\n        if (!availablecontentType && matchesMimeType.json(mt)) {\n          availablecontentType = mt\n        }\n      })\n\n      if (!availablecontentType) {\n        contentTypes.forEach((mt: string) => {\n          if (!availablecontentType) {\n            availablecontentType = mt\n          }\n        })\n      }\n\n      if (availablecontentType) {\n        return [availablecontentType, responseBody.content[availablecontentType]!, ...(responseBody.description ? [responseBody.description] : [])]\n      }\n\n      return false\n    }\n  }\n\n  getResponseSchema(operation: Operation, statusCode: string | number): SchemaObject {\n    if (operation.schema.responses) {\n      Object.keys(operation.schema.responses).forEach((key) => {\n        const schema = operation.schema.responses![key]\n        const $ref = isReference(schema) ? schema.$ref : undefined\n\n        if (schema && $ref) {\n          operation.schema.responses![key] = this.get($ref)\n        }\n      })\n    }\n\n    const getResponseBody = this.#getResponseBodyFactory(operation.getResponseByStatusCode(statusCode))\n\n    const { contentType } = this.#options\n    const responseBody = getResponseBody(contentType)\n\n    if (responseBody === false) {\n      // return empty object because response will always be defined(request does not need a body)\n      return {}\n    }\n\n    const schema = Array.isArray(responseBody) ? responseBody[1].schema : responseBody.schema\n\n    if (!schema) {\n      // return empty object because response will always be defined(request does not need a body)\n\n      return {}\n    }\n\n    return this.dereferenceWithRef(schema)\n  }\n\n  getRequestSchema(operation: Operation): SchemaObject | undefined {\n    const { contentType } = this.#options\n\n    if (operation.schema.requestBody) {\n      operation.schema.requestBody = this.dereferenceWithRef(operation.schema.requestBody)\n    }\n\n    const requestBody = operation.getRequestBody(contentType)\n\n    if (requestBody === false) {\n      return undefined\n    }\n\n    const schema = Array.isArray(requestBody) ? requestBody[1].schema : requestBody.schema\n\n    if (!schema) {\n      return undefined\n    }\n\n    return this.dereferenceWithRef(schema)\n  }\n\n  getParametersSchema(operation: Operation, inKey: 'path' | 'query' | 'header'): SchemaObject | null {\n    const { contentType = operation.getContentType() } = this.#options\n    const params = operation\n      .getParameters()\n      .map((schema) => {\n        return this.dereferenceWithRef(schema)\n      })\n      .filter((v) => v.in === inKey)\n\n    if (!params.length) {\n      return null\n    }\n\n    return params.reduce(\n      (schema, pathParameters) => {\n        const property = pathParameters.content?.[contentType]?.schema ?? (pathParameters.schema as SchemaObject)\n        const required = [...(schema.required || ([] as any)), pathParameters.required ? pathParameters.name : undefined].filter(Boolean)\n\n        return {\n          ...schema,\n          description: schema.description,\n          deprecated: schema.deprecated,\n          example: schema.example,\n          required,\n          properties: {\n            ...schema.properties,\n            [pathParameters.name]: {\n              description: pathParameters.description,\n              ...property,\n            },\n          },\n        }\n      },\n      { type: 'object', required: [], properties: {} } as SchemaObject,\n    )\n  }\n\n  async valdiate() {\n    const oasNormalize = new OASNormalize(this.api, {\n      enablePaths: true,\n      colorizeErrors: true,\n    })\n\n    await oasNormalize.validate({\n      parser: {\n        validate: {\n          colorizeErrors: true,\n          schema: false,\n          spec: false,\n        },\n      },\n    })\n  }\n}\n"],"mappings":"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","names":["schema"]}