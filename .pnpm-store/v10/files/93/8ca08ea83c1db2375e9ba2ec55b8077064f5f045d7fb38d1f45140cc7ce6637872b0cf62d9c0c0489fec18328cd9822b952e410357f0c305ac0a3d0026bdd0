{"version":3,"sources":["/home/runner/work/kubb/kubb/packages/react/dist/chunk-VJFHH3RA.cjs","../src/components/Parser.tsx","../src/components/File.tsx","../src/hooks/useIndent.ts","../src/components/App.tsx"],"names":["import_react","import_jsx_runtime"],"mappings":"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","file":"/home/runner/work/kubb/kubb/packages/react/dist/chunk-VJFHH3RA.cjs","sourcesContent":[null,"import { createContext, useContext } from 'react'\n\nimport type { KubbNode } from '../types.ts'\n\nexport type ParserLanguage = 'typescript' | 'text' | (string & {})\n\nexport type ParserContextProps = {\n  language: ParserLanguage\n}\n\nconst ParserContext = createContext<ParserContextProps>({ language: 'text' })\n\ntype Props = {\n  /**\n   * Name of the language used.\n   * @default 'text'\n   */\n  language?: ParserContextProps['language']\n  children?: KubbNode\n}\n\nexport function TypeScript({ children }: Omit<Props, 'language'>): KubbNode {\n  const context = useContext(ParserContext)\n\n  if (context.language !== 'typescript') {\n    return null\n  }\n\n  return children\n}\n\nexport function Parser({ language = 'text', children }: Props): KubbNode {\n  return (\n    <kubb-parser language={language}>\n      <ParserContext.Provider value={{ language }}>{children}</ParserContext.Provider>\n    </kubb-parser>\n  )\n}\n\nParser.TypeScript = TypeScript\nParser.Context = ParserContext\n","import { createContext } from 'react'\n\nimport type { FileMetaBase } from '@kubb/core'\nimport type * as KubbFile from '@kubb/fs/types'\nimport type { KubbNode } from '../types.ts'\n\nexport type FileContextProps<TMeta extends FileMetaBase = FileMetaBase> = {\n  /**\n   * Name to be used to dynamicly create the baseName(based on input.path).\n   * Based on UNIX basename\n   * @link https://nodejs.org/api/path.html#pathbasenamepath-suffix\n   */\n  baseName: KubbFile.BaseName\n  /**\n   * Path will be full qualified path to a specified file.\n   */\n  path: KubbFile.Path\n  meta?: TMeta\n}\nconst FileContext = createContext<FileContextProps>({} as FileContextProps)\n\ntype BasePropsWithBaseName = {\n  /**\n   * Name to be used to dynamicly create the baseName(based on input.path).\n   * Based on UNIX basename\n   * @link https://nodejs.org/api/path.html#pathbasenamepath-suffix\n   */\n  baseName: KubbFile.BaseName\n  /**\n   * Path will be full qualified path to a specified file.\n   */\n  path: KubbFile.Path\n}\n\ntype BasePropsWithoutBaseName = {\n  baseName?: never\n  /**\n   * Path will be full qualified path to a specified file.\n   */\n  path?: KubbFile.Path\n}\n\ntype BaseProps = BasePropsWithBaseName | BasePropsWithoutBaseName\n\ntype Props<TMeta extends FileMetaBase = FileMetaBase> = BaseProps & {\n  /**\n   * Unique identifier to reuse later.\n   * @default crypto.randomUUID()\n   */\n  id?: KubbFile.File['id']\n  /**\n   * This will override `process.env[key]` inside the `source`, see `getFileSource`.\n   */\n  env?: KubbFile.File['env']\n  /**\n   * This will call fileManager.add instead of fileManager.addOrAppend, adding the source when the files already exists.\n   * This will also ignore the combinefiles utils\n   * @default `false`\n   */\n  override?: KubbFile.File['override']\n  /**\n   * Override if a file can be exported by the BarrelManager\n   * @default true\n   */\n  exportable?: boolean\n  meta?: TMeta\n  children?: KubbNode\n}\n\nexport function File<TMeta extends FileMetaBase = FileMetaBase>({ children, exportable = true, ...rest }: Props<TMeta>): KubbNode {\n  if (!rest.baseName || !rest.path) {\n    return children\n  }\n\n  return (\n    <kubb-file exportable={exportable} {...rest}>\n      <FileContext.Provider value={{ baseName: rest.baseName, path: rest.path, meta: rest.meta }}>{children}</FileContext.Provider>\n    </kubb-file>\n  )\n}\n\ntype FileSourceUnionProps =\n  | {\n      /**\n       * When path is set it will copy-paste that file as a string inside the component.\n       * Children will then be ignored\n       */\n      path?: string\n      children?: never\n    }\n  | {\n      /**\n       * When path is set it will copy-paste that file as a string inside the component.\n       * Children will then be ignored\n       */\n      path?: never\n      children?: KubbNode\n    }\n\ntype FileSourceProps = FileSourceUnionProps & {\n  /**\n   * When true, it will return the generated import.\n   * When false, it will add the import to a KubbFile instance(see fileManager).\n   */\n  print?: boolean\n}\n\nfunction FileSource({ path, print, children }: FileSourceProps): KubbNode {\n  return (\n    <kubb-source path={path} print={print}>\n      {children}\n    </kubb-source>\n  )\n}\n\ntype FileExportProps = KubbFile.Export & {\n  /**\n   * When true, it will return the generated import.\n   * When false, it will add the import to a KubbFile instance(see fileManager)\n   */\n  print?: boolean\n}\n\nfunction FileExport({ name, path, isTypeOnly, asAlias, print, extName }: FileExportProps): KubbNode {\n  return <kubb-export name={name} path={path} isTypeOnly={isTypeOnly || false} extName={extName} asAlias={asAlias} print={print} />\n}\n\ntype FileImportProps = KubbFile.Import & {\n  /**\n   * When true, it will return the generated import.\n   * When false, it will add the import to a KubbFile instance(see fileManager).\n   */\n  print?: boolean\n}\n\nexport function FileImport({ name, root, path, isTypeOnly, isNameSpace, extName, print }: FileImportProps): KubbNode {\n  return <kubb-import name={name} root={root} path={path} isNameSpace={isNameSpace} extName={extName} isTypeOnly={isTypeOnly || false} print={print} />\n}\n\nFile.Export = FileExport\nFile.Import = FileImport\nFile.Source = FileSource\nFile.Context = FileContext\n","import transformers from '@kubb/core/transformers'\n\nimport type { KubbNode } from '../types.ts'\n\ntype Props = {\n  /**\n   * Size to use for the indenting\n   */\n  size: number\n  children?: KubbNode\n}\n\nexport function useIndent({ size, children }: Props): KubbNode {\n  let indentWithChildren: KubbNode\n\n  if (!children) {\n    return transformers.createIndent(size)\n  }\n\n  if (typeof children === 'string') {\n    indentWithChildren = children.replaceAll('\\n', `\\n${transformers.createIndent(size)}`)\n  }\n\n  if (Array.isArray(children)) {\n    indentWithChildren = children.map((child) => {\n      let text: string = child as string\n\n      if (typeof text === 'string') {\n        if (text.startsWith('\\n')) {\n          text = text.replace('\\n', '')\n        }\n        if (text.substring(text.length - 1, text.length) === '\\n') {\n          text = text.substring(0, text.length - 2)\n        }\n        text = text.replaceAll('\\n', `\\n${transformers.createIndent(size)}`)\n      }\n      return text\n    })\n  }\n\n  return indentWithChildren\n}\n","import { createContext } from 'react'\n\nimport type { Plugin, PluginManager } from '@kubb/core'\nimport type * as KubbFile from '@kubb/fs/types'\nimport type { KubbNode } from '../types.ts'\n\nexport type AppContextProps = {\n  mode: KubbFile.Mode\n  pluginManager: PluginManager\n  plugin: Plugin\n}\n\nconst AppContext = createContext<AppContextProps | undefined>(undefined)\n\ntype Props = {\n  mode: KubbFile.Mode\n  pluginManager: PluginManager\n  plugin: Plugin\n  children?: KubbNode\n}\n\nexport function App({ plugin, pluginManager, mode, children }: Props): KubbNode {\n  return <AppContext.Provider value={{ plugin, pluginManager, mode }}>{children}</AppContext.Provider>\n}\n\nApp.Context = AppContext\n"]}