{"version":3,"sources":["/home/runner/work/kubb/kubb/packages/core/dist/chunk-KTZ6EAKP.cjs","../../../node_modules/.pnpm/natural-orderby@3.0.2/node_modules/natural-orderby/dist/index.js","../src/transformers/casing.ts","../../../node_modules/.pnpm/change-case@5.4.4/node_modules/change-case/src/index.ts"],"names":["compareNumbers","compareUnicode","stringCompare","compareChunks","compareOtherTypes","compareValues","normalizeAlphaChunk","parseNumber","normalizeNumericChunk","createChunkMap","createChunks","createChunkMaps","isFunction","isNaN","isNull","isObject","isSymbol","isUndefined","parseDate","numberify","stringify","getMappedValueRecord","compareMultiple","createIdentifierFn","getElementByIndex","getValueByIdentifier","baseOrderBy","getIdentifiers","getOrders","pascalCase"],"mappings":"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","file":"/home/runner/work/kubb/kubb/packages/core/dist/chunk-KTZ6EAKP.cjs","sourcesContent":[null,"/**\n * natural-orderby v3.0.2\n *\n * Copyright (c) Olaf Ennen\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nvar compareNumbers = function compareNumbers(numberA, numberB) {\n  if (numberA < numberB) {\n    return -1;\n  }\n  if (numberA > numberB) {\n    return 1;\n  }\n  return 0;\n};\n\nvar compareUnicode = function compareUnicode(stringA, stringB) {\n  var result = stringA.localeCompare(stringB);\n  return result ? result / Math.abs(result) : 0;\n};\n\nvar RE_NUMBERS = /(^0x[\\da-fA-F]+$|^([+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?(?!\\.\\d+)(?=\\D|\\s|$))|\\d+)/g;\nvar RE_LEADING_OR_TRAILING_WHITESPACES = /^\\s+|\\s+$/g; // trim pre-post whitespace\nvar RE_WHITESPACES = /\\s+/g; // normalize all whitespace to single ' ' character\nvar RE_INT_OR_FLOAT = /^[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?$/; // identify integers and floats\nvar RE_DATE = /(^([\\w ]+,?[\\w ]+)?[\\w ]+,?[\\w ]+\\d+:\\d+(:\\d+)?[\\w ]?|^\\d{1,4}[/-]\\d{1,4}[/-]\\d{1,4}|^\\w+, \\w+ \\d+, \\d{4})/; // identify date strings\nvar RE_LEADING_ZERO = /^0+[1-9]{1}[0-9]*$/;\n// eslint-disable-next-line no-control-regex\nvar RE_UNICODE_CHARACTERS = /[^\\x00-\\x80]/;\n\nvar stringCompare = function stringCompare(stringA, stringB) {\n  if (stringA < stringB) {\n    return -1;\n  }\n  if (stringA > stringB) {\n    return 1;\n  }\n  return 0;\n};\n\nvar compareChunks = function compareChunks(chunksA, chunksB) {\n  var lengthA = chunksA.length;\n  var lengthB = chunksB.length;\n  var size = Math.min(lengthA, lengthB);\n  for (var i = 0; i < size; i++) {\n    var chunkA = chunksA[i];\n    var chunkB = chunksB[i];\n    if (chunkA.normalizedString !== chunkB.normalizedString) {\n      if (chunkA.normalizedString === '' !== (chunkB.normalizedString === '')) {\n        // empty strings have lowest value\n        return chunkA.normalizedString === '' ? -1 : 1;\n      }\n      if (chunkA.parsedNumber !== undefined && chunkB.parsedNumber !== undefined) {\n        // compare numbers\n        var result = compareNumbers(chunkA.parsedNumber, chunkB.parsedNumber);\n        if (result === 0) {\n          // compare string value, if parsed numbers are equal\n          // Example:\n          // chunkA = { parsedNumber: 1, normalizedString: \"001\" }\n          // chunkB = { parsedNumber: 1, normalizedString: \"01\" }\n          // chunkA.parsedNumber === chunkB.parsedNumber\n          // chunkA.normalizedString < chunkB.normalizedString\n          return stringCompare(chunkA.normalizedString, chunkB.normalizedString);\n        }\n        return result;\n      } else if (chunkA.parsedNumber !== undefined || chunkB.parsedNumber !== undefined) {\n        // number < string\n        return chunkA.parsedNumber !== undefined ? -1 : 1;\n      } else if (RE_UNICODE_CHARACTERS.test(chunkA.normalizedString + chunkB.normalizedString)) {\n        // use locale comparison only if one of the chunks contains unicode characters\n        return compareUnicode(chunkA.normalizedString, chunkB.normalizedString);\n      } else {\n        // use common string comparison for performance reason\n        return stringCompare(chunkA.normalizedString, chunkB.normalizedString);\n      }\n    }\n  }\n  // if the chunks are equal so far, the one which has more chunks is greater than the other one\n  if (lengthA > size || lengthB > size) {\n    return lengthA <= size ? -1 : 1;\n  }\n  return 0;\n};\n\nvar compareOtherTypes = function compareOtherTypes(valueA, valueB) {\n  if (!valueA.chunks ? valueB.chunks : !valueB.chunks) {\n    return !valueA.chunks ? 1 : -1;\n  }\n  if (valueA.isNaN ? !valueB.isNaN : valueB.isNaN) {\n    return valueA.isNaN ? -1 : 1;\n  }\n  if (valueA.isSymbol ? !valueB.isSymbol : valueB.isSymbol) {\n    return valueA.isSymbol ? -1 : 1;\n  }\n  if (valueA.isObject ? !valueB.isObject : valueB.isObject) {\n    return valueA.isObject ? -1 : 1;\n  }\n  if (valueA.isArray ? !valueB.isArray : valueB.isArray) {\n    return valueA.isArray ? -1 : 1;\n  }\n  if (valueA.isFunction ? !valueB.isFunction : valueB.isFunction) {\n    return valueA.isFunction ? -1 : 1;\n  }\n  if (valueA.isNull ? !valueB.isNull : valueB.isNull) {\n    return valueA.isNull ? -1 : 1;\n  }\n  return 0;\n};\n\nvar compareValues = function compareValues(valueA, valueB) {\n  if (valueA.value === valueB.value) {\n    return 0;\n  }\n  if (valueA.parsedNumber !== undefined && valueB.parsedNumber !== undefined) {\n    return compareNumbers(valueA.parsedNumber, valueB.parsedNumber);\n  }\n  if (valueA.chunks && valueB.chunks) {\n    return compareChunks(valueA.chunks, valueB.chunks);\n  }\n  return compareOtherTypes(valueA, valueB);\n};\n\nvar normalizeAlphaChunk = function normalizeAlphaChunk(chunk) {\n  return chunk.replace(RE_WHITESPACES, ' ').replace(RE_LEADING_OR_TRAILING_WHITESPACES, '');\n};\n\nvar parseNumber = function parseNumber(value) {\n  if (value.length !== 0) {\n    var parsedNumber = Number(value);\n    if (!Number.isNaN(parsedNumber)) {\n      return parsedNumber;\n    }\n  }\n  return undefined;\n};\n\nvar normalizeNumericChunk = function normalizeNumericChunk(chunk, index, chunks) {\n  if (RE_INT_OR_FLOAT.test(chunk)) {\n    // don´t parse a number, if there´s a preceding decimal point\n    // to keep significance\n    // e.g. 1.0020, 1.020\n    if (!RE_LEADING_ZERO.test(chunk) || index === 0 || chunks[index - 1] !== '.') {\n      return parseNumber(chunk) || 0;\n    }\n  }\n  return undefined;\n};\n\nvar createChunkMap = function createChunkMap(chunk, index, chunks) {\n  return {\n    parsedNumber: normalizeNumericChunk(chunk, index, chunks),\n    normalizedString: normalizeAlphaChunk(chunk)\n  };\n};\n\nvar createChunks = function createChunks(value) {\n  return value.replace(RE_NUMBERS, '\\0$1\\0').replace(/\\0$/, '').replace(/^\\0/, '').split('\\0');\n};\n\nvar createChunkMaps = function createChunkMaps(value) {\n  var chunksMaps = createChunks(value).map(createChunkMap);\n  return chunksMaps;\n};\n\nvar isFunction = function isFunction(value) {\n  return typeof value === 'function';\n};\n\nvar isNaN = function isNaN(value) {\n  return Number.isNaN(value) || value instanceof Number && Number.isNaN(value.valueOf());\n};\n\nvar isNull = function isNull(value) {\n  return value === null;\n};\n\nvar isObject = function isObject(value) {\n  return value !== null && typeof value === 'object' && !Array.isArray(value) && !(value instanceof Number) && !(value instanceof String) && !(value instanceof Boolean) && !(value instanceof Date);\n};\n\nvar isSymbol = function isSymbol(value) {\n  return typeof value === 'symbol';\n};\n\nvar isUndefined = function isUndefined(value) {\n  return value === undefined;\n};\n\nvar parseDate = function parseDate(value) {\n  try {\n    var parsedDate = Date.parse(value);\n    if (!Number.isNaN(parsedDate)) {\n      if (RE_DATE.test(value)) {\n        return parsedDate;\n      }\n    }\n    return undefined;\n  } catch (_unused) {\n    return undefined;\n  }\n};\n\nvar numberify = function numberify(value) {\n  var parsedNumber = parseNumber(value);\n  if (parsedNumber !== undefined) {\n    return parsedNumber;\n  }\n  return parseDate(value);\n};\n\nvar stringify = function stringify(value) {\n  if (typeof value === 'boolean' || value instanceof Boolean) {\n    return Number(value).toString();\n  }\n  if (typeof value === 'number' || value instanceof Number) {\n    return value.toString();\n  }\n  if (value instanceof Date) {\n    return value.getTime().toString();\n  }\n  if (typeof value === 'string' || value instanceof String) {\n    return value.toLowerCase().replace(RE_LEADING_OR_TRAILING_WHITESPACES, '');\n  }\n  return '';\n};\n\nvar getMappedValueRecord = function getMappedValueRecord(value) {\n  if (typeof value === 'string' || value instanceof String || (typeof value === 'number' || value instanceof Number) && !isNaN(value) || typeof value === 'boolean' || value instanceof Boolean || value instanceof Date) {\n    var stringValue = stringify(value);\n    var parsedNumber = numberify(stringValue);\n    var chunks = createChunkMaps(parsedNumber ? \"\" + parsedNumber : stringValue);\n    return {\n      parsedNumber: parsedNumber,\n      chunks: chunks,\n      value: value\n    };\n  }\n  return {\n    isArray: Array.isArray(value),\n    isFunction: isFunction(value),\n    isNaN: isNaN(value),\n    isNull: isNull(value),\n    isObject: isObject(value),\n    isSymbol: isSymbol(value),\n    isUndefined: isUndefined(value),\n    value: value\n  };\n};\n\nvar baseCompare = function baseCompare(options) {\n  return function (valueA, valueB) {\n    var a = getMappedValueRecord(valueA);\n    var b = getMappedValueRecord(valueB);\n    var result = compareValues(a, b);\n    return result * (options.order === 'desc' ? -1 : 1);\n  };\n};\n\nvar isValidOrder = function isValidOrder(value) {\n  return typeof value === 'string' && (value === 'asc' || value === 'desc');\n};\nvar getOptions = function getOptions(customOptions) {\n  var order = 'asc';\n  if (typeof customOptions === 'string' && isValidOrder(customOptions)) {\n    order = customOptions;\n  } else if (customOptions && typeof customOptions === 'object' && customOptions.order && isValidOrder(customOptions.order)) {\n    order = customOptions.order;\n  }\n  return {\n    order: order\n  };\n};\n\n/**\n * Creates a compare function that defines the natural sort order considering\n * the given `options` which may be passed to [`Array.prototype.sort()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).\n */\nfunction compare(options) {\n  var validatedOptions = getOptions(options);\n  return baseCompare(validatedOptions);\n}\n\nvar compareMultiple = function compareMultiple(recordA, recordB, orders) {\n  var indexA = recordA.index,\n    valuesA = recordA.values;\n  var indexB = recordB.index,\n    valuesB = recordB.values;\n  var length = valuesA.length;\n  var ordersLength = orders.length;\n  for (var i = 0; i < length; i++) {\n    var order = i < ordersLength ? orders[i] : null;\n    if (order && typeof order === 'function') {\n      var result = order(valuesA[i].value, valuesB[i].value);\n      if (result) {\n        return result;\n      }\n    } else {\n      var _result = compareValues(valuesA[i], valuesB[i]);\n      if (_result) {\n        return _result * (order === 'desc' ? -1 : 1);\n      }\n    }\n  }\n  return indexA - indexB;\n};\n\nvar createIdentifierFn = function createIdentifierFn(identifier) {\n  if (typeof identifier === 'function') {\n    // identifier is already a lookup function\n    return identifier;\n  }\n  return function (value) {\n    if (Array.isArray(value)) {\n      var index = Number(identifier);\n      if (Number.isInteger(index)) {\n        return value[index];\n      }\n    } else if (value && typeof value === 'object') {\n      var result = Object.getOwnPropertyDescriptor(value, identifier);\n      return result == null ? void 0 : result.value;\n    }\n    return value;\n  };\n};\n\nvar getElementByIndex = function getElementByIndex(collection, index) {\n  return collection[index];\n};\n\nvar getValueByIdentifier = function getValueByIdentifier(value, getValue) {\n  return getValue(value);\n};\n\nvar baseOrderBy = function baseOrderBy(collection, identifiers, orders) {\n  var identifierFns = identifiers.length ? identifiers.map(createIdentifierFn) : [function (value) {\n    return value;\n  }];\n\n  // temporary array holds elements with position and sort-values\n  var mappedCollection = collection.map(function (element, index) {\n    var values = identifierFns.map(function (identifier) {\n      return getValueByIdentifier(element, identifier);\n    }).map(getMappedValueRecord);\n    return {\n      index: index,\n      values: values\n    };\n  });\n\n  // iterate over values and compare values until a != b or last value reached\n  mappedCollection.sort(function (recordA, recordB) {\n    return compareMultiple(recordA, recordB, orders);\n  });\n  return mappedCollection.map(function (element) {\n    return getElementByIndex(collection, element.index);\n  });\n};\n\nvar getIdentifiers = function getIdentifiers(identifiers) {\n  if (!identifiers) {\n    return [];\n  }\n  var identifierList = !Array.isArray(identifiers) ? [identifiers] : [].concat(identifiers);\n  if (identifierList.some(function (identifier) {\n    return typeof identifier !== 'string' && typeof identifier !== 'number' && typeof identifier !== 'function';\n  })) {\n    return [];\n  }\n  return identifierList;\n};\n\nvar getOrders = function getOrders(orders) {\n  if (!orders) {\n    return [];\n  }\n  var orderList = !Array.isArray(orders) ? [orders] : [].concat(orders);\n  if (orderList.some(function (order) {\n    return order !== 'asc' && order !== 'desc' && typeof order !== 'function';\n  })) {\n    return [];\n  }\n  return orderList;\n};\n\n/**\n * Creates an array of elements, natural sorted by specified identifiers and\n * the corresponding sort orders. This method implements a stable sort\n * algorithm, which means the original sort order of equal elements is\n * preserved.\n */\nfunction orderBy(collection, identifiers, orders) {\n  if (!collection || !Array.isArray(collection)) {\n    return [];\n  }\n  var validatedIdentifiers = getIdentifiers(identifiers);\n  var validatedOrders = getOrders(orders);\n  return baseOrderBy(collection, validatedIdentifiers, validatedOrders);\n}\n\nexport { compare, orderBy };\n","import { camelCase as changeCamelCase, pascalCase as changePascalCase, pathCase as changePathCase } from 'change-case'\n\ntype Options = {\n  /**\n   * When set it will replace all `.` with `/`.\n   */\n  isFile?: boolean\n  prefix?: string\n  suffix?: string\n}\n\nexport function camelCase(text: string, { isFile, prefix = '', suffix = '' }: Options = {}): string {\n  if (isFile) {\n    const splitArray = text.split('.')\n    return splitArray.map((item, i) => (i === splitArray.length - 1 ? camelCase(item, { prefix, suffix }) : camelCase(item))).join('/')\n  }\n\n  return changeCamelCase(`${prefix} ${text} ${suffix}`, {\n    delimiter: '',\n    mergeAmbiguousCharacters: true,\n  })\n}\n\nexport function pascalCase(text: string, { isFile, prefix = '', suffix = '' }: Options = {}): string {\n  if (isFile) {\n    const splitArray = text.split('.')\n    return splitArray.map((item, i) => (i === splitArray.length - 1 ? pascalCase(item, { prefix, suffix }) : camelCase(item))).join('/')\n  }\n\n  return changePascalCase(`${prefix} ${text} ${suffix}`, {\n    delimiter: '',\n    mergeAmbiguousCharacters: true,\n  })\n}\n\nexport function pathCase(text: string, { isFile, prefix = '', suffix = '' }: Options = {}): string {\n  if (isFile) {\n    const splitArray = text.split('.')\n    return splitArray.map((item, i) => (i === splitArray.length - 1 ? pathCase(item, { prefix, suffix }) : camelCase(item))).join('/')\n  }\n\n  return changePathCase(`${prefix} ${text} ${suffix}`, { delimiter: '' })\n}\n","// Regexps involved with splitting words in various case formats.\nconst SPLIT_LOWER_UPPER_RE = /([\\p{Ll}\\d])(\\p{Lu})/gu;\nconst SPLIT_UPPER_UPPER_RE = /(\\p{Lu})([\\p{Lu}][\\p{Ll}])/gu;\n\n// Used to iterate over the initial split result and separate numbers.\nconst SPLIT_SEPARATE_NUMBER_RE = /(\\d)\\p{Ll}|(\\p{L})\\d/u;\n\n// Regexp involved with stripping non-word characters from the result.\nconst DEFAULT_STRIP_REGEXP = /[^\\p{L}\\d]+/giu;\n\n// The replacement value for splits.\nconst SPLIT_REPLACE_VALUE = \"$1\\0$2\";\n\n// The default characters to keep after transforming case.\nconst DEFAULT_PREFIX_SUFFIX_CHARACTERS = \"\";\n\n/**\n * Supported locale values. Use `false` to ignore locale.\n * Defaults to `undefined`, which uses the host environment.\n */\nexport type Locale = string[] | string | false | undefined;\n\n/**\n * Options used for converting strings to pascal/camel case.\n */\nexport interface PascalCaseOptions extends Options {\n  mergeAmbiguousCharacters?: boolean;\n}\n\n/**\n * Options used for converting strings to any case.\n */\nexport interface Options {\n  locale?: Locale;\n  split?: (value: string) => string[];\n  /** @deprecated Pass `split: splitSeparateNumbers` instead. */\n  separateNumbers?: boolean;\n  delimiter?: string;\n  prefixCharacters?: string;\n  suffixCharacters?: string;\n}\n\n/**\n * Split any cased input strings into an array of words.\n */\nexport function split(value: string) {\n  let result = value.trim();\n\n  result = result\n    .replace(SPLIT_LOWER_UPPER_RE, SPLIT_REPLACE_VALUE)\n    .replace(SPLIT_UPPER_UPPER_RE, SPLIT_REPLACE_VALUE);\n\n  result = result.replace(DEFAULT_STRIP_REGEXP, \"\\0\");\n\n  let start = 0;\n  let end = result.length;\n\n  // Trim the delimiter from around the output string.\n  while (result.charAt(start) === \"\\0\") start++;\n  if (start === end) return [];\n  while (result.charAt(end - 1) === \"\\0\") end--;\n\n  return result.slice(start, end).split(/\\0/g);\n}\n\n/**\n * Split the input string into an array of words, separating numbers.\n */\nexport function splitSeparateNumbers(value: string) {\n  const words = split(value);\n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    const match = SPLIT_SEPARATE_NUMBER_RE.exec(word);\n    if (match) {\n      const offset = match.index + (match[1] ?? match[2]).length;\n      words.splice(i, 1, word.slice(0, offset), word.slice(offset));\n    }\n  }\n  return words;\n}\n\n/**\n * Convert a string to space separated lower case (`foo bar`).\n */\nexport function noCase(input: string, options?: Options) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  return (\n    prefix +\n    words.map(lowerFactory(options?.locale)).join(options?.delimiter ?? \" \") +\n    suffix\n  );\n}\n\n/**\n * Convert a string to camel case (`fooBar`).\n */\nexport function camelCase(input: string, options?: PascalCaseOptions) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  const lower = lowerFactory(options?.locale);\n  const upper = upperFactory(options?.locale);\n  const transform = options?.mergeAmbiguousCharacters\n    ? capitalCaseTransformFactory(lower, upper)\n    : pascalCaseTransformFactory(lower, upper);\n  return (\n    prefix +\n    words\n      .map((word, index) => {\n        if (index === 0) return lower(word);\n        return transform(word, index);\n      })\n      .join(options?.delimiter ?? \"\") +\n    suffix\n  );\n}\n\n/**\n * Convert a string to pascal case (`FooBar`).\n */\nexport function pascalCase(input: string, options?: PascalCaseOptions) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  const lower = lowerFactory(options?.locale);\n  const upper = upperFactory(options?.locale);\n  const transform = options?.mergeAmbiguousCharacters\n    ? capitalCaseTransformFactory(lower, upper)\n    : pascalCaseTransformFactory(lower, upper);\n  return prefix + words.map(transform).join(options?.delimiter ?? \"\") + suffix;\n}\n\n/**\n * Convert a string to pascal snake case (`Foo_Bar`).\n */\nexport function pascalSnakeCase(input: string, options?: Options) {\n  return capitalCase(input, { delimiter: \"_\", ...options });\n}\n\n/**\n * Convert a string to capital case (`Foo Bar`).\n */\nexport function capitalCase(input: string, options?: Options) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  const lower = lowerFactory(options?.locale);\n  const upper = upperFactory(options?.locale);\n  return (\n    prefix +\n    words\n      .map(capitalCaseTransformFactory(lower, upper))\n      .join(options?.delimiter ?? \" \") +\n    suffix\n  );\n}\n\n/**\n * Convert a string to constant case (`FOO_BAR`).\n */\nexport function constantCase(input: string, options?: Options) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  return (\n    prefix +\n    words.map(upperFactory(options?.locale)).join(options?.delimiter ?? \"_\") +\n    suffix\n  );\n}\n\n/**\n * Convert a string to dot case (`foo.bar`).\n */\nexport function dotCase(input: string, options?: Options) {\n  return noCase(input, { delimiter: \".\", ...options });\n}\n\n/**\n * Convert a string to kebab case (`foo-bar`).\n */\nexport function kebabCase(input: string, options?: Options) {\n  return noCase(input, { delimiter: \"-\", ...options });\n}\n\n/**\n * Convert a string to path case (`foo/bar`).\n */\nexport function pathCase(input: string, options?: Options) {\n  return noCase(input, { delimiter: \"/\", ...options });\n}\n\n/**\n * Convert a string to path case (`Foo bar`).\n */\nexport function sentenceCase(input: string, options?: Options) {\n  const [prefix, words, suffix] = splitPrefixSuffix(input, options);\n  const lower = lowerFactory(options?.locale);\n  const upper = upperFactory(options?.locale);\n  const transform = capitalCaseTransformFactory(lower, upper);\n  return (\n    prefix +\n    words\n      .map((word, index) => {\n        if (index === 0) return transform(word);\n        return lower(word);\n      })\n      .join(options?.delimiter ?? \" \") +\n    suffix\n  );\n}\n\n/**\n * Convert a string to snake case (`foo_bar`).\n */\nexport function snakeCase(input: string, options?: Options) {\n  return noCase(input, { delimiter: \"_\", ...options });\n}\n\n/**\n * Convert a string to header case (`Foo-Bar`).\n */\nexport function trainCase(input: string, options?: Options) {\n  return capitalCase(input, { delimiter: \"-\", ...options });\n}\n\nfunction lowerFactory(locale: Locale): (input: string) => string {\n  return locale === false\n    ? (input: string) => input.toLowerCase()\n    : (input: string) => input.toLocaleLowerCase(locale);\n}\n\nfunction upperFactory(locale: Locale): (input: string) => string {\n  return locale === false\n    ? (input: string) => input.toUpperCase()\n    : (input: string) => input.toLocaleUpperCase(locale);\n}\n\nfunction capitalCaseTransformFactory(\n  lower: (input: string) => string,\n  upper: (input: string) => string,\n) {\n  return (word: string) => `${upper(word[0])}${lower(word.slice(1))}`;\n}\n\nfunction pascalCaseTransformFactory(\n  lower: (input: string) => string,\n  upper: (input: string) => string,\n) {\n  return (word: string, index: number) => {\n    const char0 = word[0];\n    const initial =\n      index > 0 && char0 >= \"0\" && char0 <= \"9\" ? \"_\" + char0 : upper(char0);\n    return initial + lower(word.slice(1));\n  };\n}\n\nfunction splitPrefixSuffix(\n  input: string,\n  options: Options = {},\n): [string, string[], string] {\n  const splitFn =\n    options.split ?? (options.separateNumbers ? splitSeparateNumbers : split);\n  const prefixCharacters =\n    options.prefixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS;\n  const suffixCharacters =\n    options.suffixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS;\n  let prefixIndex = 0;\n  let suffixIndex = input.length;\n\n  while (prefixIndex < input.length) {\n    const char = input.charAt(prefixIndex);\n    if (!prefixCharacters.includes(char)) break;\n    prefixIndex++;\n  }\n\n  while (suffixIndex > prefixIndex) {\n    const index = suffixIndex - 1;\n    const char = input.charAt(index);\n    if (!suffixCharacters.includes(char)) break;\n    suffixIndex = index;\n  }\n\n  return [\n    input.slice(0, prefixIndex),\n    splitFn(input.slice(prefixIndex, suffixIndex)),\n    input.slice(suffixIndex),\n  ];\n}\n"]}