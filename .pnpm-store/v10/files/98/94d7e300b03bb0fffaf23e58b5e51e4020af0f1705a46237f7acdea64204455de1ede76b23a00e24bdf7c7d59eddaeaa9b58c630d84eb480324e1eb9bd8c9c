{"version":3,"sources":["../src/components/Parser.tsx","../src/components/File.tsx","../src/hooks/useIndent.ts","../src/components/App.tsx"],"sourcesContent":["import { createContext, useContext } from 'react'\n\nimport type { KubbNode } from '../types.ts'\n\nexport type ParserLanguage = 'typescript' | 'text' | (string & {})\n\nexport type ParserContextProps = {\n  language: ParserLanguage\n}\n\nconst ParserContext = createContext<ParserContextProps>({ language: 'text' })\n\ntype Props = {\n  /**\n   * Name of the language used.\n   * @default 'text'\n   */\n  language?: ParserContextProps['language']\n  children?: KubbNode\n}\n\nexport function TypeScript({ children }: Omit<Props, 'language'>): KubbNode {\n  const context = useContext(ParserContext)\n\n  if (context.language !== 'typescript') {\n    return null\n  }\n\n  return children\n}\n\nexport function Parser({ language = 'text', children }: Props): KubbNode {\n  return (\n    <kubb-parser language={language}>\n      <ParserContext.Provider value={{ language }}>{children}</ParserContext.Provider>\n    </kubb-parser>\n  )\n}\n\nParser.TypeScript = TypeScript\nParser.Context = ParserContext\n","import { createContext } from 'react'\n\nimport type { FileMetaBase } from '@kubb/core'\nimport type * as KubbFile from '@kubb/fs/types'\nimport type { KubbNode } from '../types.ts'\n\nexport type FileContextProps<TMeta extends FileMetaBase = FileMetaBase> = {\n  /**\n   * Name to be used to dynamicly create the baseName(based on input.path).\n   * Based on UNIX basename\n   * @link https://nodejs.org/api/path.html#pathbasenamepath-suffix\n   */\n  baseName: KubbFile.BaseName\n  /**\n   * Path will be full qualified path to a specified file.\n   */\n  path: KubbFile.Path\n  meta?: TMeta\n}\nconst FileContext = createContext<FileContextProps>({} as FileContextProps)\n\ntype BasePropsWithBaseName = {\n  /**\n   * Name to be used to dynamicly create the baseName(based on input.path).\n   * Based on UNIX basename\n   * @link https://nodejs.org/api/path.html#pathbasenamepath-suffix\n   */\n  baseName: KubbFile.BaseName\n  /**\n   * Path will be full qualified path to a specified file.\n   */\n  path: KubbFile.Path\n}\n\ntype BasePropsWithoutBaseName = {\n  baseName?: never\n  /**\n   * Path will be full qualified path to a specified file.\n   */\n  path?: KubbFile.Path\n}\n\ntype BaseProps = BasePropsWithBaseName | BasePropsWithoutBaseName\n\ntype Props<TMeta extends FileMetaBase = FileMetaBase> = BaseProps & {\n  /**\n   * Unique identifier to reuse later.\n   * @default crypto.randomUUID()\n   */\n  id?: KubbFile.File['id']\n  /**\n   * This will override `process.env[key]` inside the `source`, see `getFileSource`.\n   */\n  env?: KubbFile.File['env']\n  /**\n   * This will call fileManager.add instead of fileManager.addOrAppend, adding the source when the files already exists.\n   * This will also ignore the combinefiles utils\n   * @default `false`\n   */\n  override?: KubbFile.File['override']\n  /**\n   * Override if a file can be exported by the BarrelManager\n   * @default true\n   */\n  exportable?: boolean\n  meta?: TMeta\n  children?: KubbNode\n}\n\nexport function File<TMeta extends FileMetaBase = FileMetaBase>({ children, exportable = true, ...rest }: Props<TMeta>): KubbNode {\n  if (!rest.baseName || !rest.path) {\n    return children\n  }\n\n  return (\n    <kubb-file exportable={exportable} {...rest}>\n      <FileContext.Provider value={{ baseName: rest.baseName, path: rest.path, meta: rest.meta }}>{children}</FileContext.Provider>\n    </kubb-file>\n  )\n}\n\ntype FileSourceUnionProps =\n  | {\n      /**\n       * When path is set it will copy-paste that file as a string inside the component.\n       * Children will then be ignored\n       */\n      path?: string\n      children?: never\n    }\n  | {\n      /**\n       * When path is set it will copy-paste that file as a string inside the component.\n       * Children will then be ignored\n       */\n      path?: never\n      children?: KubbNode\n    }\n\ntype FileSourceProps = FileSourceUnionProps & {\n  /**\n   * When true, it will return the generated import.\n   * When false, it will add the import to a KubbFile instance(see fileManager).\n   */\n  print?: boolean\n}\n\nfunction FileSource({ path, print, children }: FileSourceProps): KubbNode {\n  return (\n    <kubb-source path={path} print={print}>\n      {children}\n    </kubb-source>\n  )\n}\n\ntype FileExportProps = KubbFile.Export & {\n  /**\n   * When true, it will return the generated import.\n   * When false, it will add the import to a KubbFile instance(see fileManager)\n   */\n  print?: boolean\n}\n\nfunction FileExport({ name, path, isTypeOnly, asAlias, print, extName }: FileExportProps): KubbNode {\n  return <kubb-export name={name} path={path} isTypeOnly={isTypeOnly || false} extName={extName} asAlias={asAlias} print={print} />\n}\n\ntype FileImportProps = KubbFile.Import & {\n  /**\n   * When true, it will return the generated import.\n   * When false, it will add the import to a KubbFile instance(see fileManager).\n   */\n  print?: boolean\n}\n\nexport function FileImport({ name, root, path, isTypeOnly, isNameSpace, extName, print }: FileImportProps): KubbNode {\n  return <kubb-import name={name} root={root} path={path} isNameSpace={isNameSpace} extName={extName} isTypeOnly={isTypeOnly || false} print={print} />\n}\n\nFile.Export = FileExport\nFile.Import = FileImport\nFile.Source = FileSource\nFile.Context = FileContext\n","import transformers from '@kubb/core/transformers'\n\nimport type { KubbNode } from '../types.ts'\n\ntype Props = {\n  /**\n   * Size to use for the indenting\n   */\n  size: number\n  children?: KubbNode\n}\n\nexport function useIndent({ size, children }: Props): KubbNode {\n  let indentWithChildren: KubbNode\n\n  if (!children) {\n    return transformers.createIndent(size)\n  }\n\n  if (typeof children === 'string') {\n    indentWithChildren = children.replaceAll('\\n', `\\n${transformers.createIndent(size)}`)\n  }\n\n  if (Array.isArray(children)) {\n    indentWithChildren = children.map((child) => {\n      let text: string = child as string\n\n      if (typeof text === 'string') {\n        if (text.startsWith('\\n')) {\n          text = text.replace('\\n', '')\n        }\n        if (text.substring(text.length - 1, text.length) === '\\n') {\n          text = text.substring(0, text.length - 2)\n        }\n        text = text.replaceAll('\\n', `\\n${transformers.createIndent(size)}`)\n      }\n      return text\n    })\n  }\n\n  return indentWithChildren\n}\n","import { createContext } from 'react'\n\nimport type { Plugin, PluginManager } from '@kubb/core'\nimport type * as KubbFile from '@kubb/fs/types'\nimport type { KubbNode } from '../types.ts'\n\nexport type AppContextProps = {\n  mode: KubbFile.Mode\n  pluginManager: PluginManager\n  plugin: Plugin\n}\n\nconst AppContext = createContext<AppContextProps | undefined>(undefined)\n\ntype Props = {\n  mode: KubbFile.Mode\n  pluginManager: PluginManager\n  plugin: Plugin\n  children?: KubbNode\n}\n\nexport function App({ plugin, pluginManager, mode, children }: Props): KubbNode {\n  return <AppContext.Provider value={{ plugin, pluginManager, mode }}>{children}</AppContext.Provider>\n}\n\nApp.Context = AppContext\n"],"mappings":";;;;;;;;AAAA;AAAA,mBAA0C;AAkCpC;AAxBN,IAAM,oBAAgB,4BAAkC,EAAE,UAAU,OAAO,CAAC;AAWrE,SAAS,WAAW,EAAE,SAAS,GAAsC;AAC1E,QAAM,cAAU,yBAAW,aAAa;AAExC,MAAI,QAAQ,aAAa,cAAc;AACrC,WAAO;AAAA,EACT;AAEA,SAAO;AACT;AAEO,SAAS,OAAO,EAAE,WAAW,QAAQ,SAAS,GAAoB;AACvE,SACE,4CAAC,iBAAY,UACX,sDAAC,cAAc,UAAd,EAAuB,OAAO,EAAE,SAAS,GAAI,UAAS,GACzD;AAEJ;AAEA,OAAO,aAAa;AACpB,OAAO,UAAU;;;ACxCjB;AAAA,IAAAA,gBAA8B;AA4ExB,IAAAC,sBAAA;AAzDN,IAAM,kBAAc,6BAAgC,CAAC,CAAqB;AAkDnE,SAAS,KAAgD,EAAE,UAAU,aAAa,MAAM,GAAG,KAAK,GAA2B;AAChI,MAAI,CAAC,KAAK,YAAY,CAAC,KAAK,MAAM;AAChC,WAAO;AAAA,EACT;AAEA,SACE,6CAAC,eAAU,YAAyB,GAAG,MACrC,uDAAC,YAAY,UAAZ,EAAqB,OAAO,EAAE,UAAU,KAAK,UAAU,MAAM,KAAK,MAAM,MAAM,KAAK,KAAK,GAAI,UAAS,GACxG;AAEJ;AA4BA,SAAS,WAAW,EAAE,MAAM,OAAO,SAAS,GAA8B;AACxE,SACE,6CAAC,iBAAY,MAAY,OACtB,UACH;AAEJ;AAUA,SAAS,WAAW,EAAE,MAAM,MAAM,YAAY,SAAS,OAAO,QAAQ,GAA8B;AAClG,SAAO,6CAAC,iBAAY,MAAY,MAAY,YAAY,cAAc,OAAO,SAAkB,SAAkB,OAAc;AACjI;AAUO,SAAS,WAAW,EAAE,MAAM,MAAM,MAAM,YAAY,aAAa,SAAS,MAAM,GAA8B;AACnH,SAAO,6CAAC,iBAAY,MAAY,MAAY,MAAY,aAA0B,SAAkB,YAAY,cAAc,OAAO,OAAc;AACrJ;AAEA,KAAK,SAAS;AACd,KAAK,SAAS;AACd,KAAK,SAAS;AACd,KAAK,UAAU;;;AC9If;AAAA,OAAO,kBAAkB;AAYlB,SAAS,UAAU,EAAE,MAAM,SAAS,GAAoB;AAC7D,MAAI;AAEJ,MAAI,CAAC,UAAU;AACb,WAAO,aAAa,aAAa,IAAI;AAAA,EACvC;AAEA,MAAI,OAAO,aAAa,UAAU;AAChC,yBAAqB,SAAS,WAAW,MAAM;AAAA,EAAK,aAAa,aAAa,IAAI,CAAC,EAAE;AAAA,EACvF;AAEA,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,yBAAqB,SAAS,IAAI,CAAC,UAAU;AAC3C,UAAI,OAAe;AAEnB,UAAI,OAAO,SAAS,UAAU;AAC5B,YAAI,KAAK,WAAW,IAAI,GAAG;AACzB,iBAAO,KAAK,QAAQ,MAAM,EAAE;AAAA,QAC9B;AACA,YAAI,KAAK,UAAU,KAAK,SAAS,GAAG,KAAK,MAAM,MAAM,MAAM;AACzD,iBAAO,KAAK,UAAU,GAAG,KAAK,SAAS,CAAC;AAAA,QAC1C;AACA,eAAO,KAAK,WAAW,MAAM;AAAA,EAAK,aAAa,aAAa,IAAI,CAAC,EAAE;AAAA,MACrE;AACA,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAEA,SAAO;AACT;;;ACzCA;AAAA,IAAAC,gBAA8B;AAsBrB,IAAAC,sBAAA;AAVT,IAAM,iBAAa,6BAA2C,MAAS;AAShE,SAAS,IAAI,EAAE,QAAQ,eAAe,MAAM,SAAS,GAAoB;AAC9E,SAAO,6CAAC,WAAW,UAAX,EAAoB,OAAO,EAAE,QAAQ,eAAe,KAAK,GAAI,UAAS;AAChF;AAEA,IAAI,UAAU;","names":["import_react","import_jsx_runtime","import_react","import_jsx_runtime"]}