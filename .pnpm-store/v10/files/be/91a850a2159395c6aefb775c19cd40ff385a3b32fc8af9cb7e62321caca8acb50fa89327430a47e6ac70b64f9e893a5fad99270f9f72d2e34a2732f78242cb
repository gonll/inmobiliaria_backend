{"version":3,"file":"Root-DvQofGOy.cjs","names":["path","trimExtName","NodeEventEmitter","defaultParser","trimExtName"],"sources":["../src/context.ts","../src/contexts/NodeTreeContext.ts","../src/createFile.ts","../src/utils/AsyncEventEmitter.ts","../src/FileProcessor.ts","../src/utils/Cache.ts","../src/FileManager.ts","../src/utils/TreeNode.ts","../src/contexts/RootContext.ts","../src/contexts/RenderContext.ts","../src/intrinsic.ts","../src/createComponent.ts","../src/components/Root.ts"],"sourcesContent":["/**\n * Context type that carries type information about its value\n * This is a branded symbol type that enables type-safe context usage\n */\nexport type Context<T> = symbol & { readonly __type: T }\n\n/**\n * Context stack for tracking the current context values\n *\n * Note: This uses a global Map for simplicity in code generation scenarios.\n * For concurrent runtime execution, consider using AsyncLocalStorage or\n * instance-based context management.\n */\nconst contextStack = new Map<symbol, unknown[]>()\nconst contextDefaults = new Map<symbol, unknown>()\n\n/**\n * Provides a value to descendant components (Vue 3 style)\n *\n * @example\n * ```ts\n * const ThemeKey = Symbol('theme')\n * provide(ThemeKey, { color: 'blue' })\n * ```\n */\nexport function provide<T>(key: symbol | Context<T>, value: T): void {\n  if (!contextStack.has(key)) {\n    contextStack.set(key, [])\n  }\n  contextStack.get(key)!.push(value)\n}\n\n/**\n * Injects a value provided by an ancestor component (Vue 3 style)\n *\n * @example\n * ```ts\n * const theme = inject(ThemeKey, { color: 'default' })\n * ```\n */\nexport function inject<T>(key: symbol | Context<T>, defaultValue?: T): T {\n  const stack = contextStack.get(key)\n  if (!stack || stack.length === 0) {\n    if (defaultValue !== undefined) {\n      return defaultValue\n    }\n    const storedDefault = contextDefaults.get(key)\n    if (storedDefault !== undefined) {\n      return storedDefault as T\n    }\n    throw new Error(`No value provided for key: ${key.toString()}`)\n  }\n  return stack[stack.length - 1] as T\n}\n\n/**\n * Unprovides a value (for cleanup)\n * @internal\n */\nexport function unprovide<T>(key: symbol | Context<T>): void {\n  const stack = contextStack.get(key)\n  if (stack && stack.length > 0) {\n    stack.pop()\n  }\n}\n\n/**\n * Creates a context key with a default value (React-style compatibility)\n *\n * @example\n * ```ts\n * const ThemeContext = createContext({ color: 'blue' })\n * // ThemeContext is now typed as Context<{ color: string }>\n * const theme = useContext(ThemeContext) // theme is { color: string }\n * ```\n */\nexport function createContext<T>(defaultValue: T): Context<T> {\n  const key = Symbol('context') as Context<T>\n  contextDefaults.set(key, defaultValue)\n\n  return key\n}\n","import type { ComponentNode } from '../composables/useNodeTree.ts'\nimport { createContext } from '../context.ts'\nimport type { TreeNode } from '../utils/TreeNode.ts'\n\n/**\n * Context for having the current NodeTree\n */\nexport const NodeTreeContext = createContext<TreeNode<ComponentNode> | null>(null)\n","import { createHash } from 'node:crypto'\nimport path from 'node:path'\nimport { orderBy } from 'natural-orderby'\nimport { uniqueBy } from 'remeda'\nimport type * as KubbFile from './KubbFile.ts'\nimport { trimExtName } from './utils/trimExtName.ts'\n\nexport function combineSources(sources: Array<KubbFile.Source>): Array<KubbFile.Source> {\n  return uniqueBy(sources, (obj) => {\n    // For named sources, deduplicate by name, isExportable, and isTypeOnly\n    // For unnamed sources, include the value to avoid deduplicating different code blocks\n    // If both name and value are undefined, use an empty string as the unique identifier\n    const uniqueId = obj.name ?? obj.value ?? ''\n    const isExportable = obj.isExportable ?? false\n    const isTypeOnly = obj.isTypeOnly ?? false\n    return `${uniqueId}:${isExportable}:${isTypeOnly}`\n  })\n}\n\nexport function combineExports(exports: Array<KubbFile.Export>): Array<KubbFile.Export> {\n  const sorted = orderBy(exports, [\n    (v) => !!Array.isArray(v.name),\n    (v) => !v.isTypeOnly,\n    (v) => v.path,\n    (v) => !!v.name,\n    (v) => (Array.isArray(v.name) ? orderBy(v.name) : v.name),\n  ])\n\n  const prev: Array<KubbFile.Export> = []\n  // Map to track items by path for O(1) lookup\n  const pathMap = new Map<string, KubbFile.Export>()\n  // Map to track unique items by path+name+isTypeOnly+asAlias\n  const uniqueMap = new Map<string, KubbFile.Export>()\n  // Map to track items by path+name where isTypeOnly=true (for type-only check)\n  const pathNameTypeTrueMap = new Map<string, KubbFile.Export>()\n\n  for (const curr of sorted) {\n    const name = curr.name\n    const pathKey = curr.path\n    const prevByPath = pathMap.get(pathKey)\n\n    // Create unique key for path+name+isTypeOnly\n    const nameKey = Array.isArray(name) ? JSON.stringify(name) : name || ''\n    const pathNameTypeKey = `${pathKey}:${nameKey}:${curr.isTypeOnly}`\n    // Check if there's already an item with the same path+name but with isTypeOnly=true\n    const pathNameKey = `${pathKey}:${nameKey}`\n    const prevByPathAndIsTypeOnly = pathNameTypeTrueMap.get(pathNameKey)\n\n    if (prevByPathAndIsTypeOnly) {\n      // we already have an export that has the same path and name but uses `isTypeOnly` (export type ...)\n      continue\n    }\n\n    // Create unique key for path+name+isTypeOnly+asAlias\n    const uniqueKey = `${pathNameTypeKey}:${curr.asAlias || ''}`\n    const uniquePrev = uniqueMap.get(uniqueKey)\n\n    // we already have an item that was unique enough or name field is empty or prev asAlias is set but current has no changes\n    if (uniquePrev || (Array.isArray(name) && !name.length) || (prevByPath?.asAlias && !curr.asAlias)) {\n      continue\n    }\n\n    if (!prevByPath) {\n      const newItem = {\n        ...curr,\n        name: Array.isArray(name) ? [...new Set(name)] : name,\n      }\n      prev.push(newItem)\n      pathMap.set(pathKey, newItem)\n      uniqueMap.set(uniqueKey, newItem)\n      // Track items with isTypeOnly=true for the type-only check\n      if (newItem.isTypeOnly) {\n        pathNameTypeTrueMap.set(pathNameKey, newItem)\n      }\n      continue\n    }\n\n    // merge all names when prev and current both have the same isTypeOnly set\n    if (prevByPath && Array.isArray(prevByPath.name) && Array.isArray(curr.name) && prevByPath.isTypeOnly === curr.isTypeOnly) {\n      prevByPath.name = [...new Set([...prevByPath.name, ...curr.name])]\n      continue\n    }\n\n    prev.push(curr)\n    uniqueMap.set(uniqueKey, curr)\n    // Track items with isTypeOnly=true for the type-only check\n    if (curr.isTypeOnly) {\n      pathNameTypeTrueMap.set(pathNameKey, curr)\n    }\n  }\n\n  return prev\n}\n\nexport function combineImports(imports: Array<KubbFile.Import>, exports: Array<KubbFile.Export>, source?: string): Array<KubbFile.Import> {\n  const exportedNameLookup = new Set<string>()\n  for (const item of exports) {\n    const { name } = item\n    if (!name) {\n      continue\n    }\n\n    if (Array.isArray(name)) {\n      for (const value of name) {\n        if (value) {\n          exportedNameLookup.add(value)\n        }\n      }\n      continue\n    }\n\n    exportedNameLookup.add(name)\n  }\n\n  const usageCache = new Map<string, boolean>()\n  const hasImportInSource = (importName: string): boolean => {\n    if (!source) {\n      return true\n    }\n\n    const cached = usageCache.get(importName)\n    if (cached !== undefined) {\n      return cached\n    }\n\n    const isUsed = source.includes(importName) || exportedNameLookup.has(importName)\n    usageCache.set(importName, isUsed)\n\n    return isUsed\n  }\n\n  const sorted = orderBy(imports, [\n    (v) => !!Array.isArray(v.name),\n    (v) => !v.isTypeOnly,\n    (v) => v.path,\n    (v) => !!v.name,\n    (v) => (Array.isArray(v.name) ? orderBy(v.name) : v.name),\n  ])\n\n  const prev: Array<KubbFile.Import> = []\n  // Map to track items by path+isTypeOnly for O(1) lookup\n  const pathTypeMap = new Map<string, KubbFile.Import>()\n  // Map to track unique items by path+name+isTypeOnly\n  const uniqueMap = new Map<string, KubbFile.Import>()\n  // Map to track items by path+name where isTypeOnly=true (for type-only check)\n  const pathNameTypeTrueMap = new Map<string, KubbFile.Import>()\n\n  for (const curr of sorted) {\n    let name = Array.isArray(curr.name) ? [...new Set(curr.name)] : curr.name\n\n    if (curr.path === curr.root) {\n      // root and path are the same file, remove the \"./\" import\n      continue\n    }\n\n    // merge all names and check if the importName is being used in the generated source and if not filter those imports out\n    if (Array.isArray(name)) {\n      name = name.filter((item) => (typeof item === 'string' ? hasImportInSource(item) : hasImportInSource(item.propertyName)))\n    }\n\n    const pathTypeKey = `${curr.path}:${curr.isTypeOnly}`\n    const prevByPath = pathTypeMap.get(pathTypeKey)\n\n    // Create key for name comparison\n    const nameKey = Array.isArray(name) ? JSON.stringify(name) : name || ''\n    const pathNameTypeKey = `${curr.path}:${nameKey}:${curr.isTypeOnly}`\n    const uniquePrev = uniqueMap.get(pathNameTypeKey)\n    // Check if there's already an item with the same path+name but with isTypeOnly=true\n    const pathNameKey = `${curr.path}:${nameKey}`\n    const prevByPathNameAndIsTypeOnly = pathNameTypeTrueMap.get(pathNameKey)\n\n    if (prevByPathNameAndIsTypeOnly) {\n      // we already have an import that has the same path and name but uses `isTypeOnly` (import type ...)\n      continue\n    }\n\n    // already unique enough or name is empty\n    if (uniquePrev || (Array.isArray(name) && !name.length)) {\n      continue\n    }\n\n    // new item, append name\n    if (!prevByPath) {\n      const newItem = {\n        ...curr,\n        name,\n      }\n      prev.push(newItem)\n      pathTypeMap.set(pathTypeKey, newItem)\n      uniqueMap.set(pathNameTypeKey, newItem)\n      // Track items with isTypeOnly=true for the type-only check\n      if (newItem.isTypeOnly) {\n        pathNameTypeTrueMap.set(pathNameKey, newItem)\n      }\n      continue\n    }\n\n    // merge all names when prev and current both have the same isTypeOnly set\n    if (prevByPath && Array.isArray(prevByPath.name) && Array.isArray(name) && prevByPath.isTypeOnly === curr.isTypeOnly) {\n      prevByPath.name = [...new Set([...prevByPath.name, ...name])]\n      continue\n    }\n\n    // no import was found in the source, ignore import\n    if (!Array.isArray(name) && name && !hasImportInSource(name)) {\n      continue\n    }\n\n    prev.push(curr)\n    uniqueMap.set(pathNameTypeKey, curr)\n    // Track items with isTypeOnly=true for the type-only check\n    if (curr.isTypeOnly) {\n      pathNameTypeTrueMap.set(pathNameKey, curr)\n    }\n  }\n\n  return prev\n}\n\n/**\n * Helper to create a file with name and id set\n */\nexport function createFile<TMeta extends object = object>(file: KubbFile.File<TMeta>): KubbFile.ResolvedFile<TMeta> {\n  const extname = path.extname(file.baseName) as KubbFile.Extname\n  if (!extname) {\n    throw new Error(`No extname found for ${file.baseName}`)\n  }\n\n  const source = file.sources.map((item) => item.value).join('\\n\\n')\n  const exports = file.exports?.length ? combineExports(file.exports) : []\n  const imports = file.imports?.length && source ? combineImports(file.imports, exports, source) : []\n  const sources = file.sources?.length ? combineSources(file.sources) : []\n\n  return {\n    ...file,\n    id: createHash('sha256').update(file.path).digest('hex'),\n    name: trimExtName(file.baseName),\n    extname,\n    imports: imports,\n    exports: exports,\n    sources: sources,\n    meta: file.meta || ({} as TMeta),\n  }\n}\n","import { EventEmitter as NodeEventEmitter } from 'node:events'\nimport type { FabricMode } from '../Fabric.ts'\n\ntype Options = {\n  mode?: FabricMode\n  maxListener?: number\n}\n\nexport class AsyncEventEmitter<TEvents extends Record<string, any>> {\n  constructor({ maxListener = 100, mode = 'sequential' }: Options = {}) {\n    this.#emitter.setMaxListeners(maxListener)\n    this.#mode = mode\n  }\n\n  #emitter = new NodeEventEmitter()\n  #mode: FabricMode\n\n  async emit<TEventName extends keyof TEvents & string>(eventName: TEventName, ...eventArgs: TEvents[TEventName]): Promise<void> {\n    const listeners = this.#emitter.listeners(eventName) as Array<(...args: TEvents[TEventName]) => any>\n\n    if (listeners.length === 0) {\n      return\n    }\n\n    const errors: Error[] = []\n\n    if (this.#mode === 'sequential') {\n      // Run listeners one by one, in order\n      for (const listener of listeners) {\n        try {\n          await listener(...eventArgs)\n        } catch (err) {\n          const error = err instanceof Error ? err : new Error(String(err))\n          errors.push(error)\n        }\n      }\n    } else {\n      // Run all listeners concurrently\n      const promises = listeners.map(async (listener) => {\n        try {\n          await listener(...eventArgs)\n        } catch (err) {\n          const error = err instanceof Error ? err : new Error(String(err))\n          errors.push(error)\n        }\n      })\n      await Promise.all(promises)\n    }\n\n    if (errors.length === 1) {\n      throw errors[0]\n    }\n\n    if (errors.length > 1) {\n      throw new AggregateError(errors, `Errors in async listeners for \"${eventName}\"`)\n    }\n  }\n\n  on<TEventName extends keyof TEvents & string>(eventName: TEventName, handler: (...eventArg: TEvents[TEventName]) => void): void {\n    this.#emitter.on(eventName, handler as any)\n  }\n\n  onOnce<TEventName extends keyof TEvents & string>(eventName: TEventName, handler: (...eventArgs: TEvents[TEventName]) => void): void {\n    const wrapper = (...args: TEvents[TEventName]) => {\n      this.off(eventName, wrapper)\n      handler(...args)\n    }\n    this.on(eventName, wrapper)\n  }\n\n  off<TEventName extends keyof TEvents & string>(eventName: TEventName, handler: (...eventArg: TEvents[TEventName]) => void): void {\n    this.#emitter.off(eventName, handler as any)\n  }\n\n  removeAll(): void {\n    this.#emitter.removeAllListeners()\n  }\n}\n","import pLimit from 'p-limit'\nimport type { FabricEvents, FabricMode } from './Fabric.ts'\nimport type * as KubbFile from './KubbFile.ts'\nimport { defaultParser } from './parsers/defaultParser.ts'\nimport type { Parser } from './parsers/types.ts'\nimport { AsyncEventEmitter } from './utils/AsyncEventEmitter.ts'\n\nexport type ProcessFilesProps = {\n  parsers?: Map<KubbFile.Extname, Parser>\n  extension?: Record<KubbFile.Extname, KubbFile.Extname | ''>\n  dryRun?: boolean\n  /**\n   * @default 'sequential'\n   */\n  mode?: FabricMode\n}\n\ntype GetParseOptions = {\n  parsers?: Map<KubbFile.Extname, Parser>\n  extension?: Record<KubbFile.Extname, KubbFile.Extname | ''>\n}\n\ntype Options = {\n  events?: AsyncEventEmitter<FabricEvents>\n}\n\nexport class FileProcessor {\n  #limit = pLimit(100)\n  events: AsyncEventEmitter<FabricEvents>\n\n  constructor({ events = new AsyncEventEmitter<FabricEvents>() }: Options = {}) {\n    this.events = events\n\n    return this\n  }\n\n  async parse(file: KubbFile.ResolvedFile, { parsers, extension }: GetParseOptions = {}): Promise<string> {\n    const parseExtName = extension?.[file.extname] || undefined\n\n    if (!parsers) {\n      console.warn('No parsers provided, using default parser. If you want to use a specific parser, please provide it in the options.')\n\n      return defaultParser.parse(file, { extname: parseExtName })\n    }\n\n    if (!file.extname) {\n      return defaultParser.parse(file, { extname: parseExtName })\n    }\n\n    const parser = parsers.get(file.extname)\n\n    if (!parser) {\n      return defaultParser.parse(file, { extname: parseExtName })\n    }\n\n    return parser.parse(file, { extname: parseExtName })\n  }\n\n  async run(\n    files: Array<KubbFile.ResolvedFile>,\n    { parsers, mode = 'sequential', dryRun, extension }: ProcessFilesProps = {},\n  ): Promise<KubbFile.ResolvedFile[]> {\n    await this.events.emit('files:processing:start', files)\n\n    const total = files.length\n    let processed = 0\n\n    const processOne = async (resolvedFile: KubbFile.ResolvedFile, index: number) => {\n      await this.events.emit('file:processing:start', resolvedFile, index, total)\n\n      const source = dryRun ? undefined : await this.parse(resolvedFile, { extension, parsers })\n\n      const currentProcessed = ++processed\n      const percentage = (currentProcessed / total) * 100\n\n      await this.events.emit('file:processing:update', {\n        file: resolvedFile,\n        source,\n        processed: currentProcessed,\n        percentage,\n        total,\n      })\n\n      await this.events.emit('file:processing:end', resolvedFile, index, total)\n    }\n\n    if (mode === 'sequential') {\n      async function* asyncFiles() {\n        for (let index = 0; index < files.length; index++) {\n          yield [files[index], index] as const\n        }\n      }\n\n      for await (const [file, index] of asyncFiles()) {\n        if (file) {\n          await processOne(file, index)\n        }\n      }\n    } else {\n      const promises = files.map((resolvedFile, index) => this.#limit(() => processOne(resolvedFile, index)))\n      await Promise.all(promises)\n    }\n\n    await this.events.emit('files:processing:end', files)\n\n    return files\n  }\n}\n","export class Cache<T> {\n  #buffer = new Map<string, T>()\n\n  get(key: string): T | null {\n    return this.#buffer.get(key) ?? null\n  }\n\n  set(key: string, value: T): void {\n    this.#buffer.set(key, value)\n  }\n\n  delete(key: string): void {\n    this.#buffer.delete(key)\n  }\n\n  clear(): void {\n    this.#buffer.clear()\n  }\n\n  keys(): string[] {\n    return [...this.#buffer.keys()]\n  }\n\n  values(): Array<T> {\n    return [...this.#buffer.values()]\n  }\n\n  flush(): void {\n    // No-op for base cache\n  }\n}\n","import { orderBy } from 'natural-orderby'\nimport { createFile } from './createFile.ts'\nimport type { FabricEvents } from './Fabric.ts'\nimport { FileProcessor, type ProcessFilesProps } from './FileProcessor.ts'\nimport type * as KubbFile from './KubbFile.ts'\nimport { AsyncEventEmitter } from './utils/AsyncEventEmitter.ts'\nimport { Cache } from './utils/Cache.ts'\nimport { trimExtName } from './utils/trimExtName.ts'\n\nfunction mergeFile<TMeta extends object = object>(a: KubbFile.File<TMeta>, b: KubbFile.File<TMeta>): KubbFile.File<TMeta> {\n  return {\n    ...a,\n    sources: [...(a.sources || []), ...(b.sources || [])],\n    imports: [...(a.imports || []), ...(b.imports || [])],\n    exports: [...(a.exports || []), ...(b.exports || [])],\n  }\n}\n\ntype Options = {\n  events?: AsyncEventEmitter<FabricEvents>\n}\n\nexport class FileManager {\n  #cache = new Cache<KubbFile.ResolvedFile>()\n  #filesCache: Array<KubbFile.ResolvedFile> | null = null\n  events: AsyncEventEmitter<FabricEvents>\n  processor: FileProcessor\n\n  constructor({ events = new AsyncEventEmitter<FabricEvents>() }: Options = {}) {\n    this.processor = new FileProcessor({ events })\n\n    this.events = events\n    return this\n  }\n\n  #resolvePath(file: KubbFile.File): KubbFile.File {\n    this.events.emit('file:resolve:path', file)\n\n    return file\n  }\n\n  #resolveName(file: KubbFile.File): KubbFile.File {\n    this.events.emit('file:resolve:name', file)\n\n    return file\n  }\n\n  add(...files: Array<KubbFile.File>): Array<KubbFile.ResolvedFile> {\n    const resolvedFiles: Array<KubbFile.ResolvedFile> = []\n\n    const mergedFiles = new Map<string, KubbFile.File>()\n\n    files.forEach((file) => {\n      const existing = mergedFiles.get(file.path)\n      if (existing) {\n        mergedFiles.set(file.path, mergeFile(existing, file))\n      } else {\n        mergedFiles.set(file.path, file)\n      }\n    })\n\n    for (let file of mergedFiles.values()) {\n      file = this.#resolveName(file)\n      file = this.#resolvePath(file)\n\n      const resolvedFile = createFile(file)\n\n      this.#cache.set(resolvedFile.path, resolvedFile)\n      this.flush()\n\n      resolvedFiles.push(resolvedFile)\n    }\n\n    this.events.emit('files:added', resolvedFiles)\n\n    return resolvedFiles\n  }\n\n  upsert(...files: Array<KubbFile.File>): Array<KubbFile.ResolvedFile> {\n    const resolvedFiles: Array<KubbFile.ResolvedFile> = []\n\n    const mergedFiles = new Map<string, KubbFile.File>()\n\n    files.forEach((file) => {\n      const existing = mergedFiles.get(file.path)\n      if (existing) {\n        mergedFiles.set(file.path, mergeFile(existing, file))\n      } else {\n        mergedFiles.set(file.path, file)\n      }\n    })\n\n    for (let file of mergedFiles.values()) {\n      const existing = this.#cache.get(file.path)\n\n      file = this.#resolveName(file)\n      file = this.#resolvePath(file)\n\n      const merged = existing ? mergeFile(existing, file) : file\n      const resolvedFile = createFile(merged)\n\n      this.#cache.set(resolvedFile.path, resolvedFile)\n      this.flush()\n\n      resolvedFiles.push(resolvedFile)\n    }\n\n    this.events.emit('files:added', resolvedFiles)\n\n    return resolvedFiles\n  }\n\n  flush() {\n    this.#filesCache = null\n    this.#cache.flush()\n  }\n\n  getByPath(path: KubbFile.Path): KubbFile.ResolvedFile | null {\n    return this.#cache.get(path)\n  }\n\n  deleteByPath(path: KubbFile.Path): void {\n    this.#cache.delete(path)\n    this.#filesCache = null\n  }\n\n  clear(): void {\n    this.#cache.clear()\n    this.#filesCache = null\n  }\n\n  get files(): Array<KubbFile.ResolvedFile> {\n    if (this.#filesCache) {\n      return this.#filesCache\n    }\n\n    const cachedKeys = this.#cache.keys()\n\n    // order by path length and if file is a barrel file\n    const keys = orderBy(cachedKeys, [(v) => v.length, (v) => trimExtName(v).endsWith('index')])\n\n    const files: Array<KubbFile.ResolvedFile> = []\n\n    for (const key of keys) {\n      const file = this.#cache.get(key)\n      if (file) {\n        files.push(file)\n      }\n    }\n\n    this.#filesCache = files\n\n    return files\n  }\n\n  //TODO add test and check if write of FileManager contains the newly added file\n  async write(options: ProcessFilesProps): Promise<KubbFile.ResolvedFile[]> {\n    await this.events.emit('files:writing:start', this.files)\n\n    const resolvedFiles = await this.processor.run(this.files, options)\n\n    this.clear()\n\n    await this.events.emit('files:writing:end', resolvedFiles)\n\n    return resolvedFiles\n  }\n}\n","import type * as KubbFile from '../KubbFile.ts'\n\ntype BarrelData = {\n  file?: KubbFile.File\n  path: string\n  name: string\n}\n\nexport type Graph = {\n  nodes: Array<{ id: string; label: string }>\n  edges: Array<{ from: string; to: string }>\n}\n\nexport class TreeNode<TData = unknown> {\n  data: TData\n  parent?: TreeNode<TData>\n  children: Array<TreeNode<TData>> = []\n  #childrenMap = new Map<string, TreeNode<TData>>()\n  #cachedLeaves?: Array<TreeNode<TData>>\n\n  constructor(data: TData, parent?: TreeNode<TData>) {\n    this.data = data\n    this.parent = parent\n  }\n\n  addChild(data: TData): TreeNode<TData> {\n    const child = new TreeNode(data, this)\n    this.children.push(child)\n    // Update Map if data has a name property (for BarrelData)\n    if (typeof data === 'object' && data !== null && 'name' in data) {\n      this.#childrenMap.set((data as { name: string }).name, child)\n    }\n    this.#cachedLeaves = undefined // invalidate cached leaves\n    return child\n  }\n\n  getChildByName(name: string): TreeNode<TData> | undefined {\n    return this.#childrenMap.get(name)\n  }\n\n  get leaves(): Array<TreeNode<TData>> {\n    if (this.#cachedLeaves) return this.#cachedLeaves\n    if (this.children.length === 0) return [this]\n\n    const result: Array<TreeNode<TData>> = []\n    const stack: Array<TreeNode<TData>> = [...this.children]\n    const visited = new Set<TreeNode<TData>>()\n\n    while (stack.length > 0) {\n      const node = stack.pop()!\n      if (visited.has(node)) {\n        continue\n      }\n      visited.add(node)\n\n      if (node.children.length > 0) {\n        stack.push(...node.children)\n      } else {\n        result.push(node)\n      }\n    }\n\n    this.#cachedLeaves = result\n    return result\n  }\n\n  forEach(callback: (node: TreeNode<TData>) => void): this {\n    const stack: Array<TreeNode<TData>> = [this]\n\n    for (let i = 0; i < stack.length; i++) {\n      const node = stack[i]!\n      callback(node)\n\n      if (node.children.length > 0) {\n        stack.push(...node.children)\n      }\n    }\n\n    return this\n  }\n\n  findDeep(predicate: (node: TreeNode<TData>) => boolean): TreeNode<TData> | undefined {\n    for (const leaf of this.leaves) {\n      if (predicate(leaf)) return leaf\n    }\n    return undefined\n  }\n\n  static toGraph(root: TreeNode<BarrelData>): Graph {\n    const nodes: Array<{ id: string; label: string }> = []\n    const edges: Array<{ from: string; to: string }> = []\n\n    const stack: Array<TreeNode<BarrelData>> = [root]\n\n    for (let i = 0; i < stack.length; i++) {\n      const node = stack[i]!\n\n      nodes.push({\n        id: node.data.path,\n        label: node.data.name,\n      })\n\n      const children = node.children\n      if (children.length > 0) {\n        for (let j = 0, len = children.length; j < len; j++) {\n          const child = children[j]!\n          edges.push({\n            from: node.data.path,\n            to: child.data.path,\n          })\n          stack.push(child)\n        }\n      }\n    }\n\n    return { nodes, edges }\n  }\n\n  static fromFiles(files: Array<KubbFile.File>, rootFolder = ''): TreeNode<BarrelData> | null {\n    const normalizePath = (p: string): string => p.replace(/\\\\/g, '/')\n    const normalizedRoot = normalizePath(rootFolder)\n    const rootPrefix = normalizedRoot.endsWith('/') ? normalizedRoot : `${normalizedRoot}/`\n\n    const normalizedPaths = new Map<KubbFile.File, string>()\n    const filteredFiles: Array<KubbFile.File> = []\n    for (const file of files) {\n      const filePath = normalizedPaths.get(file) ?? normalizePath(file.path)\n      normalizedPaths.set(file, filePath)\n      if (!filePath.endsWith('.json') && (!rootFolder || filePath.startsWith(rootPrefix))) {\n        filteredFiles.push(file)\n      }\n    }\n\n    if (filteredFiles.length === 0) {\n      return null\n    }\n\n    const treeNode = new TreeNode<BarrelData>({\n      name: rootFolder || '',\n      path: rootFolder || '',\n      file: undefined,\n    })\n\n    for (const file of filteredFiles) {\n      const filePath = normalizedPaths.get(file)!\n      const relPath = filePath.slice(rootPrefix.length)\n      const parts = relPath.split('/')\n\n      let current = treeNode\n      let currentPath = rootFolder\n\n      for (const [index, part] of parts.entries()) {\n        const isLast = index === parts.length - 1\n        currentPath += (currentPath.endsWith('/') ? '' : '/') + part\n\n        let next = current.getChildByName(part)\n\n        if (!next) {\n          next = current.addChild({\n            name: part,\n            path: currentPath,\n            file: isLast ? file : undefined,\n          })\n        }\n\n        current = next\n      }\n    }\n\n    return treeNode\n  }\n}\n","import type { ComponentNode } from '../composables/useNodeTree.ts'\nimport { createContext } from '../context.ts'\nimport { FileManager } from '../FileManager.ts'\nimport { TreeNode } from '../utils/TreeNode.ts'\n\nexport type RootContextProps = {\n  /**\n   * Exit (unmount) the whole app.\n   */\n  exit: (error?: Error) => void\n  /**\n   * TreeNode representing the tree structure of the app.\n   */\n  treeNode: TreeNode<ComponentNode>\n  /**\n   * FileManager instance for managing files within the app.\n   */\n  fileManager: FileManager\n}\n\n/**\n * Context providing root-level functionalities such as exit hook, tree node structure, and file management.\n * Define in the `render` helper of the runtime.\n */\nexport const RootContext = createContext<RootContextProps>({\n  exit: () => {},\n  treeNode: new TreeNode({ type: 'Root', props: {} }),\n  fileManager: new FileManager(),\n})\n","import { createContext } from '../context.ts'\n\nexport type RenderContextProps = {\n  indentLevel: number\n  indentSize: number\n  currentLineLength: number\n  shouldBreak: boolean\n}\n\n/**\n * Provides a context for tracking rendering state such as indentation and line length.\n */\nexport const RenderContext = createContext<RenderContextProps>({ indentLevel: 0, indentSize: 2, currentLineLength: 0, shouldBreak: false })\n","import { inject, provide } from './context.ts'\nimport { RenderContext, type RenderContextProps } from './contexts/RenderContext.ts'\nimport type { FabricElement, FabricNode } from './Fabric.ts'\n\ntype IntrinsicType =\n  | 'br' // Line break - adds newline with current indentation\n  | 'indent' // Increase indentation level\n  | 'dedent' // Decrease indentation level\n\nexport type Intrinsic = {\n  type: IntrinsicType\n  __intrinsic: true\n}\n\nfunction isFabricElement<TProps extends object = object>(value: any): value is FabricElement<TProps> {\n  return typeof value === 'function' && 'type' in value && 'component' in value\n}\n\n/**\n * Type guard to check if a value is an intrinsic element\n */\nexport function isIntrinsic(value: any): value is Intrinsic {\n  return value && typeof value === 'object' && value.__intrinsic === true\n}\n\n/**\n * Render a single intrinsic node\n */\nfunction renderIntrinsicNode(node: Intrinsic, renderContext: RenderContextProps): string {\n  switch (node.type) {\n    case 'br':\n      renderContext.currentLineLength = 0\n      return '\\n'\n\n    case 'indent':\n      renderContext.indentLevel++\n      return ''\n\n    case 'dedent':\n      renderContext.indentLevel = Math.max(0, renderContext.indentLevel - 1)\n      return ''\n\n    default:\n      return ''\n  }\n}\n\n/**\n * Helper: render a plain string while applying current indentation at the\n * start of each logical line. This ensures `${indent}` intrinsics affect\n * subsequent string content.\n */\nexport function renderIndent(content: string, renderContext: RenderContextProps): string {\n  if (content.length === 0) {\n    return ''\n  }\n\n  const indentStr = ' '.repeat(renderContext.indentLevel * renderContext.indentSize)\n  const lines = content.split('\\n')\n  let out = ''\n\n  for (const [i, line] of lines.entries()) {\n    if (renderContext.currentLineLength === 0 && line.length > 0) {\n      // At start of a (logical) line: prefix indentation\n      out += indentStr + line\n      renderContext.currentLineLength = indentStr.length + line.length\n    } else {\n      out += line\n      renderContext.currentLineLength += line.length\n    }\n\n    // If not the last line, add newline and reset line length so next line gets indentation\n    if (i !== lines.length - 1) {\n      out += '\\n'\n      renderContext.currentLineLength = 0\n    }\n  }\n\n  return out\n}\n\nexport function renderIntrinsic(children: FabricNode, context?: RenderContextProps): string {\n  const renderContext = context || inject(RenderContext)\n\n  provide(RenderContext, renderContext)\n\n  if (!children) {\n    return ''\n  }\n\n  if (isFabricElement(children)) {\n    try {\n      // FabricElements are already wrapped in transform by createComponent\n      // Just call them and return the result (which is already a string)\n      const result = children()\n      return renderIntrinsic(result)\n    } catch {\n      return ''\n    }\n  }\n\n  if (Array.isArray(children)) {\n    return children.map((child) => renderIntrinsic(child)).join('')\n  }\n\n  if (isIntrinsic(children)) {\n    // Render intrinsic node(s) using the shared render context\n    return renderIntrinsicNode(children, renderContext)\n  }\n\n  if (typeof children === 'function') {\n    return renderIntrinsic(children())\n  }\n\n  if (typeof children === 'string') {\n    return renderIndent(children, renderContext)\n  }\n\n  if (typeof children === 'number') {\n    return renderIndent(String(children), renderContext)\n  }\n\n  if (typeof children === 'boolean') {\n    return renderIndent(children ? 'true' : 'false', renderContext)\n  }\n\n  // Fallback for FabricElement/object-like values\n  try {\n    return renderIndent(children, renderContext)\n  } catch {\n    return ''\n  }\n}\n\n/**\n * Create an intrinsic element\n */\nexport function createIntrinsic(type: IntrinsicType): Intrinsic {\n  return {\n    type,\n    __intrinsic: true,\n  }\n}\n","import type { FabricComponent, FabricElement, FabricNode } from './Fabric.ts'\nimport { renderIntrinsic } from './intrinsic.ts'\n\ntype MakeChildrenOptional<T extends object> = T extends { children?: any } ? Omit<T, 'children'> & Partial<Pick<T, 'children'>> : T\n\nexport type ComponentBuilder<T extends object> = {\n  (...args: unknown extends T ? [] : {} extends Omit<T, 'children'> ? [props?: MakeChildrenOptional<T>] : [props: MakeChildrenOptional<T>]): FabricComponent<T>\n  displayName?: string | undefined\n}\n\nexport function createComponent<TProps extends object>(type: string, Component: (props: TProps) => FabricNode): ComponentBuilder<TProps> {\n  return (...args) => {\n    const fn: FabricComponent<TProps> = (() => renderIntrinsic(Component(args[0] as TProps) as FabricNode)) as any\n    fn.component = Component\n    fn.props = args[0]! as TProps\n    fn.type = type\n    fn.children = (...children: Array<FabricNode>) => {\n      const propsWithChildren = {\n        ...(args[0] ?? {}),\n        children() {\n          return renderIntrinsic(children)\n        },\n      } as unknown as TProps\n\n      const fnChild = (() => renderIntrinsic(Component(propsWithChildren) as FabricNode)) as FabricElement<TProps>\n      fnChild.component = Component\n      fnChild.props = args[0]! as TProps\n      fnChild.type = type\n      return fnChild\n    }\n\n    return fn\n  }\n}\n","import type { ComponentNode } from '../composables/useNodeTree.ts'\nimport { provide } from '../context.ts'\nimport { NodeTreeContext } from '../contexts/NodeTreeContext.ts'\nimport { RootContext } from '../contexts/RootContext.ts'\nimport { createComponent } from '../createComponent.ts'\nimport type { FabricNode } from '../Fabric.ts'\nimport type { FileManager } from '../FileManager.ts'\nimport type { TreeNode } from '../utils/TreeNode.ts'\n\nexport type RootProps = {\n  /**\n   * Exit (unmount) the whole app.\n   */\n  onExit: (error?: Error) => void\n  /**\n   * Error hook receiving runtime exceptions.\n   */\n  onError: (error: Error) => void\n  /**\n   * TreeNode representing the tree structure of the app.\n   */\n  treeNode: TreeNode<ComponentNode>\n  /**\n   * FileManager instance for managing files within the app.\n   */\n  fileManager: FileManager\n  /**\n   * Children nodes.\n   */\n  children?: FabricNode\n}\n\n/**\n * This component provides the root behavior for the Fabric runtime.\n */\nexport const Root = createComponent('Root', ({ onError, onExit, treeNode, fileManager, children }: RootProps) => {\n  provide(RootContext, { exit: onExit, treeNode, fileManager })\n  provide(NodeTreeContext, treeNode)\n\n  try {\n    return children\n  } catch (e) {\n    if (e instanceof Error) {\n      onError?.(e)\n    }\n    return ''\n  }\n})\n\nRoot.displayName = 'KubbRoot'\n"],"mappings":"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"}