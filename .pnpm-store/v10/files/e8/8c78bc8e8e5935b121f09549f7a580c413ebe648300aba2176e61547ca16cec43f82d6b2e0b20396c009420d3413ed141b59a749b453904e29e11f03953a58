{"version":3,"sources":["/home/runner/work/kubb/kubb/packages/plugin-oas/dist/utils.cjs","../src/utils/index.ts","../src/utils/getComments.ts","../src/utils/getGroupedByTagFiles.ts","../src/utils/getParams.ts","../src/utils/refSorter.ts"],"names":[],"mappings":"AAAA;AACE;AACF,wDAA6B;AAC7B;AACE;AACA;AACA;AACF,wDAA6B;AAC7B;AACA;ACTA,8CAAA,CAAA;ADWA;AACA;AEZA,8CAAA,CAAA;AAAA,mHAAyB;AACzB,yCAAwB;AAIjB,SAAS,WAAA,CAAY,SAAA,EAAgC;AAC1D,EAAA,OAAO;AAAA,IACL,SAAA,CAAU,cAAA,CAAe,EAAA,GAAK,CAAA,aAAA,EAAgB,SAAA,CAAU,cAAA,CAAe,CAAC,CAAA,CAAA;AACZ,IAAA;AACF,IAAA;AAC9B,IAAA;AAGU,EAAA;AAC1C;AFU6E;AACA;AGzB7E;AAAwB;AAEI;AACH;AACM;AACC;AAgC8C;AACpC,EAAA;AACY,EAAA;AAEL,EAAA;AACrC,IAAA;AACV,EAAA;AAGoB,EAAA;AACqB,IAAA;AACd,IAAA;AAEe,EAAA;AACjB,IAAA;AACmD,sBAAA;AAEtE,MAAA;AACF,IAAA;AAEkE,IAAA;AACE,IAAA;AACpB,IAAA;AAEnC,IAAA;AACJ,MAAA;AACK,QAAA;AACiC,QAAA;AACnC,QAAA;AACC,QAAA;AACP,UAAA;AACkE,YAAA;AACvD,YAAA;AACH,YAAA;AACR,UAAA;AACF,QAAA;AACM,QAAA;AACc,UAAA;AACpB,QAAA;AACY,QAAA;AACd,MAAA;AACF,IAAA;AAEa,EAAA;AACnB;AHZ6E;AACA;AItE7E;AAAkC;AAMR;AAQxB;AACU,EAAA;AACR,EAAA;AAKmB;AAC0C,EAAA;AACrD,IAAA;AACV,EAAA;AAE2E,EAAA;AACjC,IAAA;AACR,IAAA;AAC9B,MAAA;AACW,MAAA;AAC2B,MAAA;AACe,MAAA;AACvD,IAAA;AAEmC,IAAA;AACpC,EAAA;AACH;AAQE;AACoE,EAAA;AACnC,IAAA;AACD,MAAA;AACZ,QAAA;AACH,QAAA;AACK,QAAA;AAClB,MAAA;AACF,IAAA;AAEO,IAAA;AACM,EAAA;AACjB;AJ+C6E;AACA;AKzG7E;AAIoE;AACG,EAAA;AAC5D,IAAA;AACT,EAAA;AACqE,EAAA;AAC5D,IAAA;AACT,EAAA;AACO,EAAA;AACT;ALwG6E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/home/runner/work/kubb/kubb/packages/plugin-oas/dist/utils.cjs","sourcesContent":[null,"export { getComments } from './getComments.ts'\nexport { getGroupedByTagFiles } from './getGroupedByTagFiles.ts'\nexport { getASTParams, getPathParams } from './getParams.ts'\nexport { getSchemaFactory } from './getSchemaFactory.ts'\nexport type { GetSchemasProps } from './getSchemas.ts'\nexport { getSchemas } from './getSchemas.ts'\nexport { refsSorter } from './refSorter.ts'\nexport { parseFromConfig } from './parseFromConfig.ts'\n","import transformers from '@kubb/core/transformers'\nimport { URLPath } from '@kubb/core/utils'\n\nimport type { Operation } from '@kubb/oas'\n\nexport function getComments(operation: Operation): string[] {\n  return [\n    operation.getDescription() && `@description ${operation.getDescription()}`,\n    operation.getSummary() && `@summary ${operation.getSummary()}`,\n    operation.path && `@link ${new URLPath(operation.path).URL}`,\n    operation.isDeprecated() && '@deprecated',\n  ]\n    .filter(Boolean)\n    .map((text) => transformers.trim(text))\n}\n","import { resolve } from 'node:path'\n\nimport { FileManager } from '@kubb/core'\nimport transformers from '@kubb/core/transformers'\nimport { renderTemplate } from '@kubb/core/utils'\nimport { getRelativePath } from '@kubb/fs'\n\nimport type { Plugin } from '@kubb/core'\nimport type { Logger } from '@kubb/core/logger'\nimport type * as KubbFile from '@kubb/fs/types'\n\ntype Options = {\n  logger: Logger\n  files: Array<KubbFile.File<FileMeta>>\n  plugin: Plugin\n  template: string\n  exportAs: string\n  /**\n   * Root based on root and output.path specified in the config\n   */\n  root: string\n  /**\n   * Output for plugin\n   */\n  output: {\n    path: string\n    exportAs?: string\n    extName?: KubbFile.Extname\n    exportType?: 'barrel' | 'barrelNamed' | false\n  }\n}\n\ntype FileMeta = {\n  pluginKey?: Plugin['key']\n  tag?: string\n}\n\nexport async function getGroupedByTagFiles({ logger, files, plugin, template, exportAs, root, output }: Options): Promise<KubbFile.File<FileMeta>[]> {\n  const { path, exportType = 'barrel' } = output\n  const mode = FileManager.getMode(resolve(root, path))\n\n  if (mode === 'single' || exportType === false) {\n    return []\n  }\n\n  return files\n    .filter((file) => {\n      const name = file.meta?.pluginKey?.[0]\n      return name === plugin.name\n    })\n    .map((file: KubbFile.File<FileMeta>) => {\n      if (!file.meta?.tag) {\n        logger?.emit('debug', [`Could not find a tagName for ${JSON.stringify(file, undefined, 2)}`])\n\n        return\n      }\n\n      const tag = file.meta?.tag && transformers.camelCase(file.meta.tag)\n      const tagPath = getRelativePath(resolve(root, output.path), resolve(root, renderTemplate(template, { tag })))\n      const tagName = renderTemplate(exportAs, { tag })\n\n      if (tagName) {\n        return {\n          baseName: 'index.ts' as const,\n          path: resolve(root, output.path, 'index.ts'),\n          source: '',\n          exports: [\n            {\n              path: output.extName ? `${tagPath}/index${output.extName}` : `${tagPath}/index`,\n              asAlias: true,\n              name: tagName,\n            },\n          ],\n          meta: {\n            pluginKey: plugin.key,\n          },\n          exportable: true,\n        }\n      }\n    })\n    .filter(Boolean)\n}\n","import { isParameterObject } from '@kubb/oas'\n\nimport type { FunctionParamsAST } from '@kubb/core/utils'\nimport type { OasTypes } from '@kubb/oas'\nimport type { Params } from '@kubb/react'\nimport type { OperationSchema } from '../types.ts'\nimport { camelCase } from '@kubb/core/transformers'\n/**\n *\n * @deprecated\n * TODO move to operationManager hook\n */\nexport function getASTParams(\n  operationSchema: OperationSchema | undefined,\n  {\n    typed = false,\n    override,\n  }: {\n    typed?: boolean\n    override?: (data: FunctionParamsAST) => FunctionParamsAST\n  } = {},\n): FunctionParamsAST[] {\n  if (!operationSchema || !operationSchema.schema.properties || !operationSchema.name) {\n    return []\n  }\n\n  return Object.entries(operationSchema.schema.properties).map(([name, schema]: [string, OasTypes.SchemaObject]) => {\n    const isParam = isParameterObject(schema)\n    const data: FunctionParamsAST = {\n      name,\n      enabled: !!name,\n      required: isParam ? schema.required : true,\n      type: typed ? `${operationSchema.name}[\"${name}\"]` : undefined,\n    }\n\n    return override ? override(data) : data\n  })\n}\n\nexport function getPathParams(\n  operationSchema: OperationSchema | undefined,\n  options: {\n    typed?: boolean\n    override?: (data: FunctionParamsAST) => FunctionParamsAST\n  } = {},\n) {\n  return getASTParams(operationSchema, options).reduce((acc, curr) => {\n    if (curr.name && curr.enabled) {\n      acc[camelCase(curr.name)] = {\n        default: curr.default,\n        type: curr.type,\n        optional: !curr.required,\n      }\n    }\n\n    return acc\n  }, {} as Params)\n}\n","import type { Refs } from '../types.ts'\n\ntype Generated = { import: { refs: Refs; name: string } }\n\nexport function refsSorter<T extends Generated>(a: T, b: T): number {\n  if (Object.keys(a.import.refs)?.length < Object.keys(b.import.refs)?.length) {\n    return -1\n  }\n  if (Object.keys(a.import.refs)?.length > Object.keys(b.import.refs)?.length) {\n    return 1\n  }\n  return 0\n}\n"]}