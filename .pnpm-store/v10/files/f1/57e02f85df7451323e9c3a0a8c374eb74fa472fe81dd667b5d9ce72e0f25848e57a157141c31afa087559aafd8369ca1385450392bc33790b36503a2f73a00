import { n as __name } from "./chunk-Cq_TCZj9.js";
import { n as defineParser, r as trimExtName, t as getRelativePath } from "./getRelativePath-DlmBsdV8.js";
import path from "node:path";
import ts from "typescript";

//#region src/parsers/typescriptParser.ts
const { factory } = ts;
/**
* Validates TypeScript AST nodes before printing to catch invalid nodes early.
* Throws an error if any node has SyntaxKind.Unknown which would cause the TypeScript printer to crash.
*/
function validateNodes(...nodes) {
	for (const node of nodes) {
		if (!node) throw new Error("Attempted to print undefined or null TypeScript node");
		if (node.kind === ts.SyntaxKind.Unknown) throw new Error(`Invalid TypeScript AST node detected with SyntaxKind.Unknown. This typically indicates a schema pattern that couldn't be properly converted to TypeScript. Node: ${JSON.stringify(node, null, 2)}`);
	}
}
/**
* Convert AST TypeScript/TSX nodes to a string based on the TypeScript printer.
*/
function print(...elements) {
	const sourceFile = ts.createSourceFile("print.tsx", "", ts.ScriptTarget.ES2022, true, ts.ScriptKind.TSX);
	const printer = ts.createPrinter({
		omitTrailingSemicolon: true,
		newLine: ts.NewLineKind.LineFeed,
		removeComments: false,
		noEmitHelpers: true
	});
	for (const node of elements) if (node.kind === ts.SyntaxKind.Unknown) console.error("⚠️ Unknown node found:", node);
	return printer.printList(ts.ListFormat.MultiLine, factory.createNodeArray(elements.filter(Boolean)), sourceFile).replace(/\r\n/g, "\n");
}
function safePrint(...elements) {
	validateNodes(...elements);
	return print(...elements);
}
function createImport({ name, path, root, isTypeOnly = false, isNameSpace = false }) {
	const resolvePath = root ? getRelativePath(root, path) : path;
	if (!Array.isArray(name)) {
		if (isNameSpace) return factory.createImportDeclaration(void 0, factory.createImportClause(isTypeOnly, void 0, factory.createNamespaceImport(factory.createIdentifier(name))), factory.createStringLiteral(resolvePath), void 0);
		return factory.createImportDeclaration(void 0, factory.createImportClause(isTypeOnly, factory.createIdentifier(name), void 0), factory.createStringLiteral(resolvePath), void 0);
	}
	const specifiers = name.map((item) => {
		if (typeof item === "object") {
			const { propertyName, name: alias } = item;
			return factory.createImportSpecifier(false, alias ? factory.createIdentifier(propertyName) : void 0, factory.createIdentifier(alias !== null && alias !== void 0 ? alias : propertyName));
		}
		return factory.createImportSpecifier(false, void 0, factory.createIdentifier(item));
	});
	return factory.createImportDeclaration(void 0, factory.createImportClause(isTypeOnly, void 0, factory.createNamedImports(specifiers)), factory.createStringLiteral(resolvePath), void 0);
}
function createExport({ path, asAlias, isTypeOnly = false, name }) {
	if (name && !Array.isArray(name) && !asAlias) console.warn(`When using name as string, asAlias should be true ${name}`);
	if (!Array.isArray(name)) {
		const parsedName = (name === null || name === void 0 ? void 0 : name.match(/^\d/)) ? `_${name === null || name === void 0 ? void 0 : name.slice(1)}` : name;
		return factory.createExportDeclaration(void 0, isTypeOnly, asAlias && parsedName ? factory.createNamespaceExport(factory.createIdentifier(parsedName)) : void 0, factory.createStringLiteral(path), void 0);
	}
	return factory.createExportDeclaration(void 0, isTypeOnly, factory.createNamedExports(name.map((propertyName) => {
		return factory.createExportSpecifier(false, void 0, typeof propertyName === "string" ? factory.createIdentifier(propertyName) : propertyName);
	})), factory.createStringLiteral(path), void 0);
}
const typescriptParser = defineParser({
	name: "typescript",
	extNames: [".ts", ".js"],
	install() {},
	async parse(file, options = { extname: ".ts" }) {
		const sourceParts = [];
		for (const item of file.sources) if (item.value) sourceParts.push(item.value);
		const source = sourceParts.join("\n\n");
		const importNodes = [];
		for (const item of file.imports) {
			const importPath = item.root ? getRelativePath(item.root, item.path) : item.path;
			const hasExtname = !!path.extname(importPath);
			importNodes.push(createImport({
				name: item.name,
				path: options.extname && hasExtname ? `${trimExtName(importPath)}${options.extname}` : item.root ? trimExtName(importPath) : importPath,
				isTypeOnly: item.isTypeOnly
			}));
		}
		const exportNodes = [];
		for (const item of file.exports) {
			const exportPath = item.path;
			const hasExtname = !!path.extname(exportPath);
			exportNodes.push(createExport({
				name: item.name,
				path: options.extname && hasExtname ? `${trimExtName(item.path)}${options.extname}` : trimExtName(item.path),
				isTypeOnly: item.isTypeOnly,
				asAlias: item.asAlias
			}));
		}
		return [
			file.banner,
			print(...importNodes, ...exportNodes),
			source,
			file.footer
		].filter((segment) => segment != null).join("\n");
	}
});

//#endregion
export { typescriptParser as a, safePrint as i, createImport as n, validateNodes as o, print as r, createExport as t };
//# sourceMappingURL=typescriptParser-D8rhO8nO.js.map