{"version":3,"sources":["/home/runner/work/kubb/kubb/packages/core/dist/index.cjs","../src/index.ts","../src/build.ts","../src/PluginManager.ts","../src/PromiseManager.ts","../src/utils/executeStrategies.ts","../src/errors.ts","../src/plugin.ts","../src/utils/cache.ts","../src/config.ts","../src/Generator.ts","../src/PackageManager.ts","../../../node_modules/.pnpm/find-up@7.0.0/node_modules/find-up/index.js","../../../node_modules/.pnpm/locate-path@7.2.0/node_modules/locate-path/index.js","../../../node_modules/.pnpm/p-locate@6.0.0/node_modules/p-locate/index.js","../../../node_modules/.pnpm/p-limit@4.0.0/node_modules/p-limit/index.js","../../../node_modules/.pnpm/yocto-queue@1.0.0/node_modules/yocto-queue/index.js","../../../node_modules/.pnpm/unicorn-magic@0.1.0/node_modules/unicorn-magic/node.js","../../../node_modules/.pnpm/path-exists@5.0.0/node_modules/path-exists/index.js"],"names":["path","files","read","require","readSync"],"mappings":"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","file":"/home/runner/work/kubb/kubb/packages/core/dist/index.cjs","sourcesContent":[null,"export { build, build as default, safeBuild } from './build.ts'\nexport { defineConfig, isInputPath } from './config.ts'\nexport { Warning } from './errors.ts'\nexport { FileManager } from './FileManager.ts'\nexport type { FileMetaBase } from './FileManager.ts'\nexport { Generator } from './Generator.ts'\nexport { PackageManager } from './PackageManager.ts'\nexport { createPlugin } from './plugin.ts'\nexport { PluginManager } from './PluginManager.ts'\nexport { PromiseManager } from './PromiseManager.ts'\nexport type * from './types.ts'\n\n// biome-ignore lint/suspicious/noEmptyInterface: <explanation>\nexport interface _Register {}\n","import c from 'tinyrainbow'\n\nimport { clean, read } from '@kubb/fs'\nimport { FileManager, type ResolvedFile } from './FileManager.ts'\nimport { PluginManager } from './PluginManager.ts'\nimport { isPromise } from './PromiseManager.ts'\nimport { isInputPath } from './config.ts'\nimport { LogLevel, createLogger, randomCliColour } from './logger.ts'\nimport { URLPath } from './utils/URLPath.ts'\n\nimport type { Logger } from './logger.ts'\nimport type { Plugin, PluginContext, PluginParameter, TransformResult } from './types.ts'\n\ntype BuildOptions = {\n  config: PluginContext['config']\n  /**\n   * @default Logger without the spinner\n   */\n  logger?: Logger\n}\n\ntype BuildOutput = {\n  files: FileManager['files']\n  pluginManager: PluginManager\n  /**\n   * Only for safeBuild\n   */\n  error?: Error\n}\n\nasync function transformReducer(\n  this: PluginContext,\n  _previousCode: string,\n  result: TransformResult | Promise<TransformResult>,\n  _plugin: Plugin,\n): Promise<string | null> {\n  return result\n}\n\nasync function setup(options: BuildOptions): Promise<PluginManager> {\n  const { config, logger = createLogger({ logLevel: LogLevel.silent }) } = options\n  let count = 0\n\n  try {\n    if (isInputPath(config) && !new URLPath(config.input.path).isURL) {\n      await read(config.input.path)\n    }\n  } catch (e) {\n    if (isInputPath(config)) {\n      throw new Error(\n        `Cannot read file/URL defined in \\`input.path\\` or set with \\`kubb generate PATH\\` in the CLI of your Kubb config ${c.dim(config.input.path)}`,\n        {\n          cause: e,\n        },\n      )\n    }\n  }\n\n  if (config.output.clean) {\n    await clean(config.output.path)\n  }\n\n  const task = async (file: ResolvedFile): Promise<ResolvedFile> => {\n    const { path } = file\n\n    let source: string | null = await FileManager.getSource(file)\n\n    const { result: loadedResult } = await pluginManager.hookFirst({\n      hookName: 'load',\n      parameters: [path],\n    })\n    if (loadedResult && isPromise(loadedResult)) {\n      source = await loadedResult\n    }\n    if (loadedResult && !isPromise(loadedResult)) {\n      source = loadedResult\n    }\n\n    if (source) {\n      source = await pluginManager.hookReduceArg0({\n        hookName: 'transform',\n        parameters: [path, source],\n        reduce: transformReducer,\n      })\n\n      if (config.output.write || config.output.write === undefined) {\n        if (file.meta?.pluginKey) {\n          // run only for pluginKey defined in the meta of the file\n          await pluginManager.hookForPlugin({\n            pluginKey: file.meta?.pluginKey,\n            hookName: 'writeFile',\n            parameters: [path, source],\n          })\n        }\n\n        await pluginManager.hookFirst({\n          hookName: 'writeFile',\n          parameters: [path, source],\n        })\n      }\n    }\n\n    return {\n      ...file,\n      source: source || '',\n    }\n  }\n\n  const pluginManager = new PluginManager(config, { logger, task })\n\n  pluginManager.on('execute', (executer) => {\n    const { hookName, parameters, plugin } = executer\n\n    if (hookName === 'writeFile') {\n      const [code] = parameters as PluginParameter<'writeFile'>\n\n      logger.emit('debug', [`PluginKey ${c.dim(JSON.stringify(plugin.key))} \\nwith source\\n\\n${code}`])\n    }\n  })\n\n  pluginManager.queue.on('add', () => {\n    if (logger.logLevel !== LogLevel.info) {\n      return\n    }\n\n    if (count === 0) {\n      logger.emit('start', 'ðŸ’¾ Writing')\n    }\n  })\n\n  pluginManager.queue.on('active', () => {\n    if (logger.logLevel !== LogLevel.info) {\n      return\n    }\n\n    if (logger.spinner && pluginManager.queue.size > 0) {\n      const text = `Item: ${count} Size: ${pluginManager.queue.size}  Pending: ${pluginManager.queue.pending}`\n\n      logger.spinner.suffixText = c.dim(text)\n    }\n    ++count\n  })\n\n  pluginManager.queue.on('completed', () => {\n    if (logger.logLevel !== LogLevel.info) {\n      return\n    }\n\n    if (logger.spinner) {\n      const text = `Item: ${count} Size: ${pluginManager.queue.size}  Pending: ${pluginManager.queue.pending}`\n\n      logger.spinner.suffixText = c.dim(text)\n    }\n  })\n\n  pluginManager.on('executed', (executer) => {\n    const { hookName, plugin, output, parameters } = executer\n\n    const logs = [\n      `${randomCliColour(plugin.name)} Executing ${hookName}`,\n      parameters && `${c.bgWhite('Parameters')} ${randomCliColour(plugin.name)} ${hookName}`,\n      JSON.stringify(parameters, undefined, 2),\n      output && `${c.bgWhite('Output')} ${randomCliColour(plugin.name)} ${hookName}`,\n      output,\n    ].filter(Boolean)\n\n    logger.emit('debug', logs as string[])\n  })\n\n  return pluginManager\n}\n\nexport async function build(options: BuildOptions): Promise<BuildOutput> {\n  const pluginManager = await setup(options)\n\n  const { fileManager, logger } = pluginManager\n\n  await pluginManager.hookParallel({\n    hookName: 'buildStart',\n    parameters: [options.config],\n  })\n\n  await pluginManager.hookParallel({ hookName: 'buildEnd' })\n\n  if (logger.logLevel === LogLevel.info) {\n    logger.emit('end', 'ðŸ’¾ Writing completed')\n  }\n\n  const files = await Promise.all(\n    fileManager.files.map(async (file) => ({\n      ...file,\n      source: await FileManager.getSource(file),\n    })),\n  )\n\n  return {\n    files,\n    pluginManager,\n  }\n}\n\nexport async function safeBuild(options: BuildOptions): Promise<BuildOutput> {\n  const pluginManager = await setup(options)\n\n  const { fileManager, logger } = pluginManager\n\n  try {\n    await pluginManager.hookParallel({\n      hookName: 'buildStart',\n      parameters: [options.config],\n    })\n\n    await pluginManager.hookParallel({ hookName: 'buildEnd' })\n\n    if (logger.logLevel === LogLevel.info) {\n      logger.emit('end', 'ðŸ’¾ Writing completed')\n    }\n  } catch (e) {\n    const files = await Promise.all(\n      fileManager.files.map(async (file) => ({\n        ...file,\n        source: await FileManager.getSource(file),\n      })),\n    )\n\n    return {\n      files,\n      pluginManager,\n      error: e as Error,\n    }\n  }\n\n  const files = await Promise.all(\n    fileManager.files.map(async (file) => ({\n      ...file,\n      source: await FileManager.getSource(file),\n    })),\n  )\n\n  return {\n    files,\n    pluginManager,\n  }\n}\n","import PQueue from 'p-queue'\n\nimport { readSync } from '@kubb/fs'\nimport { FileManager, type ResolvedFile } from './FileManager.ts'\nimport { isPromise, isPromiseRejectedResult } from './PromiseManager.ts'\nimport { PromiseManager } from './PromiseManager.ts'\nimport { ValidationPluginError } from './errors.ts'\nimport { LogLevel } from './logger.ts'\nimport { pluginCore } from './plugin.ts'\nimport { transformReservedWord } from './transformers/transformReservedWord.ts'\nimport { EventEmitter } from './utils/EventEmitter.ts'\nimport { setUniqueName } from './utils/uniqueName.ts'\n\nimport type * as KubbFile from '@kubb/fs/types'\nimport type { PossiblePromise } from '@kubb/types'\nimport type { Logger } from './logger.ts'\nimport type { PluginCore } from './plugin.ts'\nimport type {\n  Config,\n  GetPluginFactoryOptions,\n  Plugin,\n  PluginFactoryOptions,\n  PluginLifecycle,\n  PluginLifecycleHooks,\n  PluginParameter,\n  PluginWithLifeCycle,\n  ResolveNameParams,\n  ResolvePathParams,\n  UserPlugin,\n  UserPluginWithLifeCycle,\n} from './types.ts'\n\ntype RequiredPluginLifecycle = Required<PluginLifecycle>\n\n/**\n * Get the type of the first argument in a function.\n * @example Arg0<(a: string, b: number) => void> -> string\n */\ntype Argument0<H extends keyof PluginLifecycle> = Parameters<RequiredPluginLifecycle[H]>[0]\n\ntype Strategy = 'hookFirst' | 'hookForPlugin' | 'hookParallel' | 'hookReduceArg0' | 'hookSeq'\n\ntype Executer<H extends PluginLifecycleHooks = PluginLifecycleHooks> = {\n  strategy: Strategy\n  hookName: H\n  plugin: Plugin\n  parameters?: unknown[] | undefined\n  output?: unknown\n}\n\ntype ParseResult<H extends PluginLifecycleHooks> = RequiredPluginLifecycle[H]\n\ntype SafeParseResult<H extends PluginLifecycleHooks, Result = ReturnType<ParseResult<H>>> = {\n  result: Result\n  plugin: Plugin\n}\n\n// inspired by: https://github.com/rollup/rollup/blob/master/src/utils/PluginDriver.ts#\n\ntype Options = {\n  logger: Logger\n\n  /**\n   * Task for the FileManager\n   */\n  task: (file: ResolvedFile) => Promise<ResolvedFile>\n}\n\ntype Events = {\n  execute: [executer: Executer]\n  executed: [executer: Executer]\n  error: [error: Error]\n}\n\ntype GetFileProps<TOptions = object> = {\n  name: string\n  mode?: KubbFile.Mode\n  extName: KubbFile.Extname\n  pluginKey: Plugin['key']\n  options?: TOptions\n}\n\nexport class PluginManager {\n  readonly plugins: PluginWithLifeCycle[]\n  readonly fileManager: FileManager\n  readonly events: EventEmitter<Events> = new EventEmitter()\n\n  readonly config: Config\n\n  readonly executed: Array<Executer> = []\n  readonly logger: Logger\n  readonly #core: Plugin<PluginCore>\n\n  readonly #usedPluginNames: Record<string, number> = {}\n  readonly #promiseManager: PromiseManager\n\n  readonly queue: PQueue\n\n  constructor(config: Config, options: Options) {\n    this.config = config\n    this.logger = options.logger\n    this.queue = new PQueue({ concurrency: 1 })\n    this.fileManager = new FileManager({\n      task: options.task,\n      queue: this.queue,\n    })\n    this.#promiseManager = new PromiseManager({\n      nullCheck: (state: SafeParseResult<'resolveName'> | null) => !!state?.result,\n    })\n\n    const plugins = config.plugins || []\n\n    const core = pluginCore({\n      config,\n      logger: this.logger,\n      pluginManager: this,\n      fileManager: this.fileManager,\n      resolvePath: this.resolvePath.bind(this),\n      resolveName: this.resolveName.bind(this),\n      getPlugins: this.#getSortedPlugins.bind(this),\n    })\n\n    // call core.api.call with empty context so we can transform `api()` to `api: {}`\n    this.#core = this.#parse(core as unknown as UserPlugin, this as any, core.api.call(null as any)) as Plugin<PluginCore>\n\n    this.plugins = [this.#core, ...plugins].map((plugin) => {\n      return this.#parse(plugin as UserPlugin, this, this.#core.api)\n    })\n\n    return this\n  }\n\n  getFile<TOptions = object>({ name, mode, extName, pluginKey, options }: GetFileProps<TOptions>): KubbFile.File<{ pluginKey: Plugin['key'] }> {\n    let source = ''\n    const baseName = `${name}${extName}` as const\n    const path = this.resolvePath({ baseName, mode, pluginKey, options })\n\n    if (!path) {\n      throw new Error(`Filepath should be defined for resolvedName \"${name}\" and pluginKey [${JSON.stringify(pluginKey)}]`)\n    }\n\n    try {\n      source = readSync(path)\n    } catch (_e) {\n      //\n    }\n\n    return {\n      path,\n      baseName,\n      meta: {\n        pluginKey,\n      },\n      source,\n    }\n  }\n\n  resolvePath = <TOptions = object>(params: ResolvePathParams<TOptions>): KubbFile.OptionalPath => {\n    if (params.pluginKey) {\n      const paths = this.hookForPluginSync({\n        pluginKey: params.pluginKey,\n        hookName: 'resolvePath',\n        parameters: [params.baseName, params.mode, params.options as object],\n      })\n\n      if (paths && paths?.length > 1) {\n        this.logger.emit('debug', [\n          `Cannot return a path where the 'pluginKey' ${\n            params.pluginKey ? JSON.stringify(params.pluginKey) : '\"'\n          } is not unique enough\\n\\nPaths: ${JSON.stringify(paths, undefined, 2)}\\n\\nFalling back on the first item.\\n`,\n        ])\n      }\n\n      return paths?.at(0)\n    }\n    return this.hookFirstSync({\n      hookName: 'resolvePath',\n      parameters: [params.baseName, params.mode, params.options as object],\n    }).result\n  }\n  resolveName = (params: ResolveNameParams): string => {\n    if (params.pluginKey) {\n      const names = this.hookForPluginSync({\n        pluginKey: params.pluginKey,\n        hookName: 'resolveName',\n        parameters: [params.name, params.type],\n      })\n\n      if (names && names?.length > 1) {\n        this.logger.emit('debug', [\n          `Cannot return a name where the 'pluginKey' ${\n            params.pluginKey ? JSON.stringify(params.pluginKey) : '\"'\n          } is not unique enough\\n\\nNames: ${JSON.stringify(names, undefined, 2)}\\n\\nFalling back on the first item.\\n`,\n        ])\n      }\n\n      return transformReservedWord(names?.at(0) || params.name)\n    }\n\n    const name = this.hookFirstSync({\n      hookName: 'resolveName',\n      parameters: [params.name, params.type],\n    }).result\n\n    return transformReservedWord(name)\n  }\n\n  /**\n   * Instead of calling `pluginManager.events.on` you can use `pluginManager.on`. This one also has better types.\n   */\n  on<TEventName extends keyof Events & string>(eventName: TEventName, handler: (...eventArg: Events[TEventName]) => void): void {\n    this.events.on(eventName, handler as any)\n  }\n\n  /**\n   * Run a specific hookName for plugin x.\n   */\n  hookForPlugin<H extends PluginLifecycleHooks>({\n    pluginKey,\n    hookName,\n    parameters,\n  }: {\n    pluginKey: Plugin['key']\n    hookName: H\n    parameters: PluginParameter<H>\n  }): Promise<Array<ReturnType<ParseResult<H>> | null>> | null {\n    const plugins = this.getPluginsByKey(hookName, pluginKey)\n\n    const promises = plugins\n      .map((plugin) => {\n        return this.#execute<H>({\n          strategy: 'hookFirst',\n          hookName,\n          parameters,\n          plugin,\n        })\n      })\n      .filter(Boolean)\n\n    return Promise.all(promises)\n  }\n  /**\n   * Run a specific hookName for plugin x.\n   */\n\n  hookForPluginSync<H extends PluginLifecycleHooks>({\n    pluginKey,\n    hookName,\n    parameters,\n  }: {\n    pluginKey: Plugin['key']\n    hookName: H\n    parameters: PluginParameter<H>\n  }): Array<ReturnType<ParseResult<H>>> | null {\n    const plugins = this.getPluginsByKey(hookName, pluginKey)\n\n    return plugins\n      .map((plugin) => {\n        return this.#executeSync<H>({\n          strategy: 'hookFirst',\n          hookName,\n          parameters,\n          plugin,\n        })\n      })\n      .filter(Boolean)\n  }\n\n  /**\n   * First non-null result stops and will return it's value.\n   */\n  async hookFirst<H extends PluginLifecycleHooks>({\n    hookName,\n    parameters,\n    skipped,\n  }: {\n    hookName: H\n    parameters: PluginParameter<H>\n    skipped?: ReadonlySet<Plugin> | null\n  }): Promise<SafeParseResult<H>> {\n    const promises = this.#getSortedPlugins()\n      .filter((plugin) => {\n        return skipped ? skipped.has(plugin) : true\n      })\n      .map((plugin) => {\n        return async () => {\n          const value = await this.#execute<H>({\n            strategy: 'hookFirst',\n            hookName,\n            parameters,\n            plugin,\n          })\n\n          return Promise.resolve({\n            plugin,\n            result: value,\n          } as SafeParseResult<H>)\n        }\n      })\n\n    return this.#promiseManager.run('first', promises)\n  }\n\n  /**\n   * First non-null result stops and will return it's value.\n   */\n  hookFirstSync<H extends PluginLifecycleHooks>({\n    hookName,\n    parameters,\n    skipped,\n  }: {\n    hookName: H\n    parameters: PluginParameter<H>\n    skipped?: ReadonlySet<Plugin> | null\n  }): SafeParseResult<H> {\n    let parseResult: SafeParseResult<H> = null as unknown as SafeParseResult<H>\n\n    for (const plugin of this.#getSortedPlugins()) {\n      if (skipped?.has(plugin)) {\n        continue\n      }\n\n      parseResult = {\n        result: this.#executeSync<H>({\n          strategy: 'hookFirst',\n          hookName,\n          parameters,\n          plugin,\n        }),\n        plugin,\n      } as SafeParseResult<H>\n\n      if (parseResult?.result != null) {\n        break\n      }\n    }\n    return parseResult\n  }\n\n  /**\n   * Run all plugins in parallel(order will be based on `this.plugin` and if `pre` or `post` is set).\n   */\n  async hookParallel<H extends PluginLifecycleHooks, TOuput = void>({\n    hookName,\n    parameters,\n  }: {\n    hookName: H\n    parameters?: Parameters<RequiredPluginLifecycle[H]> | undefined\n  }): Promise<Awaited<TOuput>[]> {\n    const promises = this.#getSortedPlugins().map((plugin) => {\n      return () =>\n        this.#execute({\n          strategy: 'hookParallel',\n          hookName,\n          parameters,\n          plugin,\n        }) as Promise<TOuput>\n    })\n\n    const results = await this.#promiseManager.run('parallel', promises)\n\n    results.forEach((result, index) => {\n      if (isPromiseRejectedResult<Error>(result)) {\n        const plugin = this.#getSortedPlugins()[index]\n\n        this.#catcher<H>(result.reason, plugin, hookName)\n      }\n    })\n\n    return results.filter((result) => result.status === 'fulfilled').map((result) => (result as PromiseFulfilledResult<Awaited<TOuput>>).value)\n  }\n\n  /**\n   * Chain all plugins, `reduce` can be passed through to handle every returned value. The return value of the first plugin will be used as the first parameter for the plugin after that.\n   */\n  hookReduceArg0<H extends PluginLifecycleHooks>({\n    hookName,\n    parameters,\n    reduce,\n  }: {\n    hookName: H\n    parameters: PluginParameter<H>\n    reduce: (reduction: Argument0<H>, result: ReturnType<ParseResult<H>>, plugin: Plugin) => PossiblePromise<Argument0<H> | null>\n  }): Promise<Argument0<H>> {\n    const [argument0, ...rest] = parameters\n\n    let promise: Promise<Argument0<H>> = Promise.resolve(argument0)\n    for (const plugin of this.#getSortedPlugins()) {\n      promise = promise\n        .then((arg0) => {\n          const value = this.#execute({\n            strategy: 'hookReduceArg0',\n            hookName,\n            parameters: [arg0, ...rest] as PluginParameter<H>,\n            plugin,\n          })\n          return value\n        })\n        .then((result) => reduce.call(this.#core.api, argument0, result as ReturnType<ParseResult<H>>, plugin)) as Promise<Argument0<H>>\n    }\n\n    return promise\n  }\n\n  /**\n   * Chains plugins\n   */\n  async hookSeq<H extends PluginLifecycleHooks>({ hookName, parameters }: { hookName: H; parameters?: PluginParameter<H> }): Promise<void> {\n    const promises = this.#getSortedPlugins().map((plugin) => {\n      return () =>\n        this.#execute({\n          strategy: 'hookSeq',\n          hookName,\n          parameters,\n          plugin,\n        })\n    })\n\n    return this.#promiseManager.run('seq', promises)\n  }\n\n  #getSortedPlugins(hookName?: keyof PluginLifecycle): Plugin[] {\n    const plugins = [...this.plugins].filter((plugin) => plugin.name !== 'core')\n\n    if (hookName) {\n      if (this.logger.logLevel === LogLevel.info) {\n        const containsHookName = plugins.some((item) => item[hookName])\n        if (!containsHookName) {\n          this.logger.emit('warning', `No hook ${hookName} found`)\n        }\n      }\n\n      return plugins.filter((item) => item[hookName])\n    }\n    // TODO add test case for sorting with pre/post\n\n    return plugins\n      .map((plugin) => {\n        if (plugin.pre) {\n          const isValid = plugin.pre.every((pluginName) => plugins.find((pluginToFind) => pluginToFind.name === pluginName))\n\n          if (!isValid) {\n            throw new ValidationPluginError(`This plugin has a pre set that is not valid(${JSON.stringify(plugin.pre, undefined, 2)})`)\n          }\n        }\n\n        return plugin\n      })\n      .sort((a, b) => {\n        if (b.pre?.includes(a.name)) {\n          return 1\n        }\n        if (b.post?.includes(a.name)) {\n          return -1\n        }\n        return 0\n      })\n  }\n\n  getPluginsByKey(hookName: keyof PluginLifecycle, pluginKey: Plugin['key']): Plugin[] {\n    const plugins = [...this.plugins]\n    const [searchPluginName, searchIdentifier] = pluginKey\n\n    const pluginByPluginName = plugins\n      .filter((plugin) => plugin[hookName])\n      .filter((item) => {\n        const [name, identifier] = item.key\n\n        const identifierCheck = identifier?.toString() === searchIdentifier?.toString()\n        const nameCheck = name === searchPluginName\n\n        if (searchIdentifier) {\n          return identifierCheck && nameCheck\n        }\n\n        return nameCheck\n      })\n\n    if (!pluginByPluginName?.length) {\n      // fallback on the core plugin when there is no match\n\n      const corePlugin = plugins.find((plugin) => plugin.name === 'core' && plugin[hookName])\n\n      if (corePlugin) {\n        this.logger.emit('debug', [`No hook '${hookName}' for pluginKey '${JSON.stringify(pluginKey)}' found, falling back on the '@kubb/core' plugin`])\n      } else {\n        this.logger.emit('debug', [`No hook '${hookName}' for pluginKey '${JSON.stringify(pluginKey)}' found, no fallback found in the '@kubb/core' plugin`])\n      }\n      return corePlugin ? [corePlugin] : []\n    }\n\n    return pluginByPluginName\n  }\n\n  #addExecutedToCallStack(executer: Executer | undefined) {\n    if (executer) {\n      this.events.emit('executed', executer)\n      this.executed.push(executer)\n    }\n  }\n\n  /**\n   * Run an async plugin hook and return the result.\n   * @param hookName Name of the plugin hook. Must be either in `PluginHooks` or `OutputPluginValueHooks`.\n   * @param args Arguments passed to the plugin hook.\n   * @param plugin The actual pluginObject to run.\n   */\n  // Implementation signature\n  #execute<H extends PluginLifecycleHooks>({\n    strategy,\n    hookName,\n    parameters,\n    plugin,\n  }: {\n    strategy: Strategy\n    hookName: H\n    parameters: unknown[] | undefined\n    plugin: PluginWithLifeCycle\n  }): Promise<ReturnType<ParseResult<H>> | null> | null {\n    const hook = plugin[hookName]\n    let output: unknown\n\n    if (!hook) {\n      return null\n    }\n\n    this.events.emit('execute', { strategy, hookName, parameters, plugin })\n\n    const task = Promise.resolve()\n      .then(() => {\n        if (typeof hook === 'function') {\n          const possiblePromiseResult = (hook as Function).apply({ ...this.#core.api, plugin }, parameters) as Promise<ReturnType<ParseResult<H>>>\n\n          if (isPromise(possiblePromiseResult)) {\n            return Promise.resolve(possiblePromiseResult)\n          }\n          return possiblePromiseResult\n        }\n\n        return hook\n      })\n      .then((result) => {\n        output = result\n\n        this.#addExecutedToCallStack({\n          parameters,\n          output,\n          strategy,\n          hookName,\n          plugin,\n        })\n\n        return result\n      })\n      .catch((e: Error) => {\n        this.#catcher<H>(e, plugin, hookName)\n\n        return null\n      })\n\n    return task\n  }\n\n  /**\n   * Run a sync plugin hook and return the result.\n   * @param hookName Name of the plugin hook. Must be in `PluginHooks`.\n   * @param args Arguments passed to the plugin hook.\n   * @param plugin The acutal plugin\n   * @param replaceContext When passed, the plugin context can be overridden.\n   */\n  #executeSync<H extends PluginLifecycleHooks>({\n    strategy,\n    hookName,\n    parameters,\n    plugin,\n  }: {\n    strategy: Strategy\n    hookName: H\n    parameters: PluginParameter<H>\n    plugin: PluginWithLifeCycle\n  }): ReturnType<ParseResult<H>> | null {\n    const hook = plugin[hookName]\n    let output: unknown\n\n    if (!hook) {\n      return null\n    }\n\n    this.events.emit('execute', { strategy, hookName, parameters, plugin })\n\n    try {\n      if (typeof hook === 'function') {\n        const fn = (hook as Function).apply({ ...this.#core.api, plugin }, parameters) as ReturnType<ParseResult<H>>\n\n        output = fn\n        return fn\n      }\n\n      output = hook\n\n      this.#addExecutedToCallStack({\n        parameters,\n        output,\n        strategy,\n        hookName,\n        plugin,\n      })\n\n      return hook\n    } catch (e) {\n      this.#catcher<H>(e as Error, plugin, hookName)\n\n      return null\n    }\n  }\n\n  #catcher<H extends PluginLifecycleHooks>(cause: Error, plugin?: Plugin, hookName?: H) {\n    const text = `${cause.message} (plugin: ${plugin?.name || 'unknown'}, hook: ${hookName || 'unknown'})`\n\n    this.logger.emit('error', text, cause)\n    this.events.emit('error', cause)\n  }\n\n  #parse<TPlugin extends UserPluginWithLifeCycle>(\n    plugin: TPlugin,\n    pluginManager: PluginManager,\n    context: PluginCore['api'] | undefined,\n  ): Plugin<GetPluginFactoryOptions<TPlugin>> {\n    const usedPluginNames = pluginManager.#usedPluginNames\n\n    setUniqueName(plugin.name, usedPluginNames)\n\n    const key = [plugin.name, usedPluginNames[plugin.name]].filter(Boolean) as [typeof plugin.name, string]\n\n    // default transform\n    if (!plugin.transform) {\n      plugin.transform = function transform(_path, code) {\n        return code\n      }\n    }\n\n    if (plugin.api && typeof plugin.api === 'function') {\n      const api = (plugin.api as Function).call(context) as typeof plugin.api\n\n      return {\n        ...plugin,\n        key,\n        api,\n      } as unknown as Plugin<GetPluginFactoryOptions<TPlugin>>\n    }\n\n    return {\n      ...plugin,\n      key,\n    } as unknown as Plugin<GetPluginFactoryOptions<TPlugin>>\n  }\n\n  static getDependedPlugins<\n    T1 extends PluginFactoryOptions,\n    T2 extends PluginFactoryOptions = never,\n    T3 extends PluginFactoryOptions = never,\n    TOutput = T3 extends never ? (T2 extends never ? [T1: Plugin<T1>] : [T1: Plugin<T1>, T2: Plugin<T2>]) : [T1: Plugin<T1>, T2: Plugin<T2>, T3: Plugin<T3>],\n  >(plugins: Array<Plugin>, dependedPluginNames: string | string[]): TOutput {\n    let pluginNames: string[] = []\n    if (typeof dependedPluginNames === 'string') {\n      pluginNames = [dependedPluginNames]\n    } else {\n      pluginNames = dependedPluginNames\n    }\n\n    return pluginNames.map((pluginName) => {\n      const plugin = plugins.find((plugin) => plugin.name === pluginName)\n      if (!plugin) {\n        throw new ValidationPluginError(`This plugin depends on the ${pluginName} plugin.`)\n      }\n      return plugin\n    }) as TOutput\n  }\n\n  static get hooks() {\n    return ['buildStart', 'resolvePath', 'resolveName', 'load', 'transform', 'writeFile', 'buildEnd'] as const\n  }\n}\n","import { hookFirst, hookParallel, hookSeq } from './utils/executeStrategies.ts'\n\nimport type { PossiblePromise } from '@kubb/types'\nimport type { Strategy, StrategySwitch } from './utils/executeStrategies.ts'\n\ntype PromiseFunc<T = unknown, T2 = never> = () => T2 extends never ? Promise<T> : Promise<T> | T2\n\ntype Options<TState = any> = {\n  nullCheck?: (state: TState) => boolean\n}\n\nexport class PromiseManager<TState = any> {\n  #options: Options<TState> = {}\n\n  constructor(options: Options<TState> = {}) {\n    this.#options = options\n\n    return this\n  }\n\n  run<TInput extends Array<PromiseFunc<TValue, null>>, TValue, TStrategy extends Strategy, TOutput = StrategySwitch<TStrategy, TInput, TValue>>(\n    strategy: TStrategy,\n    promises: TInput,\n  ): TOutput {\n    if (strategy === 'seq') {\n      return hookSeq<TInput, TValue, TOutput>(promises)\n    }\n\n    if (strategy === 'first') {\n      return hookFirst<TInput, TValue, TOutput>(promises, this.#options.nullCheck)\n    }\n\n    if (strategy === 'parallel') {\n      return hookParallel<TInput, TValue, TOutput>(promises)\n    }\n\n    throw new Error(`${strategy} not implemented`)\n  }\n}\n\nexport function isPromise<T>(result: PossiblePromise<T>): result is Promise<T> {\n  return !!result && typeof (result as Promise<unknown>)?.then === 'function'\n}\n\nexport function isPromiseFulfilledResult<T = unknown>(result: PromiseSettledResult<unknown>): result is PromiseFulfilledResult<T> {\n  return result.status === 'fulfilled'\n}\n\nexport function isPromiseRejectedResult<T>(result: PromiseSettledResult<unknown>): result is Omit<PromiseRejectedResult, 'reason'> & { reason: T } {\n  return result.status === 'rejected'\n}\n","type PromiseFunc<T = unknown, T2 = never> = (state?: T) => T2 extends never ? Promise<T> : Promise<T> | T2\n\nexport type ValueOfPromiseFuncArray<TInput extends Array<unknown>> = TInput extends Array<PromiseFunc<infer X, infer Y>> ? X | Y : never\n\nexport function noReturn(): void {}\n\ntype SeqOutput<TInput extends Array<PromiseFunc<TValue, null>>, TValue> = Array<Awaited<ValueOfPromiseFuncArray<TInput>>>\n\n/**\n * Chains promises\n */\nexport function hookSeq<TInput extends Array<PromiseFunc<TValue, null>>, TValue, TOutput = SeqOutput<TInput, TValue>>(promises: TInput): TOutput {\n  return promises.filter(Boolean).reduce(\n    (promise, func) => {\n      if (typeof func !== 'function') {\n        throw new Error('HookSeq needs a function that returns a promise `() => Promise<unknown>`')\n      }\n\n      return promise.then((state) => {\n        const calledFunc = func(state as TValue)\n\n        if (calledFunc) {\n          return calledFunc.then(Array.prototype.concat.bind(state))\n        }\n      })\n    },\n    Promise.resolve([] as unknown),\n  ) as TOutput\n}\n\ntype HookFirstOutput<TInput extends Array<PromiseFunc<TValue, null>>, TValue = unknown> = ValueOfPromiseFuncArray<TInput>\n\n/**\n * Chains promises, first non-null result stops and returns\n */\nexport function hookFirst<TInput extends Array<PromiseFunc<TValue, null>>, TValue = unknown, TOutput = HookFirstOutput<TInput, TValue>>(\n  promises: TInput,\n  nullCheck = (state: any) => state !== null,\n): TOutput {\n  let promise: Promise<unknown> = Promise.resolve(null) as Promise<unknown>\n\n  for (const func of promises.filter(Boolean)) {\n    promise = promise.then((state) => {\n      if (nullCheck(state)) {\n        return state\n      }\n\n      const calledFunc = func(state as TValue)\n\n      return calledFunc\n    })\n  }\n\n  return promise as TOutput\n}\n\ntype HookParallelOutput<TInput extends Array<PromiseFunc<TValue, null>>, TValue> = Promise<PromiseSettledResult<Awaited<ValueOfPromiseFuncArray<TInput>>>[]>\n\n/**\n * Run promises in parallel with allSettled\n */\nexport function hookParallel<TInput extends Array<PromiseFunc<TValue, null>>, TValue = unknown, TOutput = HookParallelOutput<TInput, TValue>>(\n  promises: TInput,\n): TOutput {\n  return Promise.allSettled(promises.filter(Boolean).map((promise) => promise())) as TOutput\n}\n\nexport type Strategy = 'seq' | 'first' | 'parallel'\n\nexport type StrategySwitch<TStrategy extends Strategy, TInput extends Array<PromiseFunc<TValue, null>>, TValue> = TStrategy extends 'first'\n  ? HookFirstOutput<TInput, TValue>\n  : TStrategy extends 'seq'\n    ? SeqOutput<TInput, TValue>\n    : TStrategy extends 'parallel'\n      ? HookParallelOutput<TInput, TValue>\n      : never\n\n// tests\n\ntype test = ValueOfPromiseFuncArray<Array<PromiseFunc<number, null>>>\n//    ^?\n","/**\n * Behaves as an Error to log a warning in the console(still stops the execution)\n */\nexport class Warning extends Error {\n  constructor(message?: string, options?: { cause: Error }) {\n    super(message, { cause: options?.cause })\n\n    this.name = 'Warning'\n  }\n}\n\nexport class ValidationPluginError extends Error {}\n","import path from 'node:path'\n\nimport { createPluginCache } from './utils/cache.ts'\n\nimport type { FileManager } from './FileManager.ts'\nimport type { PluginManager } from './PluginManager.ts'\nimport type { Plugin, PluginContext, PluginFactoryOptions, UserPluginWithLifeCycle } from './types.ts'\n\ntype PluginFactory<T extends PluginFactoryOptions = PluginFactoryOptions> = (options: T['options']) => UserPluginWithLifeCycle<T>\n\ntype OptionalPluginFactory<T extends PluginFactoryOptions = PluginFactoryOptions> = (options?: T['options']) => UserPluginWithLifeCycle<T>\n\nexport function createPlugin<T extends PluginFactoryOptions = PluginFactoryOptions>(factory: PluginFactory<T>): OptionalPluginFactory<T> {\n  return (options = {}) => {\n    return factory(options)\n  }\n}\n\ntype Options = {\n  config: PluginContext['config']\n  fileManager: FileManager\n  pluginManager: PluginManager\n  resolvePath: PluginContext['resolvePath']\n  resolveName: PluginContext['resolveName']\n  logger: PluginContext['logger']\n  getPlugins: () => Array<Plugin>\n  plugin?: PluginContext['plugin']\n}\n\n// not publicly exported\nexport type PluginCore = PluginFactoryOptions<'core', Options, Options, PluginContext, never>\n\nexport const pluginCore = createPlugin<PluginCore>((options) => {\n  const { fileManager, pluginManager, resolvePath, resolveName, logger } = options\n\n  return {\n    name: 'core',\n    options,\n    key: ['core'],\n    api() {\n      return {\n        get config() {\n          return options.config\n        },\n        get plugins() {\n          return options.getPlugins()\n        },\n        get plugin() {\n          // see pluginManger.#execute where we override with `.call` the this with the correct plugin\n          return options.plugin as NonNullable<Options['plugin']>\n        },\n        logger,\n        fileManager,\n        pluginManager,\n        async addFile(...files) {\n          const resolvedFiles = await fileManager.add(...files)\n\n          if (!Array.isArray(resolvedFiles)) {\n            return [resolvedFiles]\n          }\n\n          return resolvedFiles\n        },\n        resolvePath,\n        resolveName,\n        cache: createPluginCache(),\n      }\n    },\n    resolvePath(baseName) {\n      const root = path.resolve(this.config.root, this.config.output.path)\n\n      return path.resolve(root, baseName)\n    },\n    resolveName(name) {\n      return name\n    },\n  }\n})\n","import type { PluginCache } from '../types.ts'\n\nexport interface Cache<TStore extends object = object> {\n  delete(id: keyof TStore): boolean\n  get(id: keyof TStore): TStore[keyof TStore] | null\n  has(id: keyof TStore): boolean\n  set(id: keyof TStore, value: unknown): void\n}\n\nexport function createPluginCache<TStore extends PluginCache>(Store: TStore = Object.create(null) as TStore): Cache<TStore> {\n  return {\n    set(id, value): void {\n      Store[id] = [0, value] as TStore[keyof TStore]\n    },\n    get(id): TStore[keyof TStore] | null {\n      const item = Store[id]\n      if (!item) {\n        return null\n      }\n      item[0] = 0\n      return item[1] as TStore[keyof TStore]\n    },\n    has(id): boolean {\n      const item = Store[id]\n      if (!item) {\n        return false\n      }\n      item[0] = 0\n      return true\n    },\n    delete(id: keyof TStore): boolean {\n      return delete Store[id]\n    },\n  }\n}\n","import type { PossiblePromise } from '@kubb/types'\nimport type { Config, InputPath, UserConfig } from './types.ts'\n\ntype Args = {\n  /**\n   * Path to `kubb.config.js`\n   */\n  config?: string\n  /**\n   * Watch changes on input\n   */\n  watch?: boolean\n\n  /**\n   * Log level to report when using the CLI\n   *\n   * `silent` will hide all information that is not relevant\n   *\n   * `info` will show all information possible(not related to the PluginManager)\n   *\n   * `debug` will show all information possible(related to the PluginManager), handy for seeing logs\n   * @default `silent`\n   */\n  logLevel?: string\n  /**\n   * Run Kubb with Bun\n   */\n  bun?: boolean\n}\n\n/**\n * Type helper to make it easier to use kubb.config.js\n * accepts a direct {@link Config} object, or a function that returns it.\n * The function receives a {@link ConfigEnv} object that exposes two properties:\n */\nexport function defineConfig(\n  options:\n    | PossiblePromise<UserConfig | Array<UserConfig>>\n    | ((\n        /** The options derived from the CLI flags */\n        args: Args,\n      ) => PossiblePromise<UserConfig | Array<UserConfig>>),\n): typeof options {\n  return options\n}\n\nexport function isInputPath(result: Config | undefined): result is Config<InputPath> {\n  return !!result && 'path' in (result as any)\n}\n","/**\n * Abstract class that contains the building blocks for plugins to create their own Generator\n * @link idea based on https://github.com/colinhacks/zod/blob/master/src/types.ts#L137\n */\nexport abstract class Generator<TOptions = unknown, TContext = unknown> {\n  #options: TOptions = {} as TOptions\n  #context: TContext = {} as TContext\n\n  constructor(options?: TOptions, context?: TContext) {\n    if (context) {\n      this.#context = context\n    }\n\n    if (options) {\n      this.#options = options\n    }\n\n    return this\n  }\n\n  get options(): TOptions {\n    return this.#options\n  }\n\n  get context(): TContext {\n    return this.#context\n  }\n\n  set options(options: TOptions) {\n    this.#options = { ...this.#options, ...options }\n  }\n\n  abstract build(...params: unknown[]): unknown\n}\n","import mod from 'node:module'\nimport os from 'node:os'\nimport { pathToFileURL } from 'node:url'\n\nimport { findUp, findUpSync } from 'find-up'\nimport { coerce, satisfies } from 'semver'\n\nimport { read, readSync } from '@kubb/fs'\n\ntype PackageJSON = {\n  dependencies?: Record<string, string>\n  devDependencies?: Record<string, string>\n}\n\ntype DependencyName = string\n\ntype DependencyVersion = string\n\nexport class PackageManager {\n  static #cache: Record<DependencyName, DependencyVersion> = {}\n\n  #cwd?: string\n  #SLASHES = new Set(['/', '\\\\'])\n  constructor(workspace?: string) {\n    if (workspace) {\n      this.#cwd = workspace\n    }\n\n    return this\n  }\n\n  set workspace(workspace: string) {\n    this.#cwd = workspace\n  }\n\n  get workspace(): string | undefined {\n    return this.#cwd\n  }\n\n  normalizeDirectory(directory: string): string {\n    if (!this.#SLASHES.has(directory[directory.length - 1]!)) {\n      return `${directory}/`\n    }\n\n    return directory\n  }\n\n  getLocation(path: string): string {\n    let location = path\n\n    if (this.#cwd) {\n      const require = mod.createRequire(this.normalizeDirectory(this.#cwd))\n      location = require.resolve(path)\n    }\n\n    return location\n  }\n\n  async import(path: string): Promise<any | undefined> {\n    try {\n      let location = this.getLocation(path)\n\n      if (os.platform() === 'win32') {\n        location = pathToFileURL(location).href\n      }\n\n      const module = await import(location)\n\n      return module?.default ?? module\n    } catch (e) {\n      console.log(e)\n      return undefined\n    }\n  }\n\n  async getPackageJSON(): Promise<PackageJSON | undefined> {\n    const pkgPath = await findUp(['package.json'], {\n      cwd: this.#cwd,\n    })\n    if (!pkgPath) {\n      return undefined\n    }\n\n    const json = await read(pkgPath)\n\n    return JSON.parse(json) as PackageJSON\n  }\n\n  getPackageJSONSync(): PackageJSON | undefined {\n    const pkgPath = findUpSync(['package.json'], {\n      cwd: this.#cwd,\n    })\n    if (!pkgPath) {\n      return undefined\n    }\n\n    const json = readSync(pkgPath)\n\n    return JSON.parse(json) as PackageJSON\n  }\n\n  static setVersion(dependency: DependencyName, version: DependencyVersion): void {\n    PackageManager.#cache[dependency] = version\n  }\n\n  #match(packageJSON: PackageJSON, dependency: DependencyName | RegExp): string | undefined {\n    const dependencies = {\n      ...(packageJSON['dependencies'] || {}),\n      ...(packageJSON['devDependencies'] || {}),\n    }\n\n    if (typeof dependency === 'string' && dependencies[dependency]) {\n      return dependencies[dependency]\n    }\n\n    const matchedDependency = Object.keys(dependencies).find((dep) => dep.match(dependency))\n\n    return matchedDependency ? dependencies[matchedDependency] : undefined\n  }\n\n  async getVersion(dependency: DependencyName | RegExp): Promise<DependencyVersion | undefined> {\n    if (typeof dependency === 'string' && PackageManager.#cache[dependency]) {\n      return PackageManager.#cache[dependency]\n    }\n\n    const packageJSON = await this.getPackageJSON()\n\n    if (!packageJSON) {\n      return undefined\n    }\n\n    return this.#match(packageJSON, dependency)\n  }\n\n  getVersionSync(dependency: DependencyName | RegExp): DependencyVersion | undefined {\n    if (typeof dependency === 'string' && PackageManager.#cache[dependency]) {\n      return PackageManager.#cache[dependency]\n    }\n\n    const packageJSON = this.getPackageJSONSync()\n\n    if (!packageJSON) {\n      return undefined\n    }\n\n    return this.#match(packageJSON, dependency)\n  }\n\n  async isValid(dependency: DependencyName | RegExp, version: DependencyVersion): Promise<boolean> {\n    const packageVersion = await this.getVersion(dependency)\n\n    if (!packageVersion) {\n      return false\n    }\n\n    if (packageVersion === version) {\n      return true\n    }\n\n    const semVer = coerce(packageVersion)\n\n    if (!semVer) {\n      throw new Error(`${packageVersion} is not valid`)\n    }\n\n    return satisfies(semVer, version)\n  }\n  isValidSync(dependency: DependencyName | RegExp, version: DependencyVersion): boolean {\n    const packageVersion = this.getVersionSync(dependency)\n\n    if (!packageVersion) {\n      return false\n    }\n    const semVer = coerce(packageVersion)\n\n    if (!semVer) {\n      throw new Error(`${packageVersion} is not valid`)\n    }\n\n    return satisfies(semVer, version)\n  }\n}\n","import path from 'node:path';\nimport {locatePath, locatePathSync} from 'locate-path';\nimport {toPath} from 'unicorn-magic';\n\nexport const findUpStop = Symbol('findUpStop');\n\nexport async function findUpMultiple(name, options = {}) {\n\tlet directory = path.resolve(toPath(options.cwd) ?? '');\n\tconst {root} = path.parse(directory);\n\tconst stopAt = path.resolve(directory, toPath(options.stopAt ?? root));\n\tconst limit = options.limit ?? Number.POSITIVE_INFINITY;\n\tconst paths = [name].flat();\n\n\tconst runMatcher = async locateOptions => {\n\t\tif (typeof name !== 'function') {\n\t\t\treturn locatePath(paths, locateOptions);\n\t\t}\n\n\t\tconst foundPath = await name(locateOptions.cwd);\n\t\tif (typeof foundPath === 'string') {\n\t\t\treturn locatePath([foundPath], locateOptions);\n\t\t}\n\n\t\treturn foundPath;\n\t};\n\n\tconst matches = [];\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tconst foundPath = await runMatcher({...options, cwd: directory});\n\n\t\tif (foundPath === findUpStop) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (foundPath) {\n\t\t\tmatches.push(path.resolve(directory, foundPath));\n\t\t}\n\n\t\tif (directory === stopAt || matches.length >= limit) {\n\t\t\tbreak;\n\t\t}\n\n\t\tdirectory = path.dirname(directory);\n\t}\n\n\treturn matches;\n}\n\nexport function findUpMultipleSync(name, options = {}) {\n\tlet directory = path.resolve(toPath(options.cwd) ?? '');\n\tconst {root} = path.parse(directory);\n\tconst stopAt = path.resolve(directory, toPath(options.stopAt) ?? root);\n\tconst limit = options.limit ?? Number.POSITIVE_INFINITY;\n\tconst paths = [name].flat();\n\n\tconst runMatcher = locateOptions => {\n\t\tif (typeof name !== 'function') {\n\t\t\treturn locatePathSync(paths, locateOptions);\n\t\t}\n\n\t\tconst foundPath = name(locateOptions.cwd);\n\t\tif (typeof foundPath === 'string') {\n\t\t\treturn locatePathSync([foundPath], locateOptions);\n\t\t}\n\n\t\treturn foundPath;\n\t};\n\n\tconst matches = [];\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst foundPath = runMatcher({...options, cwd: directory});\n\n\t\tif (foundPath === findUpStop) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (foundPath) {\n\t\t\tmatches.push(path.resolve(directory, foundPath));\n\t\t}\n\n\t\tif (directory === stopAt || matches.length >= limit) {\n\t\t\tbreak;\n\t\t}\n\n\t\tdirectory = path.dirname(directory);\n\t}\n\n\treturn matches;\n}\n\nexport async function findUp(name, options = {}) {\n\tconst matches = await findUpMultiple(name, {...options, limit: 1});\n\treturn matches[0];\n}\n\nexport function findUpSync(name, options = {}) {\n\tconst matches = findUpMultipleSync(name, {...options, limit: 1});\n\treturn matches[0];\n}\n\nexport {\n\tpathExists,\n\tpathExistsSync,\n} from 'path-exists';\n","import process from 'node:process';\nimport path from 'node:path';\nimport fs, {promises as fsPromises} from 'node:fs';\nimport {fileURLToPath} from 'node:url';\nimport pLocate from 'p-locate';\n\nconst typeMappings = {\n\tdirectory: 'isDirectory',\n\tfile: 'isFile',\n};\n\nfunction checkType(type) {\n\tif (Object.hasOwnProperty.call(typeMappings, type)) {\n\t\treturn;\n\t}\n\n\tthrow new Error(`Invalid type specified: ${type}`);\n}\n\nconst matchType = (type, stat) => stat[typeMappings[type]]();\n\nconst toPath = urlOrPath => urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath;\n\nexport async function locatePath(\n\tpaths,\n\t{\n\t\tcwd = process.cwd(),\n\t\ttype = 'file',\n\t\tallowSymlinks = true,\n\t\tconcurrency,\n\t\tpreserveOrder,\n\t} = {},\n) {\n\tcheckType(type);\n\tcwd = toPath(cwd);\n\n\tconst statFunction = allowSymlinks ? fsPromises.stat : fsPromises.lstat;\n\n\treturn pLocate(paths, async path_ => {\n\t\ttry {\n\t\t\tconst stat = await statFunction(path.resolve(cwd, path_));\n\t\t\treturn matchType(type, stat);\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t}, {concurrency, preserveOrder});\n}\n\nexport function locatePathSync(\n\tpaths,\n\t{\n\t\tcwd = process.cwd(),\n\t\ttype = 'file',\n\t\tallowSymlinks = true,\n\t} = {},\n) {\n\tcheckType(type);\n\tcwd = toPath(cwd);\n\n\tconst statFunction = allowSymlinks ? fs.statSync : fs.lstatSync;\n\n\tfor (const path_ of paths) {\n\t\ttry {\n\t\t\tconst stat = statFunction(path.resolve(cwd, path_), {\n\t\t\t\tthrowIfNoEntry: false,\n\t\t\t});\n\n\t\t\tif (!stat) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (matchType(type, stat)) {\n\t\t\t\treturn path_;\n\t\t\t}\n\t\t} catch {}\n\t}\n}\n","import pLimit from 'p-limit';\n\nclass EndError extends Error {\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.value = value;\n\t}\n}\n\n// The input can also be a promise, so we await it.\nconst testElement = async (element, tester) => tester(await element);\n\n// The input can also be a promise, so we `Promise.all()` them both.\nconst finder = async element => {\n\tconst values = await Promise.all(element);\n\tif (values[1] === true) {\n\t\tthrow new EndError(values[0]);\n\t}\n\n\treturn false;\n};\n\nexport default async function pLocate(\n\titerable,\n\ttester,\n\t{\n\t\tconcurrency = Number.POSITIVE_INFINITY,\n\t\tpreserveOrder = true,\n\t} = {},\n) {\n\tconst limit = pLimit(concurrency);\n\n\t// Start all the promises concurrently with optional limit.\n\tconst items = [...iterable].map(element => [element, limit(testElement, element, tester)]);\n\n\t// Check the promises either serially or concurrently.\n\tconst checkLimit = pLimit(preserveOrder ? 1 : Number.POSITIVE_INFINITY);\n\n\ttry {\n\t\tawait Promise.all(items.map(element => checkLimit(finder, element)));\n\t} catch (error) {\n\t\tif (error instanceof EndError) {\n\t\t\treturn error.value;\n\t\t}\n\n\t\tthrow error;\n\t}\n}\n","import Queue from 'yocto-queue';\n\nexport default function pLimit(concurrency) {\n\tif (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n\n\tconst queue = new Queue();\n\tlet activeCount = 0;\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tif (queue.size > 0) {\n\t\t\tqueue.dequeue()();\n\t\t}\n\t};\n\n\tconst run = async (fn, resolve, args) => {\n\t\tactiveCount++;\n\n\t\tconst result = (async () => fn(...args))();\n\n\t\tresolve(result);\n\n\t\ttry {\n\t\t\tawait result;\n\t\t} catch {}\n\n\t\tnext();\n\t};\n\n\tconst enqueue = (fn, resolve, args) => {\n\t\tqueue.enqueue(run.bind(undefined, fn, resolve, args));\n\n\t\t(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// when the run function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve();\n\n\t\t\tif (activeCount < concurrency && queue.size > 0) {\n\t\t\t\tqueue.dequeue()();\n\t\t\t}\n\t\t})();\n\t};\n\n\tconst generator = (fn, ...args) => new Promise(resolve => {\n\t\tenqueue(fn, resolve, args);\n\t});\n\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount,\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.size,\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue: () => {\n\t\t\t\tqueue.clear();\n\t\t\t},\n\t\t},\n\t});\n\n\treturn generator;\n}\n","/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\n\nclass Node {\n\tvalue;\n\tnext;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n}\n\nexport default class Queue {\n\t#head;\n\t#tail;\n\t#size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this.#head) {\n\t\t\tthis.#tail.next = node;\n\t\t\tthis.#tail = node;\n\t\t} else {\n\t\t\tthis.#head = node;\n\t\t\tthis.#tail = node;\n\t\t}\n\n\t\tthis.#size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this.#head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#head = this.#head.next;\n\t\tthis.#size--;\n\t\treturn current.value;\n\t}\n\n\tclear() {\n\t\tthis.#head = undefined;\n\t\tthis.#tail = undefined;\n\t\tthis.#size = 0;\n\t}\n\n\tget size() {\n\t\treturn this.#size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this.#head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n}\n","import {fileURLToPath} from 'node:url';\n\nexport function toPath(urlOrPath) {\n\treturn urlOrPath instanceof URL ? fileURLToPath(urlOrPath) : urlOrPath;\n}\n\nexport * from './default.js';\n","import fs, {promises as fsPromises} from 'node:fs';\n\nexport async function pathExists(path) {\n\ttry {\n\t\tawait fsPromises.access(path);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport function pathExistsSync(path) {\n\ttry {\n\t\tfs.accessSync(path);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n}\n"]}