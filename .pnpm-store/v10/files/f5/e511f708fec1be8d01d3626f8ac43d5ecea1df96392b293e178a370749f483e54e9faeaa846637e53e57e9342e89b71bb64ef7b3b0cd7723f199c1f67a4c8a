{"version":3,"sources":["/home/runner/work/kubb/kubb/packages/fs/dist/types.cjs","../src/types.ts"],"names":[],"mappings":"AAAA;AACE;AACF,wDAA6B;AAC7B;AACA;ACJA,8CAAA,CAAA","file":"/home/runner/work/kubb/kubb/packages/fs/dist/types.cjs","sourcesContent":[null,"type BasePath<T extends string = string> = `${T}/`\n\nexport type Import = {\n  /**\n   * Import name to be used\n   * @example [\"useState\"]\n   * @example \"React\"\n   */\n  name:\n    | string\n    | Array<\n        | string\n        | {\n            propertyName: string\n            name?: string\n          }\n      >\n  /**\n   * Path for the import\n   * @example '@kubb/core'\n   */\n  path: string\n  extName?: Extname\n  /**\n   * Add `type` prefix to the import, this will result in: `import type { Type } from './path'`.\n   */\n  isTypeOnly?: boolean\n  /**\n   * Add `* as` prefix to the import, this will result in: `import * as path from './path'`.\n   */\n\n  isNameSpace?: boolean\n  /**\n   * When root is set it will get the path with relative getRelativePath(root, path).\n   */\n  root?: string\n}\n\nexport type Export = {\n  /**\n   * Export name to be used.\n   * @example [\"useState\"]\n   * @example \"React\"\n   */\n  name?: string | Array<string>\n  /**\n   * Path for the import.\n   * @example '@kubb/core'\n   */\n  path: string\n  extName?: Extname\n  /**\n   * Add `type` prefix to the export, this will result in: `export type { Type } from './path'`.\n   */\n  isTypeOnly?: boolean\n  /**\n   * Make it possible to override the name, this will result in: `export * as aliasName from './path'`.\n   */\n  asAlias?: boolean\n}\n\nexport declare const dataTagSymbol: unique symbol\nexport type DataTag<Type, Value> = Type & {\n  [dataTagSymbol]: Value\n}\n\nexport type UUID = string\nexport type Source = string\n\nexport type Extname = '.ts' | '.js' | '.tsx' | '.json' | `.${string}`\n\nexport type Mode = 'single' | 'split'\n\n/**\n * Name to be used to dynamicly create the baseName(based on input.path)\n * Based on UNIX basename\n * @link https://nodejs.org/api/path.html#pathbasenamepath-suffix\n */\nexport type BaseName = `${string}${Extname}`\n\n/**\n * Path will be full qualified path to a specified file\n */\nexport type Path = string\n\nexport type AdvancedPath<T extends BaseName = BaseName> = `${BasePath}${T}`\n\nexport type OptionalPath = Path | undefined | null\n\nexport type File<TMeta extends object = object, TBaseName extends BaseName = BaseName> = {\n  /**\n   * Unique identifier to reuse later\n   * @default crypto.randomUUID()\n   */\n  id?: string\n  /**\n   * Name to be used to create the path\n   * Based on UNIX basename, `${name}.extName`\n   * @link https://nodejs.org/api/path.html#pathbasenamepath-suffix\n   */\n  baseName: TBaseName\n  /**\n   * Path will be full qualified path to a specified file\n   */\n  path: AdvancedPath<TBaseName> | Path\n  source: Source\n  imports?: Import[]\n  exports?: Export[]\n  /**\n   * This will call fileManager.add instead of fileManager.addOrAppend, adding the source when the files already exists\n   * This will also ignore the combinefiles utils\n   * @default `false`\n   */\n  override?: boolean\n  /**\n   * Use extra meta, this is getting used to generate the barrel/index files.\n   */\n  meta?: TMeta\n  /**\n   * Override if a file can be exported by the BarrelManager\n   * @default true\n   */\n  exportable?: boolean\n  /**\n   * This will override `process.env[key]` inside the `source`, see `getFileSource`.\n   */\n  env?: NodeJS.ProcessEnv\n  /**\n   * The name of the language being used. This can be TypeScript, JavaScript and still have another ext.\n   */\n  language?: string\n}\n"]}