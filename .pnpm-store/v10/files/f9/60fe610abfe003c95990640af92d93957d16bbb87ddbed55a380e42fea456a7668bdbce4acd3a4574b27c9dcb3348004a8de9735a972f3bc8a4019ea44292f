{"version":3,"sources":["/home/runner/work/kubb/kubb/packages/react/dist/chunk-IYEDWCWH.cjs","../src/components/index.ts","../src/components/Function.tsx","../src/shared/utils/getParams.ts","../src/components/Text.tsx","../src/components/Type.tsx","../src/components/Const.tsx"],"names":["item","key","parsedItem","import_jsx_runtime","createJSDocBlockText"],"mappings":"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","file":"/home/runner/work/kubb/kubb/packages/react/dist/chunk-IYEDWCWH.cjs","sourcesContent":[null,"export type { RootContextProps as AppContextProps } from './Root.tsx'\nexport type { ParserLanguage } from './Parser.tsx'\nexport { Parser, TypeScript } from './Parser.tsx'\nexport { File } from './File.tsx'\nexport { Function } from './Function.tsx'\nexport { Text } from './Text.tsx'\nexport { Type } from './Type.tsx'\nexport { Const } from './Const.tsx'\nexport { App } from './App.tsx'\n","import { createJSDocBlockText } from '@kubb/core/transformers'\n\nimport { getParams, isParamItems } from '../shared/utils/getParams.ts'\nimport { Text } from './Text.tsx'\n\nimport type { ReactElement } from 'react'\nimport type { Params } from '../shared/utils/getParams.ts'\nimport type { JSDoc, KubbNode } from '../types.ts'\n\ntype Props = {\n  /**\n   * Name of the function.\n   */\n  name: string\n  /**\n   * Parameters/options/props that need to be used.\n   */\n  params?: string | Params\n  /**\n   * Does this function need to be exported.\n   */\n  export?: boolean\n  /**\n   * Does the function has async/promise behaviour.\n   * This will also add `Promise<returnType>` as the returnType.\n   */\n  async?: boolean\n  /**\n   * Generics that needs to be added for TypeScript.\n   */\n  generics?: string | string[]\n\n  /**\n   * ReturnType(see async for adding Promise type).\n   */\n  returnType?: string\n  /**\n   * Options for JSdocs.\n   */\n  JSDoc?: JSDoc\n  children?: KubbNode\n}\n\nexport function Function({ name, export: canExport, async, generics, params, returnType, JSDoc, children }: Props): KubbNode {\n  return (\n    <>\n      {JSDoc?.comments && (\n        <>\n          {createJSDocBlockText({ comments: JSDoc?.comments })}\n          <br />\n        </>\n      )}\n      {canExport && (\n        <Text>\n          export\n          <Text.Space />\n        </Text>\n      )}\n      {async && (\n        <Text>\n          async\n          <Text.Space />\n        </Text>\n      )}\n      <Text>function {name}</Text>\n      {generics && (\n        <>\n          <Text>{'<'}</Text>\n          <Text>{Array.isArray(generics) ? generics.join(', ').trim() : generics}</Text>\n          <Text>{'>'}</Text>\n        </>\n      )}\n      {isParamItems(params) ? <Text>({getParams(params, { type: 'constructor' })})</Text> : <Text>({params})</Text>}\n      {returnType && !async && <Text>: {returnType}</Text>}\n      {returnType && async && (\n        <Text>\n          : Promise{'<'}\n          {returnType}\n          {'>'}\n        </Text>\n      )}\n      <Text>{' {'}</Text>\n      <br />\n      <Text indentSize={2}>{children}</Text>\n      <br />\n      <Text>{'}'}</Text>\n      <br />\n    </>\n  )\n}\n\ntype ArrowFunctionProps = Props & {\n  /**\n   * Create Arrow function in one line\n   */\n  singleLine?: boolean\n}\n\nexport function ArrowFunction({ name, export: canExport, async, generics, params, returnType, JSDoc, singleLine, children }: ArrowFunctionProps): KubbNode {\n  return (\n    <>\n      {JSDoc?.comments && (\n        <>\n          {createJSDocBlockText({ comments: JSDoc?.comments })}\n          <br />\n        </>\n      )}\n      {canExport && (\n        <Text>\n          export\n          <Text.Space />\n        </Text>\n      )}\n      <Text>\n        const {name} =<Text.Space />\n      </Text>\n      {async && (\n        <Text>\n          async\n          <Text.Space />\n        </Text>\n      )}\n      {generics && (\n        <>\n          <Text>{'<'}</Text>\n          <Text>{Array.isArray(generics) ? generics.join(', ').trim() : generics}</Text>\n          <Text>{'>'}</Text>\n        </>\n      )}\n      {isParamItems(params) ? <Text>({getParams(params, { type: 'constructor' })})</Text> : <Text>({params})</Text>}\n      {returnType && !async && <Text>: {returnType}</Text>}\n      {returnType && async && (\n        <Text>\n          : Promise{'<'}\n          {returnType}\n          {'>'}\n        </Text>\n      )}\n      {singleLine && (\n        <>\n          <Text>{' => '}</Text>\n          <Text indentSize={2}>{children}</Text>\n          <br />\n        </>\n      )}\n\n      {!singleLine && (\n        <>\n          <Text>{' => {'}</Text>\n          <br />\n          <Text indentSize={2}>{children}</Text>\n          <br />\n          <Text>{'}'}</Text>\n          <br />\n        </>\n      )}\n    </>\n  )\n}\n/**\n *\n * @deprecated\n */\ntype CallFunctionProps = {\n  /**\n   * Name of the caller.\n   */\n  name: string\n  to: ReactElement<Props>\n}\n\n/**\n *\n * @deprecated\n */\nexport function CallFunction({ name, to }: CallFunctionProps) {\n  const { params, name: fnName, generics, async } = to.props\n\n  return (\n    <>\n      const <Text>{name}</Text>\n      <Text> = </Text>\n      {async && (\n        <Text>\n          await\n          <Text.Space />\n        </Text>\n      )}\n      {fnName}\n      {generics && (\n        <>\n          <Text>{'<'}</Text>\n          <Text>{Array.isArray(generics) ? generics.join(', ').trim() : generics}</Text>\n          <Text>{'>'}</Text>\n        </>\n      )}\n      {isParamItems(params) ? <Text>({getParams(params, { type: 'call' })})</Text> : <Text>({params})</Text>}\n      <br />\n    </>\n  )\n}\n/**\n *\n * @deprecated\n */\ntype ReturnFunctionProps = {\n  children: KubbNode\n}\n/**\n *\n * @deprecated\n */\nexport function ReturnFunction({ children }: ReturnFunctionProps) {\n  return (\n    <Text indentSize={2}>\n      return <Text>{children}</Text>\n    </Text>\n  )\n}\n\nFunction.Arrow = ArrowFunction\n/**\n *\n * @deprecated\n */\nFunction.Call = CallFunction\n/**\n *\n * @deprecated\n */\nFunction.Return = ReturnFunction\n\nexport const Fun = Function\n","import { camelCase } from '@kubb/core/transformers'\nimport { orderBy } from 'natural-orderby'\n\nexport type Param = {\n  /**\n   * `object` will return the pathParams as an object.\n   *\n   * `inline` will return the pathParams as comma separated params.\n   * @default `'inline'`\n   * @private\n   */\n  mode?: 'object' | 'inline' | 'inlineSpread'\n  type?: 'string' | 'number' | (string & {})\n  optional?: boolean\n  /**\n   * @example test = \"default\"\n   */\n  default?: string\n  /**\n   * Used for no TypeScript(with mode object)\n   * @example test: \"default\"\n   */\n  value?: string\n  children?: Params\n}\n\ntype ParamItem =\n  | (Pick<Param, 'mode' | 'type' | 'value'> & {\n      optional?: true\n      default?: never\n      children?: Params\n    })\n  | (Pick<Param, 'mode' | 'type' | 'value'> & {\n      optional?: false\n      default?: string\n      children?: Params\n    })\n\nexport type Params = Record<string, Param | undefined>\n\ntype Options = {\n  type: 'constructor' | 'call'\n}\n\nfunction order(items: Array<[key: string, item?: ParamItem]>) {\n  return orderBy(\n    items.filter(Boolean),\n    [\n      ([_key, item]) => {\n        if (item?.children) {\n          return undefined\n        }\n        return !item?.default\n      },\n      ([_key, item]) => {\n        if (item?.children) {\n          return undefined\n        }\n        return !item?.optional\n      },\n    ],\n    ['desc', 'desc'],\n  )\n}\n\nfunction parseChild(key: string, item: ParamItem, options: Options): string[] {\n  const entries = order(Object.entries(item.children as ParamItem))\n\n  const types: string[] = []\n  const names: string[] = []\n\n  const optional = entries.every(([_key, item]) => item?.optional)\n\n  entries.forEach(([key, entryItem]) => {\n    if (entryItem) {\n      if (options.type === 'call') {\n        names.push(...parseItem(key, { ...entryItem, type: undefined }))\n      } else {\n        names.push(\n          ...parseItem(key, {\n            ...entryItem,\n            type: undefined,\n            value: undefined,\n          }),\n        )\n      }\n\n      if (entries.some(([_key, item]) => item?.type)) {\n        types.push(...parseItem(key, { ...entryItem, default: undefined }))\n      }\n    }\n  })\n\n  const name = item.mode === 'inline' ? key : names.length ? `{ ${names.join(', ')} }` : ''\n\n  const type = item.type ? item.type : types.length ? `{ ${types.join('; ')} }` : undefined\n\n  return parseItem(name, {\n    type: options.type === 'constructor' ? type : undefined,\n    default: item.default ? item.default : undefined,\n    optional: !item.default ? optional : undefined,\n  } as ParamItem)\n}\n\nfunction parseItem(name: string, item: ParamItem): string[] {\n  const acc = []\n\n  if (item.type) {\n    if (item.optional) {\n      acc.push(`${name}?: ${item.type}`)\n    } else {\n      acc.push(`${name}: ${item.type}${item.default ? ` = ${item.default}` : ''}`)\n    }\n  } else if (item.default) {\n    acc.push(`${name} = ${item.default}`)\n  } else if (item.value) {\n    acc.push(`${name} : ${item.value}`)\n  } else if (item.mode === 'inlineSpread') {\n    acc.push(`... ${name}`)\n  } else {\n    acc.push(name)\n  }\n\n  return acc\n}\n\nexport function getParams(items: Params, options: Options): string {\n  const entries = order(Object.entries(items as Record<string, ParamItem | undefined>))\n\n  return entries\n    .reduce((acc, [key, item]) => {\n      if (!item) {\n        return acc\n      }\n\n      if (item.children) {\n        if (Object.keys(item.children).length === 0) {\n          return acc\n        }\n\n        if (item.mode === 'inlineSpread') {\n          return [...acc, getParams(item.children!, options)]\n        }\n\n        const parsedItem = parseChild(key, item, options)\n\n        return [...acc, ...parsedItem]\n      }\n\n      const parsedItem = parseItem(camelCase(key), item)\n\n      return [...acc, ...parsedItem]\n    }, [] as string[])\n    .join(', ')\n}\n\nexport function isParamItems(items: any): items is Params {\n  return typeof items !== 'string' && items && Object.keys(items)?.length\n}\n","import { createJSDocBlockText } from '@kubb/core/transformers'\n\nimport { useIndent } from '../hooks/useIndent.ts'\n\nimport type { JSDoc, KubbNode } from '../types.ts'\n\ntype Props = {\n  /**\n   * Change the indent.\n   * @default 0\n   */\n  indentSize?: number\n  children?: KubbNode\n}\n\nexport function Text({ indentSize = 0, children }: Props): KubbNode {\n  const indentBefore = useIndent({ size: indentSize })\n  const indentChildren = useIndent({ size: 4, children })\n\n  return (\n    <kubb-text>\n      {indentBefore}\n      {indentChildren ? indentChildren : children}\n    </kubb-text>\n  )\n}\n\ntype ConstProps = Props & {\n  /**\n   * Name of the const.\n   */\n  name: string\n  /**\n   * Does this const need to be exported.\n   */\n  export?: boolean\n  /**\n   * Options for JSdocs.\n   */\n  JSDoc?: JSDoc\n}\n\n/**\n * @deprecated\n */\nexport function Const({ name, export: canExport, JSDoc, children }: ConstProps): KubbNode {\n  return (\n    <>\n      {JSDoc?.comments && (\n        <>\n          {createJSDocBlockText({ comments: JSDoc?.comments })}\n          <br />\n        </>\n      )}\n      {canExport && (\n        <Text>\n          export\n          <Text.Space />\n        </Text>\n      )}\n      <Text>\n        const {name} =<Text.Space />\n      </Text>\n\n      <Text>{children}</Text>\n    </>\n  )\n}\n\ntype SpaceProps = {\n  /**\n   * Change the indent\n   * @default 1\n   */\n  size?: number\n}\n\nfunction Space({ size = 1 }: SpaceProps): KubbNode {\n  const indentBefore = useIndent({ size })\n\n  return <kubb-text>{indentBefore}</kubb-text>\n}\n\nText.Space = Space\n/**\n * @deprecated\n */\nText.Const = Const\n","import { createJSDocBlockText } from '@kubb/core/transformers'\n\nimport { Text } from './Text.tsx'\n\nimport type { JSDoc, KubbNode } from '../types.ts'\n\ntype Props = {\n  /**\n   * Name of the type, this needs to start with a capital letter.\n   */\n  name: string\n  /**\n   * Does this type need to be exported.\n   */\n  export?: boolean\n  /**\n   * Options for JSdocs.\n   */\n  JSDoc?: JSDoc\n  children?: KubbNode\n}\n\nexport function Type({ name, export: canExport, JSDoc, children }: Props): KubbNode {\n  if (name.charAt(0).toUpperCase() !== name.charAt(0)) {\n    throw new Error('Name should start with a capital letter(see TypeScript types)')\n  }\n\n  return (\n    <>\n      {JSDoc?.comments && (\n        <>\n          {createJSDocBlockText({ comments: JSDoc?.comments })}\n          <br />\n        </>\n      )}\n      {canExport && (\n        <Text>\n          export\n          <Text.Space />\n        </Text>\n      )}\n      <Text>\n        type {name} =\n        <Text.Space />\n      </Text>\n      <Text>{children}</Text>\n      <br />\n    </>\n  )\n}\n","import { createJSDocBlockText } from '@kubb/core/transformers'\n\nimport { Text } from './Text.tsx'\n\nimport type { JSDoc, KubbNode } from '../types.ts'\n\ntype Props = {\n  /**\n   * Name of the const\n   */\n  name: string\n  /**\n   * Does this type need to be exported.\n   */\n  export?: boolean\n  /**\n   * Options for JSdocs.\n   */\n  JSDoc?: JSDoc\n  /**\n   * Use of `const` assertions\n   */\n  asConst?: boolean\n  children?: KubbNode\n}\n\nexport function Const({ name, export: canExport, JSDoc, asConst, children }: Props): KubbNode {\n  return (\n    <>\n      {JSDoc?.comments && (\n        <>\n          {createJSDocBlockText({ comments: JSDoc?.comments })}\n          <br />\n        </>\n      )}\n      {canExport && (\n        <Text>\n          export\n          <Text.Space />\n        </Text>\n      )}\n      <Text>\n        const {name} =\n        <Text.Space />\n      </Text>\n      <Text>{children}</Text>\n      {asConst && (\n        <Text>\n          <Text.Space />\n          as const\n        </Text>\n      )}\n      <br />\n    </>\n  )\n}\n"]}